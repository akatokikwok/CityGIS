<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <title>UE5 Map Engine</title>
    <style>
        /* ================= 1. åŸºç¡€æ ·å¼ ================= */
        html, body, #map_container { width: 100%; height: 100%; overflow: hidden; margin: 0; padding: 0; font-family: "å¾®è½¯é›…é»‘"; }
        .anchorBL, .BMap_cpyCtrl { display: none; } 

        /* æ ‡ç­¾æ ·å¼ */
        .BMapLabel {
            background: transparent !important; border: none !important;
            font-size: 14px !important; font-weight: bold !important;
            text-shadow: 1px 1px 2px black, -1px -1px 2px black;
            pointer-events: none; 
        }

        /* ================= 2. æ‚¬æµ®æ ·å¼å·¥å…·æ¡ ================= */
        #style_toolbox {
            display: none; position: fixed; top: 20px; right: 20px;
            background: rgba(255, 255, 255, 0.95); padding: 15px; border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2); z-index: 9990; width: 220px;
            backdrop-filter: blur(5px); border: 1px solid #eee;
        }
        #style_toolbox h4 { margin: 0 0 10px 0; font-size: 14px; color: #333; border-bottom: 1px solid #eee; padding-bottom: 5px; }
        .tool-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; font-size: 13px; color: #555; }
        input[type=color] { border: none; width: 40px; height: 25px; cursor: pointer; background: none; }
        input[type=range] { width: 100px; cursor: pointer; }
        .val-display { font-size: 12px; color: #007bff; font-weight: bold; width: 30px; text-align: right; }

        /* ================= 3. æ¨¡å¼é€‰æ‹©å¼¹çª— ================= */
        #mode_select_modal {
            display: none; position: fixed; 
            left: 50%; top: 50%; transform: translate(-50%, -50%);
            z-index: 10000; background: white; width: 320px; padding: 25px;
            border-radius: 16px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); text-align: center;
        }
        #mode_select_modal h3 { margin: 0 0 20px 0; color: #333; }
        .mode-btn {
            display: block; width: 100%; padding: 15px; margin-bottom: 15px;
            border: 2px solid #eee; border-radius: 10px; background: #f9f9f9;
            cursor: pointer; transition: 0.2s; text-align: left;
        }
        .mode-btn:hover { border-color: #007bff; background: #eef7ff; }
        .mode-btn strong { display: block; font-size: 16px; margin-bottom: 4px; color: #333; }
        .mode-btn span { font-size: 12px; color: #666; }

        /* ================= 4. ä¿å­˜å¼¹çª— ================= */
        #save_modal {
            display: none; position: fixed; 
            left: 50%; bottom: 80px; transform: translateX(-50%);
            z-index: 9999; background: rgba(255, 255, 255, 0.98); backdrop-filter: blur(12px);
            width: 280px; padding: 20px; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            border: 1px solid #eee; animation: popUp 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }
        @keyframes popUp { from { bottom: -200px; opacity: 0; } to { bottom: 80px; opacity: 1; } }
        #save_modal h4 { margin: 0 0 10px 0; font-size: 16px; color: #333; text-align: center; }
        .input-label { font-size: 12px; color: #666; margin-bottom: 4px; display: block; }
        select, input[type=text] { width: 100%; padding: 8px; margin-bottom: 12px; box-sizing: border-box; border: 1px solid #ddd; border-radius: 6px; outline: none; font-size: 14px; }
        #parent_container { display: none; background: #f9f9f9; padding: 8px; border-radius: 6px; margin-bottom: 10px; border: 1px dashed #ccc;}
        .btn-group { display: flex; justify-content: space-between; gap: 10px; margin-top: 10px;}
        .btn-group button { flex: 1; padding: 8px; cursor: pointer; border: none; border-radius: 6px; color: white; font-weight: bold; }
        #btn_confirm { background-color: #007bff; } #btn_confirm:hover { background-color: #0056b3; }
        #btn_cancel { background-color: #6c757d; } #btn_cancel:hover { background-color: #5a6268; }
        
        /* å¸é™„å¤é€‰æ¡†æ ·å¼ */
        .checkbox-row { display: flex; align-items: center; justify-content: center; margin-bottom: 12px; padding:8px; background:#f0f8ff; border-radius:6px; cursor: pointer; border:1px dashed #a0cfff;}
        .checkbox-row input { width: auto; margin-right: 8px; cursor: pointer; }
        .checkbox-row strong { font-size:13px; color:#0056b3; }

        /* ================= 5. æç¤ºæ¡ ================= */
        #hint_bar {
            display: none; position: fixed; top: 100px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 14px;
            z-index: 9998; pointer-events: none;
        }
    </style>
    
    <script type="text/javascript" src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
    
    <script src="turf.min.js"></script>
</head>
<body>
    <div id="map_container"></div>
    <div id="hint_bar">æ“ä½œæç¤º...</div>

    <div id="style_toolbox">
        <h4>ğŸ¨ ç»˜å›¾æ ·å¼æ¿</h4>
        <div class="tool-row"> 
            <span>å¡«å……é¢œè‰²</span> <input type="color" id="tool_color" value="#3388ff" onchange="updateStyleState()"> 
        </div>
        <div class="tool-row"> 
            <span>ä¸é€æ˜åº¦</span> <input type="range" id="tool_opacity" min="0.1" max="1.0" step="0.1" value="0.5" oninput="updateStyleState()"> 
            <span id="opacity_val" class="val-display">0.5</span> 
        </div>
        <div style="font-size:10px; color:#999; margin-top:5px;">* ç»˜åˆ¶æ—¶å®æ—¶ç”Ÿæ•ˆ<br>* WASD ç§»åŠ¨åœ°å›¾</div>
    </div>

    <div id="mode_select_modal">
        <h3>ğŸ› ï¸ é€‰æ‹©ç»˜åˆ¶æ–¹æ¡ˆ</h3>
        <div class="mode-btn" onclick="startDraw('Freehand')">
            <strong>æ–¹æ¡ˆä¸€ï¼šæ‰‹ç»˜æ‹–æ‹½</strong> <span>æŒ‰ä½å·¦é”®æ‹–åŠ¨ï¼Œæ¾å¼€å³é—­åˆã€‚</span>
        </div>
        <div class="mode-btn" onclick="startDraw('Polyline')">
            <strong>æ–¹æ¡ˆäºŒï¼šç‚¹å¯¹ç‚¹æŠ˜çº¿</strong> <span>ç‚¹å‡»å®šç‚¹ï¼ŒåŒå‡»é—­åˆã€‚</span>
        </div>
        <div style="margin-top:15px; font-size:12px; color:#999; cursor:pointer;" onclick="setMode('browse')">å–æ¶ˆè¿”å›</div>
    </div>

    <div id="save_modal">
        <h4 id="modal_title">åŒºåŸŸä¿å­˜</h4>
        
        <label class="checkbox-row">
            <input type="checkbox" id="snap_toggle" checked> 
            <strong>ğŸ§² è‡ªåŠ¨å¸é™„è´´åˆ (Snap)</strong>
        </label>

        <div id="color_filter_box"> 
            <span class="input-label">åˆ†æç»“æœ:</span> 
            <select id="color_selector"> 
                <option value="yellow">ğŸŸ¡ æ–°æ‹“å±•åŒº</option> 
                <option value="purple">ğŸŸ£ å•ä¾§è¦†ç›–</option> 
                <option value="pink">ğŸŒ¸ é‡å æ ¸å¿ƒ</option> 
                <option value="all">ğŸ’  æ‰€æœ‰åŒºåŸŸ</option> 
            </select> 
        </div>
        <span class="input-label">å½’å±å±‚çº§:</span> 
        <select id="type_selector" onchange="onTypeChanged()"> 
            <option value="District">1çº§ - åŒºé•‡</option> 
            <option value="Street" selected>2çº§ - è¡—é“</option> 
            <option value="Community">3çº§ - å»ºç­‘/å°åŒº</option> 
            <option value="Reconstruct">âš¡ é‡æ„å›¾å—</option> 
        </select>
        <div id="parent_container"> 
            <span class="input-label" id="parent_label">é™„ç€åˆ°:</span> 
            <select id="parent_selector"><option value="">è¯·é€‰æ‹©...</option></select> 
        </div>
        <span class="input-label">åŒºåŸŸåç§°:</span> <input type="text" id="poly_name_input" placeholder="è¯·è¾“å…¥åç§°">
        <div class="btn-group"> 
            <button id="btn_cancel" onclick="closeModal()">ä¸¢å¼ƒ</button> 
            <button id="btn_confirm" onclick="confirmSave()">ä¿å­˜</button> 
        </div>
    </div>

<script>
    // 1. å…¨å±€é”™è¯¯æ•æ‰ (å°†JSé”™è¯¯å‘é€å›UE5)
    window.onerror = function(msg, url, line) { 
        console.log("UE_ERROR:JS_Error:" + msg + " Line:" + line); 
    };
    
    // å±è”½å³é”®
    document.oncontextmenu = function() { return false; }; 
    
    // æ£€æŸ¥ Turf æ˜¯å¦åŠ è½½
    if (typeof turf === 'undefined') {
        alert("ä¸¥é‡é”™è¯¯: turf.min.js æœªåŠ è½½ï¼è¯·æ£€æŸ¥ Content/HTML ç›®å½•ä¸‹æ˜¯å¦æœ‰è¯¥æ–‡ä»¶ã€‚");
    }

    // åˆå§‹åŒ–åœ°å›¾ (ä¸Šæµ·äººæ°‘å¹¿åœº)
    var map = new BMapGL.Map("map_container");
    map.centerAndZoom(new BMapGL.Point(121.474, 31.233), 17);
    map.enableScrollWheelZoom(true); 
    map.setTilt(0);
    
    const MOVE_SPEED = 15; 

    // å…¨å±€çŠ¶æ€æœº
    var appState = {
        mode: 'browse', 
        drawMethod: 'None', 
        currentStyle: { color: '#3388ff', opacity: 0.5, textColor: '#ffffff' }, // é»˜è®¤æ ·å¼
        polygons: [], 
        drawPath: [], 
        tempPolyline: null, 
        tempMouseLine: null,
        canSnapClose: false, 
        snapHintCircle: null, 
        analysisOverlays: [], 
        tempResultData: [],
        isSaving: false, 
        isDrawing: false 
    };
    var ID_COUNTER = 1; 
    var DEFAULT_NAME_IDX = 1; 

    console.log("UE_LOG: Map Engine Loaded Successfully");

    // ================= 2. çŠ¶æ€ç®¡ç†ä¸æ¨¡å¼åˆ‡æ¢ =================
    window.updateStyleState = function() {
        var col = document.getElementById('tool_color').value;
        var op = parseFloat(document.getElementById('tool_opacity').value);
        document.getElementById('opacity_val').innerText = op;
        appState.currentStyle.color = col;
        appState.currentStyle.opacity = op;
        if (appState.isDrawing && appState.tempPolyline) appState.tempPolyline.setStrokeColor(col);
    };

    window.setMode = function(mode) {
        console.log("UE_LOG: Switching Mode to " + mode);
        try {
            appState.mode = mode;
            closeModal(); 
            clearAnalysis(); 
            clearTemp();
            
            // é‡ç½®ç»˜å›¾çŠ¶æ€
            appState.isDrawing = false; 
            appState.drawPath = [];
            appState.drawMethod = 'None'; 

            document.getElementById('mode_select_modal').style.display = 'none';
            var toolbox = document.getElementById('style_toolbox');
            
            if (mode === 'edit') {
                if(toolbox) toolbox.style.display = 'block';
                map.disableDragging();
                document.getElementById('mode_select_modal').style.display = 'block';
            } 
            else if (mode === 'reconstruct') {
                if(toolbox) toolbox.style.display = 'none';
                map.disableDragging();
                appState.drawMethod = 'Freehand';
                appState.currentStyle = { color: '#800080', opacity: 0.5, textColor: '#ffffff' }; 
                showHint("WASDç§»åŠ¨ | å·¦é”®æ‰‹ç»˜ | é‡æ„æ¨¡å¼");
            }
            else { // browse
                if(toolbox) toolbox.style.display = 'none';
                map.enableDragging();
                map.setDefaultCursor("default");
                hideHint();
            }
        } catch(e) {
            console.log("UE_ERROR: setMode failed: " + e.message);
        }
    };

    window.startDraw = function(method) {
        appState.drawMethod = method;
        document.getElementById('mode_select_modal').style.display = 'none';
        
        updateStyleState(); // ç¡®ä¿é¢œè‰²æ­£ç¡®

        if (method === 'Freehand') {
            showHint("ã€WASDã€‘ç§»åŠ¨ | ã€å·¦é”®æ‹–æ‹½ã€‘ç»˜åˆ¶");
            map.setDefaultCursor("crosshair");
        } else {
            showHint("ã€WASDã€‘ç§»åŠ¨ | ã€å·¦é”®ç‚¹å‡»ã€‘å®šç‚¹ | ã€åŒå‡»ã€‘é—­åˆ");
            map.setDefaultCursor("crosshair");
        }
    };

    // ================= 3. WASD ç§»åŠ¨å¼•æ“ (æ¸¸æˆçº§å¹³æ»‘) =================
    var keyState = { w: false, a: false, s: false, d: false }; 
    var isPanningLoopActive = false;

    document.addEventListener('keydown', function(e) { 
        if(e.target.tagName === 'INPUT') return; 
        var k = e.key.toLowerCase(); 
        if(['w','a','s','d'].includes(k)) { 
            keyState[k] = true; 
            if(!isPanningLoopActive) { isPanningLoopActive=true; panMapLoop(); } 
        } 
    });
    document.addEventListener('keyup', function(e) { 
        var k = e.key.toLowerCase(); 
        if(['w','a','s','d'].includes(k)) keyState[k] = false; 
    });

    function panMapLoop() { 
        if (!keyState.w && !keyState.a && !keyState.s && !keyState.d) { isPanningLoopActive = false; return; } 
        var centerPt = map.getCenter(); 
        var centerPx = map.pointToPixel(centerPt); 
        var dx = 0; var dy = 0; 
        // ç™¾åº¦åœ°å›¾åæ ‡ç³»ï¼šyå‘ä¸‹å¢åŠ 
        if (keyState.w) dy -= MOVE_SPEED; 
        if (keyState.s) dy += MOVE_SPEED; 
        if (keyState.a) dx -= MOVE_SPEED; 
        if (keyState.d) dx += MOVE_SPEED; 
        
        var newCenterPx = new BMapGL.Pixel(centerPx.x + dx, centerPx.y + dy); 
        var newCenterPt = map.pixelToPoint(newCenterPx); 
        map.setCenter(newCenterPt, { noAnimation: true }); 
        requestAnimationFrame(panMapLoop); 
    }

    // ================= 4. ç»˜å›¾äº‹ä»¶ç›‘å¬ =================
    var container = document.getElementById('map_container');

    container.addEventListener('mousedown', function(e) { 
        if(appState.mode === 'browse') return; 
        // é˜²æ­¢ç‚¹å‡»å¼¹çª—æ—¶è§¦å‘ç»˜å›¾
        if(e.target.closest('#save_modal') || e.target.closest('#mode_select_modal') || e.target.closest('#style_toolbox')) return; 
        
        if(e.button !== 0) return; // åªå“åº”å·¦é”®

        if (appState.drawMethod === 'Freehand') handleFreehandDown(e); 
        else if (appState.drawMethod === 'Polyline') handlePolylineDown(e); 
    });

    container.addEventListener('mousemove', function(e) { 
        if(appState.mode === 'browse') return; 
        if (appState.drawMethod === 'Freehand') handleFreehandMove(e); 
        else if (appState.drawMethod === 'Polyline') handlePolylineMove(e); 
    });

    container.addEventListener('mouseup', function(e) { 
        if(appState.mode === 'browse') return; 
        if (e.button !== 0) return; 
        if (appState.drawMethod === 'Freehand') handleFreehandUp(e); 
    });

    container.addEventListener('dblclick', function(e) { 
        if (appState.mode === 'browse') return; 
        if (appState.drawMethod === 'Polyline') finishPolyline(); 
    });

    // --- æ–¹æ¡ˆä¸€ï¼šæ‰‹ç»˜é€»è¾‘ ---
    function handleFreehandDown(e) { 
        if (!appState.isDrawing) { 
            appState.isDrawing = true; 
            var pt = map.pixelToPoint(new BMapGL.Pixel(e.clientX, e.clientY)); 
            appState.drawPath = [pt]; 
            appState.canSnapClose = false; 
        } 
    }
    function handleFreehandMove(e) { 
        if (appState.isDrawing) { 
            var currentPt = map.pixelToPoint(new BMapGL.Pixel(e.clientX, e.clientY)); 
            appState.drawPath.push(currentPt); 
            redrawTempPolyline(); 
            checkSnapProximity(currentPt); 
        } 
    }
    function handleFreehandUp(e) { 
        if (appState.isDrawing) { 
            appState.isDrawing = false; 
            finishDraw(); 
        } 
    }

    // --- æ–¹æ¡ˆäºŒï¼šæŠ˜çº¿é€»è¾‘ ---
    function handlePolylineDown(e) { 
        var pt = map.pixelToPoint(new BMapGL.Pixel(e.clientX, e.clientY)); 
        appState.drawPath.push(pt); 
        redrawTempPolyline(); 
        appState.isDrawing = true; 
    }
    function handlePolylineMove(e) { 
        if (appState.isDrawing && appState.drawPath.length > 0) { 
            var lastPt = appState.drawPath[appState.drawPath.length - 1]; 
            var mousePt = map.pixelToPoint(new BMapGL.Pixel(e.clientX, e.clientY)); 
            // ç»˜åˆ¶æ©¡çš®ç­‹è¾…åŠ©çº¿
            if (appState.tempMouseLine) map.removeOverlay(appState.tempMouseLine); 
            appState.tempMouseLine = new BMapGL.Polyline([lastPt, mousePt], { strokeColor: appState.currentStyle.color, strokeWeight: 2, strokeStyle: 'dashed' }); 
            map.addOverlay(appState.tempMouseLine); 
        } 
    }
    function finishPolyline() { 
        if (appState.drawPath.length < 3) return; 
        if (appState.tempMouseLine) map.removeOverlay(appState.tempMouseLine); 
        finishDraw(); 
    }

    // --- ç»˜å›¾è¾…åŠ© ---
    function redrawTempPolyline() { 
        if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline); 
        appState.tempPolyline = new BMapGL.Polyline(appState.drawPath, { strokeColor: appState.currentStyle.color, strokeWeight: 2 }); 
        map.addOverlay(appState.tempPolyline); 
    }
    
    function checkSnapProximity(currentPt) { 
        if(appState.drawPath.length < 10) return; 
        var startPt = appState.drawPath[0]; 
        var pixStart = map.pointToPixel(new BMapGL.Point(startPt.lng, startPt.lat)); 
        var pixCurrent = map.pointToPixel(new BMapGL.Point(currentPt.lng, currentPt.lat)); 
        var dist = Math.sqrt(Math.pow(pixStart.x - pixCurrent.x, 2) + Math.pow(pixStart.y - pixCurrent.y, 2)); 
        if(dist < 20) { 
            appState.canSnapClose = true; 
            if(!appState.snapHintCircle) { 
                appState.snapHintCircle = new BMapGL.Circle(new BMapGL.Point(startPt.lng, startPt.lat), 5, {strokeColor: "white", strokeWeight: 2, fillColor: "#FFD700", fillOpacity: 0.9}); 
                map.addOverlay(appState.snapHintCircle); 
            } 
        } else { 
            appState.canSnapClose = false; 
            if(appState.snapHintCircle) { 
                map.removeOverlay(appState.snapHintCircle); 
                appState.snapHintCircle = null; 
            } 
        } 
    }

    function finishDraw() { 
        if(appState.drawPath.length < 3) { clearTemp(); return; } 
        // è‡ªåŠ¨é—­åˆ
        if(appState.canSnapClose) appState.drawPath.push(appState.drawPath[0]); 
        else appState.drawPath.push(appState.drawPath[0]); 
        
        var coords = appState.drawPath.map(p => [p.lng, p.lat]); 
        var rawGeo = turf.polygon([coords]); 
        // ç®€åŒ–å‡ ä½•
        var simpleGeo = turf.simplify(rawGeo, {tolerance: 0.00001, highQuality: false}); 
        
        if(appState.mode === 'edit') prepareSingleSave(simpleGeo); 
        else if(appState.mode === 'reconstruct') executeAnalysis(simpleGeo); 
        
        clearTemp(); 
        hideHint(); 
    }

    // ================= 5. æ‹“æ‰‘å¸é™„ç®—æ³• (Snap) =================
    function snapPolygon(inputGeo) {
        // 1. è·å–æ‰€æœ‰ç°æœ‰é¡¶ç‚¹
        var existingPoints = [];
        appState.polygons.forEach(p => {
            if (p.geoJson && p.geoJson.geometry) {
                var coords = turf.coordAll(p.geoJson);
                existingPoints = existingPoints.concat(coords);
            }
        });

        // å¦‚æœæ²¡æœ‰é‚»å±…ï¼Œç›´æ¥è¿”å›
        if (existingPoints.length === 0) return inputGeo; 

        // 2. æ„å»ºç›®æ ‡ç‚¹é›†
        var targetPointsFC = turf.featureCollection(existingPoints.map(c => turf.point(c)));
        
        // 3. æ ¸å¿ƒä¿®æ”¹ï¼šå¤§å¹…å¢åŠ å¸é™„åŠå¾„ (å®¹é”™ç‡)
        // ä¹‹å‰æ˜¯ 0.015 (15ç±³)ï¼Œç°åœ¨æ”¹ä¸º 0.05 (50ç±³)
        // å¦‚æœä½ è§‰å¾—è¿˜ä¸å¤Ÿï¼Œå¯ä»¥æ”¹æˆ 0.08 æˆ– 0.1
        var SNAP_THRESHOLD = 0.05; 

        var oldCoords = inputGeo.geometry.coordinates;

        // 4. éå†å¹¶å¸é™„
        var newCoords = oldCoords.map(ring => {
            // ç”¨æ¥è¿‡æ»¤é‡å¤ç‚¹çš„ä¸´æ—¶æ•°ç»„
            var ringPoints = [];
            
            ring.forEach((ptCoords, idx) => {
                var fromPt = turf.point(ptCoords);
                var nearest = turf.nearestPoint(fromPt, targetPointsFC);
                var dist = turf.distance(fromPt, nearest); // å•ä½: km

                var finalCoords = ptCoords;

                if (dist < SNAP_THRESHOLD) {
                    console.log("âš¡ å¼ºåŠ›å¸é™„! è·ç¦»: " + (dist*1000).toFixed(1) + "ç±³");
                    finalCoords = nearest.geometry.coordinates; // å¼ºåˆ¶ç¬ç§»åˆ°é‚»å±…ç‚¹
                }
                
                // ç®€å•çš„å»é‡é€»è¾‘ï¼šé˜²æ­¢å¸é™„åè¿ç»­ä¸¤ç‚¹é‡åˆ
                if (ringPoints.length > 0) {
                    var lastPt = ringPoints[ringPoints.length - 1];
                    if (lastPt[0] === finalCoords[0] && lastPt[1] === finalCoords[1]) {
                        return; // è·³è¿‡é‡å¤ç‚¹
                    }
                }
                ringPoints.push(finalCoords);
            });

            // ç¡®ä¿é—­åˆ (é¦–å°¾ä¸€è‡´)
            if (ringPoints.length > 2) {
                var first = ringPoints[0];
                var last = ringPoints[ringPoints.length - 1];
                if (first[0] !== last[0] || first[1] !== last[1]) {
                    ringPoints.push(first);
                }
            }
            
            return ringPoints;
        });

        // 5. è¿”å›ä¿®æ­£åçš„ Polygon
        // ä½¿ç”¨ turf.cleanCoords æ¸…ç†ä¸€ä¸‹å¯èƒ½äº§ç”Ÿçš„å†—ä½™å…±çº¿ç‚¹
        var snappedPoly = turf.polygon(newCoords, inputGeo.properties);
        return turf.cleanCoords(snappedPoly);
    }

    // ================= 6. åˆ†æä¸ä¿å­˜é€»è¾‘ =================
    function executeAnalysis(polyX) { 
        clearAnalysis(); appState.tempResultData = []; 
        if(appState.polygons.length === 0) { prepareSingleSave(polyX); return; } 
        try { 
            var featX = turf.feature(polyX.geometry); 
            var existFeats = appState.polygons.map(p => turf.feature(p.geoJson.geometry)); 
            var unionC = null; 
            for(let i=0; i<existFeats.length; i++) { 
                for(let j=i+1; j<existFeats.length; j++) { 
                    var inter = turf.intersect(existFeats[i], existFeats[j]); 
                    if(inter) unionC = unionC ? turf.union(unionC, inter) : inter; 
                } 
            } 
            var interXC = unionC ? turf.intersect(featX, unionC) : null; 
            if(interXC) cacheResult(interXC, "#FFC0CB", 0.6, "é‡å æ ¸å¿ƒ", false, 'pink'); 
            var unionAll = existFeats[0]; 
            for(let i=1; i<existFeats.length; i++) unionAll = turf.union(unionAll, existFeats[i]); 
            var interTotal = turf.intersect(featX, unionAll); 
            var interPurple = (interTotal && interXC) ? turf.difference(interTotal, interXC) : interTotal; 
            if(interPurple) cacheResult(interPurple, "#800080", 0.4, "å•ä¾§è¦†ç›–", false, 'purple'); 
            var resE = turf.difference(featX, unionAll); 
            if(resE) cacheResult(resE, "yellow", 0.3, "æ–°æ‹“å±•åŒº", false, 'yellow'); 
            showModal(true); 
        } catch(e) { console.log("UE_ERROR:" + e.message); alert("åˆ†æé”™è¯¯"); } 
    }
    
    function cacheResult(geo, col, op, name, line, type) { 
        var geoms = flattenGeo(geo); 
        geoms.forEach(path => { 
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4}) : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1}); 
            map.addOverlay(ov); 
            appState.analysisOverlays.push(ov); 
        }); 
        if(!type) type = "Reconstruct"; 
        appState.tempResultData.push({geoJson:geo, color:col, opacity:op, rawType:type, isLine:line}); 
    }
    
    function prepareSingleSave(geoJson) { 
        appState.tempResultData = []; 
        cacheResult(geoJson, appState.currentStyle.color, appState.currentStyle.opacity, 'Temp', false, 'single'); 
        showModal(false); 
    }
    
    function showModal(isMulti) { 
        var modal = document.getElementById('save_modal'); 
        var colorBox = document.getElementById('color_filter_box'); 
        var colorSel = document.getElementById('color_selector'); 
        
        if(isMulti) { 
            colorBox.style.display = 'block'; 
            var hasYellow = appState.tempResultData.some(i => i.rawType === 'yellow');
            var hasPurple = appState.tempResultData.some(i => i.rawType === 'purple');
            var hasPink = appState.tempResultData.some(i => i.rawType === 'pink');
            updateOption(colorSel, 'yellow', hasYellow, "ğŸŸ¡ æ–°æ‹“å±•åŒº");
            updateOption(colorSel, 'purple', hasPurple, "ğŸŸ£ å•ä¾§è¦†ç›–");
            updateOption(colorSel, 'pink', hasPink, "ğŸŒ¸ é‡å æ ¸å¿ƒ");
            if (hasYellow) colorSel.value = 'yellow'; else if (hasPurple) colorSel.value = 'purple'; else if (hasPink) colorSel.value = 'pink'; else colorSel.value = 'all'; 
        } else { 
            colorBox.style.display = 'none'; 
        } 
        
        document.getElementById('poly_name_input').value = "æˆ‘çš„åŒºåŸŸ" + DEFAULT_NAME_IDX; 
        document.getElementById('type_selector').value = 'Street'; 
        onTypeChanged(); 
        modal.style.display = 'block'; 
    }

    function updateOption(sel, val, hasData, label) { for (var i=0; i<sel.options.length; i++) { if (sel.options[i].value === val) { if (!hasData) { sel.options[i].text = label + " [æ— æ•°æ®]"; sel.options[i].disabled = true; } else { sel.options[i].text = label; sel.options[i].disabled = false; } } } }
    function closeModal() { document.getElementById('save_modal').style.display = 'none'; clearAnalysis(); }
    
    window.onTypeChanged = function() { 
        var type = document.getElementById('type_selector').value; 
        var parentContainer = document.getElementById('parent_container'); 
        var parentSelector = document.getElementById('parent_selector'); 
        var parentLabel = document.getElementById('parent_label'); 
        parentSelector.innerHTML = '<option value="">è¯·é€‰æ‹©...</option>'; 
        var targetParentType = ""; 
        if (type === 'District') { parentContainer.style.display = 'none'; return; } 
        else if (type === 'Street') { targetParentType = 'District'; parentLabel.innerText = "éš¶å±äºå“ªä¸ªåŒºé•‡:"; } 
        else if (type === 'Community') { targetParentType = 'Street'; parentLabel.innerText = "éš¶å±äºå“ªä¸ªè¡—é“:"; } 
        else { parentContainer.style.display = 'none'; return; } 
        parentContainer.style.display = 'block'; 
        var parents = appState.polygons.filter(p => p.geoJson.properties.customType === targetParentType); 
        if (parents.length === 0) { 
            var opt = document.createElement('option'); opt.text = "âš ï¸ æš‚æ— ä¸Šçº§æ•°æ®"; opt.disabled = true; opt.selected = true; parentSelector.add(opt); 
        } else { 
            parents.forEach(p => { var opt = document.createElement('option'); opt.value = p.geoJson.properties.id; opt.text = p.geoJson.properties.name; parentSelector.add(opt); }); 
        } 
    };
    
    // --- æ ¸å¿ƒï¼šä¿å­˜ç¡®è®¤ (é›†æˆå¸é™„é€»è¾‘) ---
    window.confirmSave = function() { 
        if(appState.isSaving) return; 
        var nameInput = document.getElementById('poly_name_input').value || "æœªå‘½å"; 
        var selectedType = document.getElementById('type_selector').value; 
        var parentId = ""; 
        if (selectedType === 'Street' || selectedType === 'Community') { 
            var pSel = document.getElementById('parent_selector'); 
            parentId = pSel.value; 
            if (!parentId) { alert("è¯·é€‰æ‹©éš¶å±çš„çˆ¶çº§åŒºåŸŸï¼"); return; } 
        } 
        if(nameInput === "æˆ‘çš„åŒºåŸŸ" + DEFAULT_NAME_IDX) { DEFAULT_NAME_IDX++; } 
        var colorSel = document.getElementById('color_selector'); 
        var choice = (document.getElementById('color_filter_box').style.display === 'none') ? 'single' : colorSel.value; 
        var toSave = []; 
        if(choice === 'all' || choice === 'single') toSave = appState.tempResultData; 
        else toSave = appState.tempResultData.filter(i => i.rawType === choice); 
        if(toSave.length === 0) { alert("æ— æ•°æ®"); return; } 
        
        // --- æ ¸å¿ƒï¼šæ‰§è¡Œå¸é™„ ---
        var snapToggle = document.getElementById('snap_toggle');
        if (snapToggle && snapToggle.checked) {
            toSave.forEach((item) => {
                try {
                    // ä»…å¸é™„å¤šè¾¹å½¢
                    if (item.geoJson.geometry.type === 'Polygon') {
                        var snappedGeo = snapPolygon(item.geoJson);
                        if(snappedGeo) item.geoJson = snappedGeo; 
                    }
                } catch(e) { console.log("Snap Error: " + e.message); }
            });
        }

        document.getElementById('save_modal').style.display = 'none'; 
        appState.isSaving = true; 
        processSaveQueue(toSave, nameInput, selectedType, parentId, 0); 
    };

    function processSaveQueue(list, baseName, typeStr, pid, index) { 
        if(index >= list.length) { appState.tempResultData = []; appState.isSaving = false; return; } 
        var item = list[index]; 
        var finalName = (list.length > 1) ? (baseName + "_" + item.rawType + "_" + (index+1)) : baseName; 
        
        // è¯»å–å½“å‰æ ·å¼ä¸­çš„æ–‡å­—é¢œè‰²
        var txtColorToSave = appState.currentStyle.textColor || '#ffffff';
        
        addPermanent(item.geoJson, item.color, item.opacity, item.isLine, finalName, typeStr, pid, txtColorToSave); 
        setTimeout(function() { processSaveQueue(list, baseName, typeStr, pid, index + 1); }, 300); 
    }
    
    function addPermanent(geo, col, op, line, name, typeStr, parentId, txtCol) {
        var id = 'poly_' + (ID_COUNTER++);
        if(!parentId) parentId = "None"; 
        if(!txtCol) txtCol = "yellow"; // é»˜è®¤æ–‡å­—é»„è‰²

        geo.properties = { 
            id: id, name: name, svCol: col, svOp: op, svLine: line, 
            customType: typeStr, pid: parentId, svTxtCol: txtCol 
        };
        
        var polygonOverlays = [];
        var geoms = flattenGeo(geo);
        
        geoms.forEach(path => {
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4, strokeOpacity:op}) 
                          : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1});
            ov.addEventListener('click', function(){ window.focusPoly(id); });
            ov.customData = { id: id, type: typeStr }; 
            map.addOverlay(ov);
            polygonOverlays.push(ov);
        });

        // æ ‡ç­¾
        var label = null;
        try {
            var center = turf.centerOfMass(geo).geometry.coordinates;
            var labelPt = new BMapGL.Point(center[0], center[1]);
            label = new BMapGL.Label(name, { position: labelPt, offset: new BMapGL.Size(-20, -10) });
            label.setStyle({
                color: txtCol, backgroundColor: "transparent", border: "none",
                fontSize: "14px", fontWeight: "bold", textShadow: "1px 1px 2px black"
            });
            map.addOverlay(label);
        } catch(e) { console.log("Label Err"); }

        appState.polygons.push({ overlay: polygonOverlays, label: label, geoJson: geo });
        var randomTag = new Date().getTime(); 
        
        // 8å‚æ•°é€šä¿¡
        console.log("UE_ADD:" + id + "|" + name + "|" + typeStr + "|" + parentId + "|" + col + "|" + op + "|" + txtCol + "|" + randomTag);
    }

    // --- ä¾›C++è°ƒç”¨çš„æ›´æ–°æ¥å£ ---
    window.updatePolyAttributes = function(id, newName, newColor, newOpacity, newTxtCol) {
        var target = appState.polygons.find(p => p.geoJson.properties.id === id);
        if (!target) return;

        target.geoJson.properties.name = newName;
        target.geoJson.properties.svCol = newColor;
        target.geoJson.properties.svOp = newOpacity;
        target.geoJson.properties.svTxtCol = newTxtCol;

        var ovs = Array.isArray(target.overlay) ? target.overlay : [target.overlay];
        ovs.forEach(o => {
            if (o instanceof BMapGL.Polygon) {
                o.setFillColor(newColor); o.setStrokeColor(newColor); o.setFillOpacity(parseFloat(newOpacity));
            } else if (o instanceof BMapGL.Polyline) {
                o.setStrokeColor(newColor); o.setStrokeOpacity(parseFloat(newOpacity));
            }
        });

        if (target.label) {
            target.label.setContent(newName);
            target.label.setStyle({ color: newTxtCol });
        }
    };

    window.deletePoly = function(id) { var targets = appState.polygons.filter(p => p.geoJson.properties.id === id); if(targets.length > 0) { targets.forEach(t => { var ovs = Array.isArray(t.overlay) ? t.overlay : [t.overlay]; ovs.forEach(o => map.removeOverlay(o)); if(t.label) map.removeOverlay(t.label); }); appState.polygons = appState.polygons.filter(p => p.geoJson.properties.id !== id); console.log("UE_LOG: Deleted poly " + id); } };
    window.clearTemp = function() { appState.drawPath=[]; if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline); if(appState.tempMouseLine) map.removeOverlay(appState.tempMouseLine); if(appState.snapHintCircle) { map.removeOverlay(appState.snapHintCircle); appState.snapHintCircle = null; } appState.canSnapClose = false; appState.isDrawing = false; }
    window.exportMap = function(fname) { var data = appState.polygons.map(p => p.geoJson); console.log("UE_SAVE:" + fname + "|" + JSON.stringify(data)); };
    window.importMap = function(json) { map.clearOverlays(); appState.polygons=[]; var list = JSON.parse(json); list.forEach((g, i) => { var p = g.properties; setTimeout(() => addPermanent(g, p.svCol, p.svOp, p.svLine, p.name, p.customType, p.pid, p.svTxtCol), i * 50); }); };
    
    // ================= 8. è¾…åŠ©å‡½æ•° =================
    function showHint(text) { var bar = document.getElementById('hint_bar'); if(bar) { bar.innerText = text; bar.style.display = 'block'; } }
    function hideHint() { var bar = document.getElementById('hint_bar'); if(bar) bar.style.display = 'none'; }
    function flattenGeo(geo) { var coords = []; if(!geo || !geo.geometry) return []; var type = geo.geometry.type; if(type === 'MultiPolygon') coords = geo.geometry.coordinates.map(c=>c[0]); else if(type === 'Polygon') coords = [geo.geometry.coordinates[0]]; else if(type === 'LineString') coords = [geo.geometry.coordinates]; else if(type === 'MultiLineString') coords = geo.geometry.coordinates; var res = []; coords.forEach(c => { if(c) res.push(c.map(p => new BMapGL.Point(p[0], p[1]))); }); return res; }
    function clearAnalysis() { appState.analysisOverlays.forEach(o=>map.removeOverlay(o)); appState.analysisOverlays=[]; appState.tempResultData=[]; }
    window.focusPoly = function(id) { var targets = appState.polygons.filter(p => p.geoJson.properties.id === id); if(targets.length > 0) { var allPoints = []; targets.forEach(t => { var ovs = Array.isArray(t.overlay) ? t.overlay : [t.overlay]; ovs.forEach(o => { var path = o.getPath(); if(path) allPoints = allPoints.concat(path); var oldColor = o.getStrokeColor(); o.setStrokeColor("red"); o.setStrokeWeight(4); setTimeout(() => { o.setStrokeColor(oldColor); o.setStrokeWeight(1); }, 1000); }); }); if(allPoints.length > 0) { map.setViewport(allPoints, { margins: [60, 60, 60, 300], enableAnimation: true, zoomFactor: 0 }); } } else { console.log("UE_ERROR: Not found " + id); } };
    window.filterPolys = function(filterType) { appState.polygons.forEach(p => { var pType = p.geoJson.properties.customType || "Normal"; var ovs = Array.isArray(p.overlay) ? p.overlay : [p.overlay]; var shouldShow = (filterType === 'all') || (pType === filterType); ovs.forEach(o => { if(shouldShow) o.show(); else o.hide(); }); }); };
</script>
</body>
</html>