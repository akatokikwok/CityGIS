<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <style>
        html, body, #map_container { width: 100%; height: 100%; overflow: hidden; margin: 0; font-family: "å¾®è½¯é›…é»‘"; }
        .anchorBL, .BMap_cpyCtrl { display: none; } 

        /* æ ‡ç­¾æ ·å¼ (è‡ªå®šä¹‰è¦†ç›–ç‰©) */
        .BMapLabel {
            background: transparent !important;
            border: none !important;
            color: white !important;
            font-size: 14px !important;
            font-weight: bold !important;
            text-shadow: 1px 1px 2px black, -1px -1px 2px black;
            pointer-events: none; /* è®©é¼ æ ‡ç©¿é€æ ‡ç­¾ï¼Œä¸å½±å“ç‚¹å‡»å¤šè¾¹å½¢ */
        }

        /* ... (ä¿ç•™ä¹‹å‰çš„æ ·å¼å·¥å…·æ¡ã€å¼¹çª—æ ·å¼ï¼Œå®Œå…¨ä¸å˜) ... */
        #style_toolbox {
            display: none; position: fixed; top: 20px; right: 20px;
            background: rgba(255, 255, 255, 0.95); padding: 15px; border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2); z-index: 9990; width: 200px;
            backdrop-filter: blur(5px); border: 1px solid #eee;
        }
        #style_toolbox h4 { margin: 0 0 10px 0; font-size: 14px; color: #333; border-bottom: 1px solid #eee; padding-bottom: 5px; }
        .tool-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; font-size: 13px; color: #555; }
        input[type=color] { border: none; width: 40px; height: 25px; cursor: pointer; background: none; }
        input[type=range] { width: 100px; cursor: pointer; }
        .val-display { font-size: 12px; color: #007bff; font-weight: bold; width: 30px; text-align: right; }

        #mode_select_modal {
            display: none; position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%);
            z-index: 10000; background: white; width: 320px; padding: 25px;
            border-radius: 16px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); text-align: center;
        }
        #mode_select_modal h3 { margin: 0 0 20px 0; color: #333; }
        .mode-btn { display: block; width: 100%; padding: 15px; margin-bottom: 15px; border: 2px solid #eee; border-radius: 10px; background: #f9f9f9; cursor: pointer; transition: 0.2s; text-align: left; }
        .mode-btn:hover { border-color: #007bff; background: #eef7ff; }
        .mode-btn strong { display: block; font-size: 16px; margin-bottom: 4px; color: #333; }
        .mode-btn span { font-size: 12px; color: #666; }

        #save_modal {
            display: none; position: fixed; left: 50%; bottom: 80px; transform: translateX(-50%);
            z-index: 9999; background: rgba(255, 255, 255, 0.98); backdrop-filter: blur(12px);
            width: 280px; padding: 20px; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            border: 1px solid #eee; animation: popUp 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }
        @keyframes popUp { from { bottom: -200px; opacity: 0; } to { bottom: 80px; opacity: 1; } }
        #save_modal h4 { margin: 0 0 10px 0; font-size: 16px; color: #333; text-align: center; }
        .input-label { font-size: 12px; color: #666; margin-bottom: 4px; display: block; }
        select, input[type=text] { width: 100%; padding: 8px; margin-bottom: 12px; box-sizing: border-box; border: 1px solid #ddd; border-radius: 6px; outline: none; font-size: 14px; }
        #parent_container { display: none; background: #f9f9f9; padding: 8px; border-radius: 6px; margin-bottom: 10px; border: 1px dashed #ccc;}
        .btn-group { display: flex; justify-content: space-between; gap: 10px; margin-top: 10px;}
        .btn-group button { flex: 1; padding: 8px; cursor: pointer; border: none; border-radius: 6px; color: white; font-weight: bold; }
        #btn_confirm { background-color: #007bff; } #btn_confirm:hover { background-color: #0056b3; }
        #btn_cancel { background-color: #6c757d; } #btn_cancel:hover { background-color: #5a6268; }
        #hint_bar {
            display: none; position: fixed; top: 60px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 14px;
            z-index: 9998; pointer-events: none;
        }
    </style>
    <script type="text/javascript" src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
    <script src="turf.min.js"></script>
</head>
<body>
    <div id="map_container"></div>
    <div id="hint_bar">æ“ä½œæç¤º...</div>

    <div id="style_toolbox">
        <h4>ğŸ¨ ç»˜å›¾æ ·å¼æ¿</h4>
        <div class="tool-row">
            <span>å¡«å……é¢œè‰²</span> <input type="color" id="tool_color" value="#3388ff" onchange="updateStyleState()">
        </div>
        <div class="tool-row">
            <span>ä¸é€æ˜åº¦</span> <input type="range" id="tool_opacity" min="0.1" max="1.0" step="0.1" value="0.5" oninput="updateStyleState()">
            <span id="opacity_val" class="val-display">0.5</span>
        </div>
        <div style="font-size:10px; color:#999; margin-top:5px;">* ç»˜åˆ¶æ—¶å®æ—¶ç”Ÿæ•ˆ<br>* WASD ç§»åŠ¨åœ°å›¾</div>
    </div>

    <div id="mode_select_modal">
        <h3>ğŸ› ï¸ é€‰æ‹©ç»˜åˆ¶æ–¹æ¡ˆ</h3>
        <div class="mode-btn" onclick="startDraw('Freehand')">
            <strong>æ–¹æ¡ˆä¸€ï¼šæ‰‹ç»˜æ‹–æ‹½</strong> <span>æŒ‰ä½å·¦é”®æ‹–åŠ¨ï¼Œæ¾å¼€å³é—­åˆã€‚</span>
        </div>
        <div class="mode-btn" onclick="startDraw('Polyline')">
            <strong>æ–¹æ¡ˆäºŒï¼šç‚¹å¯¹ç‚¹æŠ˜çº¿</strong> <span>ç‚¹å‡»å®šç‚¹ï¼ŒåŒå‡»é—­åˆã€‚</span>
        </div>
        <div style="margin-top:15px; font-size:12px; color:#999; cursor:pointer;" onclick="setMode('browse')">å–æ¶ˆè¿”å›</div>
    </div>

    <div id="save_modal">
        <h4 id="modal_title">åŒºåŸŸä¿å­˜</h4>
        <div id="color_filter_box">
            <span class="input-label">åˆ†æç»“æœ:</span>
            <select id="color_selector">
                <option value="yellow">ğŸŸ¡ æ–°æ‹“å±•åŒº</option>
                <option value="purple">ğŸŸ£ å•ä¾§è¦†ç›–</option>
                <option value="pink">ğŸŒ¸ é‡å æ ¸å¿ƒ</option>
                <option value="all">ğŸ’  æ‰€æœ‰åŒºåŸŸ</option>
            </select>
        </div>
        <span class="input-label">å½’å±å±‚çº§:</span>
        <select id="type_selector" onchange="onTypeChanged()">
            <option value="District">1çº§ - åŒºé•‡</option>
            <option value="Street" selected>2çº§ - è¡—é“</option>
            <option value="Community">3çº§ - å»ºç­‘/å°åŒº</option>
            <option value="Reconstruct">âš¡ é‡æ„å›¾å—</option>
        </select>
        <div id="parent_container">
            <span class="input-label" id="parent_label">é™„ç€åˆ°:</span> <select id="parent_selector"><option value="">è¯·é€‰æ‹©...</option></select>
        </div>
        <span class="input-label">åŒºåŸŸåç§°:</span> <input type="text" id="poly_name_input" placeholder="è¯·è¾“å…¥åç§°">
        <div class="btn-group">
            <button id="btn_cancel" onclick="closeModal()">ä¸¢å¼ƒ</button>
            <button id="btn_confirm" onclick="confirmSave()">ä¿å­˜</button>
        </div>
    </div>
</body>
</html>
<script>
    window.onerror = function(msg, url, line) { console.log("UE_ERROR:JS_Error:" + msg + " Line:" + line); };
    document.oncontextmenu = function() { return false; }; 
    var map = new BMapGL.Map("map_container");
    map.centerAndZoom(new BMapGL.Point(121.474, 31.233), 17); // ä¸Šæµ·
    map.enableScrollWheelZoom(true); map.setTilt(0);
    const MOVE_SPEED = 15; 

    var appState = {
        mode: 'browse', drawMethod: 'None', currentStyle: { color: '#3388ff', opacity: 0.5 },
        polygons: [], drawPath: [], tempPolyline: null, tempMouseLine: null,
        canSnapClose: false, snapHintCircle: null, analysisOverlays: [], tempResultData: [],
        isSaving: false, isDrawing: false 
    };
    var ID_COUNTER = 1; var DEFAULT_NAME_IDX = 1; 

    // ... (æ¨¡å¼æ§åˆ¶ã€WASDã€ç»˜å›¾äº‹ä»¶ ä¿æŒä¸å˜ï¼Œçœç•¥ä»¥èŠ‚çœç¯‡å¹…ï¼Œè¯·ç›´æ¥å¤ç”¨ä¹‹å‰çš„é€»è¾‘) ...
    // ... æ ¸å¿ƒå˜åŒ–åœ¨ä¸‹æ–¹çš„ addPermanent å’Œ updatePolyAttributes ...

    window.updateStyleState = function() {
        var col = document.getElementById('tool_color').value;
        var op = parseFloat(document.getElementById('tool_opacity').value);
        document.getElementById('opacity_val').innerText = op;
        appState.currentStyle = { color: col, opacity: op };
        if (appState.isDrawing && appState.tempPolyline) appState.tempPolyline.setStrokeColor(col);
    };
    window.setMode = function(mode) {
        appState.mode = mode; closeModal(); clearAnalysis(); clearTemp();
        document.getElementById('mode_select_modal').style.display = 'none';
        var toolbox = document.getElementById('style_toolbox');
        if (mode === 'edit') toolbox.style.display = 'block'; else toolbox.style.display = 'none';
        hideHint();
        if(mode === 'browse') { map.enableDragging(); map.setDefaultCursor("default"); }
        else if (mode === 'edit') { map.disableDragging(); document.getElementById('mode_select_modal').style.display = 'block'; }
        else if (mode === 'reconstruct') { map.disableDragging(); appState.drawMethod = 'Freehand'; appState.currentStyle = { color: '#0000ff', opacity: 0.5 }; toolbox.style.display = 'none'; showHint("WASDç§»åŠ¨ | å·¦é”®æ‰‹ç»˜ | é‡æ„æ¨¡å¼"); }
    };
    window.startDraw = function(method) {
        appState.drawMethod = method; document.getElementById('mode_select_modal').style.display = 'none'; updateStyleState();
        if (method === 'Freehand') { showHint("ã€WASDã€‘ç§»åŠ¨ | ã€å·¦é”®æ‹–æ‹½ã€‘ç»˜åˆ¶"); map.setDefaultCursor("crosshair"); } 
        else { showHint("ã€WASDã€‘ç§»åŠ¨ | ã€å·¦é”®ç‚¹å‡»ã€‘å®šç‚¹ | ã€åŒå‡»ã€‘é—­åˆ"); map.setDefaultCursor("crosshair"); }
    };
    
    // ... (WASD Logic ä¿æŒä¸å˜) ...
    var keyState = { w: false, a: false, s: false, d: false }; var isPanningLoopActive = false;
    document.addEventListener('keydown', function(e) { if(e.target.tagName === 'INPUT') return; var k = e.key.toLowerCase(); if(['w','a','s','d'].includes(k)) { keyState[k] = true; if(!isPanningLoopActive) { isPanningLoopActive=true; panMapLoop(); } } });
    document.addEventListener('keyup', function(e) { var k = e.key.toLowerCase(); if(['w','a','s','d'].includes(k)) keyState[k] = false; });
    function panMapLoop() { if (!keyState.w && !keyState.a && !keyState.s && !keyState.d) { isPanningLoopActive = false; return; } var centerPt = map.getCenter(); var centerPx = map.pointToPixel(centerPt); var dx = 0; var dy = 0; if (keyState.w) dy -= MOVE_SPEED; if (keyState.s) dy += MOVE_SPEED; if (keyState.a) dx -= MOVE_SPEED; if (keyState.d) dx += MOVE_SPEED; var newCenterPx = new BMapGL.Pixel(centerPx.x + dx, centerPx.y + dy); var newCenterPt = map.pixelToPoint(newCenterPx); map.setCenter(newCenterPt, { noAnimation: true }); requestAnimationFrame(panMapLoop); }

    // ... (Mouse Events ä¿æŒä¸å˜) ...
    var container = document.getElementById('map_container');
    container.addEventListener('mousedown', function(e) { if(appState.mode === 'browse') return; if(e.target.closest('#save_modal') || e.target.closest('#mode_select_modal') || e.target.closest('#style_toolbox')) return; if(e.button !== 0) return; if (appState.drawMethod === 'Freehand') handleFreehandDown(e); else if (appState.drawMethod === 'Polyline') handlePolylineDown(e); });
    container.addEventListener('mousemove', function(e) { if(appState.mode === 'browse') return; if (appState.drawMethod === 'Freehand') handleFreehandMove(e); else if (appState.drawMethod === 'Polyline') handlePolylineMove(e); });
    container.addEventListener('mouseup', function(e) { if(appState.mode === 'browse') return; if(e.button !== 0) return; if (appState.drawMethod === 'Freehand') handleFreehandUp(e); });
    container.addEventListener('dblclick', function(e) { if (appState.mode === 'browse') return; if (appState.drawMethod === 'Polyline') finishPolyline(); });

    // ... (Drawing Logic ä¿æŒä¸å˜) ...
    function handleFreehandDown(e) { if (!appState.isDrawing) { appState.isDrawing = true; var pt = map.pixelToPoint(new BMapGL.Pixel(e.clientX, e.clientY)); appState.drawPath = [pt]; appState.canSnapClose = false; } }
    function handleFreehandMove(e) { if (appState.isDrawing) { var currentPt = map.pixelToPoint(new BMapGL.Pixel(e.clientX, e.clientY)); appState.drawPath.push(currentPt); redrawTempPolyline(); checkSnapProximity(currentPt); } }
    function handleFreehandUp(e) { if (appState.isDrawing) { appState.isDrawing = false; finishDraw(); } }
    function handlePolylineDown(e) { var pt = map.pixelToPoint(new BMapGL.Pixel(e.clientX, e.clientY)); appState.drawPath.push(pt); redrawTempPolyline(); appState.isDrawing = true; }
    function handlePolylineMove(e) { if (appState.isDrawing && appState.drawPath.length > 0) { var lastPt = appState.drawPath[appState.drawPath.length - 1]; var mousePt = map.pixelToPoint(new BMapGL.Pixel(e.clientX, e.clientY)); if (appState.tempMouseLine) map.removeOverlay(appState.tempMouseLine); appState.tempMouseLine = new BMapGL.Polyline([lastPt, mousePt], { strokeColor: appState.currentStyle.color, strokeWeight: 2, strokeStyle: 'dashed' }); map.addOverlay(appState.tempMouseLine); } }
    function finishPolyline() { if (appState.drawPath.length < 3) return; if (appState.tempMouseLine) map.removeOverlay(appState.tempMouseLine); finishDraw(); }
    function redrawTempPolyline() { if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline); appState.tempPolyline = new BMapGL.Polyline(appState.drawPath, { strokeColor: appState.currentStyle.color, strokeWeight: 2 }); map.addOverlay(appState.tempPolyline); }
    function checkSnapProximity(currentPt) { if(appState.drawPath.length < 10) return; var startPt = appState.drawPath[0]; var pixStart = map.pointToPixel(new BMapGL.Point(startPt.lng, startPt.lat)); var pixCurrent = map.pointToPixel(new BMapGL.Point(currentPt.lng, currentPt.lat)); var dist = Math.sqrt(Math.pow(pixStart.x - pixCurrent.x, 2) + Math.pow(pixStart.y - pixCurrent.y, 2)); if(dist < 20) { appState.canSnapClose = true; if(!appState.snapHintCircle) { appState.snapHintCircle = new BMapGL.Circle(new BMapGL.Point(startPt.lng, startPt.lat), 5, {strokeColor: "white", strokeWeight: 2, fillColor: "#FFD700", fillOpacity: 0.9}); map.addOverlay(appState.snapHintCircle); } } else { appState.canSnapClose = false; if(appState.snapHintCircle) { map.removeOverlay(appState.snapHintCircle); appState.snapHintCircle = null; } } }
    function finishDraw() { if(appState.drawPath.length < 3) { clearTemp(); return; } if(appState.canSnapClose) appState.drawPath.push(appState.drawPath[0]); else appState.drawPath.push(appState.drawPath[0]); var coords = appState.drawPath.map(p => [p.lng, p.lat]); var rawGeo = turf.polygon([coords]); var simpleGeo = turf.simplify(rawGeo, {tolerance: 0.00001, highQuality: false}); if(appState.mode === 'edit') prepareSingleSave(simpleGeo); else if(appState.mode === 'reconstruct') executeAnalysis(simpleGeo); clearTemp(); hideHint(); }

    // ... (Analysis & Save Logic ä¿æŒä¸å˜) ...
    function executeAnalysis(polyX) { clearAnalysis(); appState.tempResultData = []; if(appState.polygons.length === 0) { prepareSingleSave(polyX); return; } try { var featX = turf.feature(polyX.geometry); var existFeats = appState.polygons.map(p => turf.feature(p.geoJson.geometry)); var unionC = null; for(let i=0; i<existFeats.length; i++) { for(let j=i+1; j<existFeats.length; j++) { var inter = turf.intersect(existFeats[i], existFeats[j]); if(inter) unionC = unionC ? turf.union(unionC, inter) : inter; } } var interXC = unionC ? turf.intersect(featX, unionC) : null; if(interXC) cacheResult(interXC, "#FFC0CB", 0.6, "é‡å æ ¸å¿ƒ", false, 'pink'); var unionAll = existFeats[0]; for(let i=1; i<existFeats.length; i++) unionAll = turf.union(unionAll, existFeats[i]); var interTotal = turf.intersect(featX, unionAll); var interPurple = (interTotal && interXC) ? turf.difference(interTotal, interXC) : interTotal; if(interPurple) cacheResult(interPurple, "#800080", 0.4, "å•ä¾§è¦†ç›–", false, 'purple'); var resE = turf.difference(featX, unionAll); if(resE) cacheResult(resE, "yellow", 0.3, "æ–°æ‹“å±•åŒº", false, 'yellow'); showModal(true); } catch(e) { console.log("UE_ERROR:" + e.message); alert("åˆ†æé”™è¯¯"); } }
    function cacheResult(geo, col, op, name, line, type) { var geoms = flattenGeo(geo); geoms.forEach(path => { var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4}) : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1}); map.addOverlay(ov); appState.analysisOverlays.push(ov); }); if(!type) type = "Reconstruct"; appState.tempResultData.push({geoJson:geo, color:col, opacity:op, rawType:type, isLine:line}); }
    function prepareSingleSave(geoJson) { appState.tempResultData = []; cacheResult(geoJson, appState.currentStyle.color, appState.currentStyle.opacity, 'Temp', false, 'single'); showModal(false); }
    function showModal(isMulti) { var modal = document.getElementById('save_modal'); var colorBox = document.getElementById('color_filter_box'); var colorSel = document.getElementById('color_selector'); if(isMulti) { colorBox.style.display = 'block'; var hasYellow = appState.tempResultData.some(i => i.rawType === 'yellow'); var hasPurple = appState.tempResultData.some(i => i.rawType === 'purple'); var hasPink = appState.tempResultData.some(i => i.rawType === 'pink'); updateOption(colorSel, 'yellow', hasYellow, "ğŸŸ¡ æ–°æ‹“å±•åŒº"); updateOption(colorSel, 'purple', hasPurple, "ğŸŸ£ å•ä¾§è¦†ç›–"); updateOption(colorSel, 'pink', hasPink, "ğŸŒ¸ é‡å æ ¸å¿ƒ"); if (hasYellow) colorSel.value = 'yellow'; else if (hasPurple) colorSel.value = 'purple'; else if (hasPink) colorSel.value = 'pink'; else colorSel.value = 'all'; } else { colorBox.style.display = 'none'; } document.getElementById('poly_name_input').value = "æˆ‘çš„åŒºåŸŸ" + DEFAULT_NAME_IDX; document.getElementById('type_selector').value = 'Street'; onTypeChanged(); modal.style.display = 'block'; }
    function updateOption(sel, val, hasData, label) { for (var i=0; i<sel.options.length; i++) { if (sel.options[i].value === val) { if (!hasData) { sel.options[i].text = label + " [æ— æ•°æ®]"; sel.options[i].disabled = true; } else { sel.options[i].text = label; sel.options[i].disabled = false; } } } }
    function closeModal() { document.getElementById('save_modal').style.display = 'none'; clearAnalysis(); }
    window.onTypeChanged = function() { var type = document.getElementById('type_selector').value; var parentContainer = document.getElementById('parent_container'); var parentSelector = document.getElementById('parent_selector'); var parentLabel = document.getElementById('parent_label'); parentSelector.innerHTML = '<option value="">è¯·é€‰æ‹©...</option>'; var targetParentType = ""; if (type === 'District') { parentContainer.style.display = 'none'; return; } else if (type === 'Street') { targetParentType = 'District'; parentLabel.innerText = "éš¶å±äºå“ªä¸ªçˆ¶å•ä½:"; } else if (type === 'Community') { targetParentType = 'Street'; parentLabel.innerText = "éš¶å±äºå“ªä¸ªè¡—é“:"; } else { parentContainer.style.display = 'none'; return; } parentContainer.style.display = 'block'; var parents = appState.polygons.filter(p => p.geoJson.properties.customType === targetParentType); if (parents.length === 0) { var opt = document.createElement('option'); opt.text = "âš ï¸ æš‚æ— ä¸Šçº§æ•°æ®"; opt.disabled = true; opt.selected = true; parentSelector.add(opt); } else { parents.forEach(p => { var opt = document.createElement('option'); opt.value = p.geoJson.properties.id; opt.text = p.geoJson.properties.name; parentSelector.add(opt); }); } };
    window.confirmSave = function() { if(appState.isSaving) return; var nameInput = document.getElementById('poly_name_input').value || "æœªå‘½å"; var selectedType = document.getElementById('type_selector').value; var parentId = ""; if (selectedType === 'Street' || selectedType === 'Community') { var pSel = document.getElementById('parent_selector'); parentId = pSel.value; if (!parentId) { alert("è¯·é€‰æ‹©éš¶å±çš„çˆ¶çº§åŒºåŸŸï¼"); return; } } if(nameInput === "æˆ‘çš„åŒºåŸŸ" + DEFAULT_NAME_IDX) { DEFAULT_NAME_IDX++; } var colorSel = document.getElementById('color_selector'); var choice = (document.getElementById('color_filter_box').style.display === 'none') ? 'single' : colorSel.value; var toSave = []; if(choice === 'all' || choice === 'single') toSave = appState.tempResultData; else toSave = appState.tempResultData.filter(i => i.rawType === choice); if(toSave.length === 0) { alert("æ— æ•°æ®"); return; } document.getElementById('save_modal').style.display = 'none'; appState.isSaving = true; processSaveQueue(toSave, nameInput, selectedType, parentId, 0); };
    function processSaveQueue(list, baseName, typeStr, pid, index) { if(index >= list.length) { appState.tempResultData = []; appState.isSaving = false; return; } var item = list[index]; var finalName = (list.length > 1) ? (baseName + "_" + item.rawType + "_" + (index+1)) : baseName; addPermanent(item.geoJson, item.color, item.opacity, item.isLine, finalName, typeStr, pid); setTimeout(function() { processSaveQueue(list, baseName, typeStr, pid, index + 1); }, 300); }
    
    // ==========================================
    // æ ¸å¿ƒæ–°å¢å‡½æ•°ï¼šæ·»åŠ /æ›´æ–° å¤šè¾¹å½¢ä¸æ ‡ç­¾
    // ==========================================
    function addPermanent(geo, col, op, line, name, typeStr, parentId) {
        var id = 'poly_' + (ID_COUNTER++);
        if(!parentId) parentId = "None"; 
        
        geo.properties = { 
            id: id, name: name, svCol: col, svOp: op, svLine: line, 
            customType: typeStr, pid: parentId 
        };
        
        var polygonOverlays = [];
        var geoms = flattenGeo(geo);
        
        geoms.forEach(path => {
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4, strokeOpacity:op}) 
                          : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1});
            ov.addEventListener('click', function(){ window.focusPoly(id); });
            ov.customData = { id: id, type: typeStr }; 
            map.addOverlay(ov);
            polygonOverlays.push(ov);
        });

        // --- æ ¸å¿ƒéœ€æ±‚2ï¼šåˆ›å»ºä¸­å¿ƒæ–‡å­—æ ‡ç­¾ ---
        var center = turf.centerOfMass(geo).geometry.coordinates; // è®¡ç®—é‡å¿ƒ [lng, lat]
        var labelPt = new BMapGL.Point(center[0], center[1]);
        
        // åˆ›å»ºæ ‡ç­¾
        var label = new BMapGL.Label(name, { position: labelPt, offset: new BMapGL.Size(-20, -10) });
        // è®¾ç½®æ ·å¼ (ç™½è‰²æ— èƒŒæ™¯ï¼Œé˜´å½±é˜²çœ‹ä¸æ¸…)
        label.setStyle({
            color: "white", backgroundColor: "transparent", border: "none",
            fontSize: "14px", fontWeight: "bold", textShadow: "1px 1px 2px black"
        });
        map.addOverlay(label);

        appState.polygons.push({
            overlay: polygonOverlays, // æ•°ç»„
            label: label,             // ä¿å­˜labelå¼•ç”¨ï¼Œæ–¹ä¾¿åˆ é™¤æˆ–æ”¹å
            geoJson: geo
        });
        
        var randomTag = new Date().getTime(); 
        // ä¼ è¾“é¢œè‰²å’Œé€æ˜åº¦ç»™UE5: ID|Name|Type|ParentID|Color|Opacity|Time
        console.log("UE_ADD:" + id + "|" + name + "|" + typeStr + "|" + parentId + "|" + col + "|" + op + "|" + randomTag);
    }

    // --- æ ¸å¿ƒéœ€æ±‚1ï¼šæä¾›ç»™C++è°ƒç”¨çš„æ›´æ–°æ¥å£ ---
    window.updatePolyAttributes = function(id, newName, newColor, newOpacity) {
        var target = appState.polygons.find(p => p.geoJson.properties.id === id);
        if (!target) return;

        // 1. æ›´æ–°æ•°æ®
        target.geoJson.properties.name = newName;
        target.geoJson.properties.svCol = newColor;
        target.geoJson.properties.svOp = newOpacity;

        // 2. æ›´æ–°å¤šè¾¹å½¢æ ·å¼
        var ovs = Array.isArray(target.overlay) ? target.overlay : [target.overlay];
        ovs.forEach(o => {
            if (o instanceof BMapGL.Polygon) {
                o.setFillColor(newColor);
                o.setStrokeColor(newColor);
                o.setFillOpacity(parseFloat(newOpacity));
            } else if (o instanceof BMapGL.Polyline) {
                o.setStrokeColor(newColor);
                o.setStrokeOpacity(parseFloat(newOpacity));
            }
        });

        // 3. æ›´æ–°æ ‡ç­¾æ–‡å­—
        if (target.label) {
            target.label.setContent(newName);
        }
    };

    // --- æ›´æ–°åˆ é™¤é€»è¾‘ï¼šåŒæ—¶ä¹Ÿåˆ é™¤æ ‡ç­¾ ---
    window.deletePoly = function(id) { 
        var targets = appState.polygons.filter(p => p.geoJson.properties.id === id); 
        if(targets.length > 0) { 
            targets.forEach(t => { 
                var ovs = Array.isArray(t.overlay) ? t.overlay : [t.overlay]; 
                ovs.forEach(o => map.removeOverlay(o)); 
                if(t.label) map.removeOverlay(t.label); // åˆ é™¤æ ‡ç­¾
            }); 
            appState.polygons = appState.polygons.filter(p => p.geoJson.properties.id !== id); 
            console.log("UE_LOG: Deleted poly " + id); 
        } 
    };

    // ... è¾…åŠ©å‡½æ•°ä¸å˜ ...
    function showHint(text) { var bar = document.getElementById('hint_bar'); bar.innerText = text; bar.style.display = 'block'; }
    function hideHint() { document.getElementById('hint_bar').style.display = 'none'; }
    function clearTemp() { appState.drawPath=[]; if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline); if(appState.tempMouseLine) map.removeOverlay(appState.tempMouseLine); if(appState.snapHintCircle) { map.removeOverlay(appState.snapHintCircle); appState.snapHintCircle = null; } appState.canSnapClose = false; appState.isDrawing = false; }
    window.focusPoly = function(id) { var targets = appState.polygons.filter(p => p.geoJson.properties.id === id); if(targets.length > 0) { var allPoints = []; targets.forEach(t => { var ovs = Array.isArray(t.overlay) ? t.overlay : [t.overlay]; ovs.forEach(o => { var path = o.getPath(); if(path) allPoints = allPoints.concat(path); var oldColor = o.getStrokeColor(); o.setStrokeColor("red"); o.setStrokeWeight(4); setTimeout(() => { o.setStrokeColor(oldColor); o.setStrokeWeight(1); }, 1000); }); }); if(allPoints.length > 0) { map.setViewport(allPoints, { margins: [60, 60, 60, 300], enableAnimation: true, zoomFactor: 0 }); } } else { console.log("UE_ERROR: Not found " + id); } };
    window.filterPolys = function(filterType) { appState.polygons.forEach(p => { var pType = p.geoJson.properties.customType || "Normal"; var ovs = Array.isArray(p.overlay) ? p.overlay : [p.overlay]; var shouldShow = (filterType === 'all') || (pType === filterType); ovs.forEach(o => { if(shouldShow) o.show(); else o.hide(); }); }); };
    function flattenGeo(geo) { var coords = []; if(!geo || !geo.geometry) return []; var type = geo.geometry.type; if(type === 'MultiPolygon') coords = geo.geometry.coordinates.map(c=>c[0]); else if(type === 'Polygon') coords = [geo.geometry.coordinates[0]]; else if(type === 'LineString') coords = [geo.geometry.coordinates]; else if(type === 'MultiLineString') coords = geo.geometry.coordinates; var res = []; coords.forEach(c => { if(c) res.push(c.map(p => new BMapGL.Point(p[0], p[1]))); }); return res; }
    function clearAnalysis() { appState.analysisOverlays.forEach(o=>map.removeOverlay(o)); appState.analysisOverlays=[]; appState.tempResultData=[]; }
    window.exportMap = function(fname) { var data = appState.polygons.map(p => p.geoJson); console.log("UE_SAVE:" + fname + "|" + JSON.stringify(data)); };
    window.importMap = function(json) { map.clearOverlays(); appState.polygons=[]; var list = JSON.parse(json); list.forEach((g, i) => { var p = g.properties; setTimeout(() => addPermanent(g, p.svCol, p.svOp, p.svLine, p.name, p.customType, p.pid), i * 50); }); };
</script>
