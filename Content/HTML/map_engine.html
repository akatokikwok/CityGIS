<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <style>
        html, body, #map_container { width: 100%; height: 100%; overflow: hidden; margin: 0; }
        /* 隐藏百度版权(商业发布需获授权) */
        .anchorBL, .BMap_cpyCtrl { display: none; } 
    </style>
    <script type="text/javascript" src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
    <script src="turf.min.js"></script>
</head>
<body>
    <div id="map_container"></div>
</body>
</html>

<script>
    // ============================================
    // 1. 全局配置与状态
    // ============================================
    var map = new BMapGL.Map("map_container");
    map.centerAndZoom(new BMapGL.Point(116.404, 39.915), 18); 
    map.enableScrollWheelZoom(true); 
    map.setTilt(60); 

    var appState = {
        mode: 'browse', // browse | edit | snap | reconstruct
        polygons: [],   // 存现有板块: {overlay, geoJson}
        
        // --- 手绘相关状态 ---
        isDrawing: false,
        drawPath: [],   // 实时手绘路径点
        tempPolyline: null, // 实时绘制的线
        
        // --- 分析结果缓存 (用于清理高亮) ---
        analysisOverlays: [] 
    };

    var ID_COUNTER = 1; 

    // ============================================
    // 2. 模式控制
    // ============================================
    window.setMode = function(modeName) {
        appState.mode = modeName;
        console.log("Mode:", modeName);
        
        clearAnalysis(); // 切换模式清理高亮
        clearTempDrawing();

        if(modeName === 'browse') {
            map.enableDragging();
        } else {
            // Edit, Snap, Reconstruct 模式下全部禁止地图拖拽，启用手绘
            map.disableDragging();
        }
    };

    // ============================================
    // 3. 核心交互：按住拖拽画图 (需求三)
    // ============================================
    
    // --- 鼠标按下：开始绘制 ---
    map.addEventListener('mousedown', function(e) {
        // 仅在非浏览模式下生效
        if(appState.mode === 'browse') return;

        appState.isDrawing = true;
        appState.drawPath = []; // 清空路径
        
        // 记录起点
        var pt = e.latlng;
        appState.drawPath.push(new BMapGL.Point(pt.lng, pt.lat));
    });

    // --- 鼠标移动：记录轨迹 ---
    map.addEventListener('mousemove', function(e) {
        if(!appState.isDrawing || appState.mode === 'browse') return;

        var pt = e.latlng;
        var lastPt = appState.drawPath[appState.drawPath.length - 1];

        // 节流：如果移动距离太小（小于0.00001度），不记录点，优化性能
        if (Math.abs(pt.lng - lastPt.lng) < 0.00001 && Math.abs(pt.lat - lastPt.lat) < 0.00001) {
            return;
        }

        appState.drawPath.push(new BMapGL.Point(pt.lng, pt.lat));

        // 实时绘制视觉反馈 (蓝色线)
        if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline);
        appState.tempPolyline = new BMapGL.Polyline(appState.drawPath, {
            strokeColor: "blue", strokeWeight: 2, strokeOpacity: 0.8
        });
        map.addOverlay(appState.tempPolyline);
    });

    // --- 鼠标抬起：结束绘制并闭合 ---
    map.addEventListener('mouseup', function(e) {
        if(!appState.isDrawing || appState.mode === 'browse') return;
        appState.isDrawing = false;

        // 至少要有3个点
        if(appState.drawPath.length < 3) {
            clearTempDrawing();
            return;
        }

        // 1. 自动闭合路径
        appState.drawPath.push(appState.drawPath[0]);

        // 2. 转换为 GeoJSON 并平滑处理 (Simplify)
        // 手绘的点极其密集，必须简化，否则后续计算会卡死
        var rawGeo = ptsToGeoJSON(appState.drawPath);
        var options = {tolerance: 0.00001, highQuality: false};
        var simplifiedGeo = turf.simplify(rawGeo, options);

        // 3. 根据模式分发逻辑
        if (appState.mode === 'edit') {
            // 编辑模式：直接生成板块
            finalizePolygon(simplifiedGeo);
        } 
        else if (appState.mode === 'reconstruct') {
            // 重构模式：执行复杂的重叠分析 (需求一 & 二)
            executeReconstructAnalysis(simplifiedGeo);
        }
        else if (appState.mode === 'snap') {
             // 吸附模式逻辑 (此处保留接口，逻辑同之前)
             // executeSnap(simplifiedGeo); 
        }

        clearTempDrawing();
    });

    // ============================================
    // 4. 核心算法：复杂重叠分析 (需求一 & 二)
    // ============================================
    function executeReconstructAnalysis(polyX) {
        // polyX 是我们手绘的区域 (X)
        // 目标：
        // 1. 找出 A 和 B 的重叠 C。
        // 2. X 与 C 重叠 -> 淡红色。
        // 3. X 与 (A U B) 重叠 但排除 C -> 紫色。
        // 4. 所有重叠的边线 -> 橙色。
        
        clearAnalysis(); // 清除上次的高亮

        if (appState.polygons.length === 0) {
            alert("地图上没有其他多边形，无法分析重叠。");
            return;
        }

        try {
            var featureX = turf.feature(polyX.geometry);
            var existingFeatures = appState.polygons.map(p => turf.feature(p.geoJson.geometry));

            // --- 步骤 A: 预计算现有的所有重叠 (C) ---
            // 这是一个 O(N^2) 操作，为了性能，我们只计算与 X BBox 相交的板块
            var preExistingOverlaps = []; // 存储所有的 C
            
            for (let i = 0; i < existingFeatures.length; i++) {
                for (let j = i + 1; j < existingFeatures.length; j++) {
                    var polyA = existingFeatures[i];
                    var polyB = existingFeatures[j];
                    
                    // 计算 A 和 B 的交集
                    var intersectionAB = turf.intersect(polyA, polyB);
                    if (intersectionAB) {
                        preExistingOverlaps.push(intersectionAB);
                    }
                }
            }

            // 合并所有的 C 成为一个大的 MultiPolygon (Existing_Overlap_Zone)
            var unionC = null;
            if (preExistingOverlaps.length > 0) {
                unionC = preExistingOverlaps[0];
                for (let k = 1; k < preExistingOverlaps.length; k++) {
                    unionC = turf.union(unionC, preExistingOverlaps[k]);
                }
            }

            // --- 步骤 B: 计算 X 与 C 的交集 (淡红色区域) ---
            var intersectionXC = null;
            if (unionC) {
                intersectionXC = turf.intersect(featureX, unionC);
                if (intersectionXC) {
                    renderHighlight(intersectionXC, "#FFC0CB", 0.6); // 淡红色
                }
            }

            // --- 步骤 C: 计算 X 与 其他部分的交集 (紫色区域) ---
            // 1. 计算 X 与 所有现有板块的并集 U 的交集 -> Total_Intersection
            var unionAllExisting = existingFeatures[0];
            for (let i = 1; i < existingFeatures.length; i++) {
                unionAllExisting = turf.union(unionAllExisting, existingFeatures[i]);
            }
            
            var intersectionTotal = turf.intersect(featureX, unionAllExisting);
            
            // 2. 从 Total 中 挖掉 XC，剩下的就是紫色区域
            var intersectionPurple = intersectionTotal;
            if (intersectionPurple && intersectionXC) {
                intersectionPurple = turf.difference(intersectionPurple, intersectionXC);
            }

            if (intersectionPurple) {
                renderHighlight(intersectionPurple, "#800080", 0.4); // 紫色
            }

            // --- 步骤 D: 绘制重叠边线 (橙色) ---
            // 我们提取 intersectionTotal 的边界
            if (intersectionTotal) {
                var lines = turf.polygonToLine(intersectionTotal);
                renderLines(lines, "#FFA500", 4); // 橙色粗线
            }

            // --- 步骤 E: 绘制 X 自身的剩余部分 (作为重构结果 E) ---
            // E = X - Total_Intersection
            var resultE = turf.difference(featureX, unionAllExisting);
            if (resultE) {
                // 这是最终重构产生的新区域，用我们标准的黄色高亮
                renderHighlight(resultE, "yellow", 0.2);
            }

        } catch (e) {
            console.error(e);
            alert("分析计算过载或几何错误，请尝试画得简单一点。");
        }
    }

    // ============================================
    // 5. 辅助渲染函数
    // ============================================
    
    // 渲染高亮面
    function renderHighlight(geoJson, color, opacity) {
        // 处理 MultiPolygon
        var geoms = [];
        if (geoJson.geometry.type === 'MultiPolygon') {
            geoJson.geometry.coordinates.forEach(coords => geoms.push(coords[0]));
        } else {
            geoms.push(geoJson.geometry.coordinates[0]);
        }

        geoms.forEach(loop => {
            var path = loop.map(p => new BMapGL.Point(p[0], p[1]));
            var overlay = new BMapGL.Polygon(path, {
                strokeColor: color, strokeWeight: 1, strokeOpacity: 1,
                fillColor: color, fillOpacity: opacity
            });
            map.addOverlay(overlay);
            appState.analysisOverlays.push(overlay);
        });
    }

    // 渲染高亮线
    function renderLines(geoJsonLine, color, weight) {
        var geoms = [];
        // 处理 MultiLineString 或 FeatureCollection
        if (geoJsonLine.type === 'FeatureCollection') {
            geoJsonLine.features.forEach(f => geoms.push(f.geometry.coordinates));
        } else if (geoJsonLine.geometry.type === 'MultiLineString') {
            geoms = geoJsonLine.geometry.coordinates;
        } else {
            geoms.push(geoJsonLine.geometry.coordinates);
        }

        geoms.forEach(lineCoords => {
            var path = lineCoords.map(p => new BMapGL.Point(p[0], p[1]));
            var overlay = new BMapGL.Polyline(path, {
                strokeColor: color, strokeWeight: weight, strokeOpacity: 1
            });
            map.addOverlay(overlay);
            appState.analysisOverlays.push(overlay);
        });
    }

    function clearAnalysis() {
        appState.analysisOverlays.forEach(o => map.removeOverlay(o));
        appState.analysisOverlays = [];
    }

    function clearTempDrawing() {
        appState.drawPath = [];
        if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline);
        appState.tempPolyline = null;
    }

    function ptsToGeoJSON(pts) {
        var coords = pts.map(p => [p.lng, p.lat]);
        return turf.polygon([coords]);
    }

    function finalizePolygon(geoJson) {
        geoJson.properties = { id: 'poly_' + (ID_COUNTER++), name: '板块' };
        
        var coords = geoJson.geometry.coordinates[0];
        var path = coords.map(p => new BMapGL.Point(p[0], p[1]));
        
        var overlay = new BMapGL.Polygon(path, {
            strokeColor: "blue", strokeWeight: 2, strokeOpacity: 0.5,
            fillColor: "rgba(0,0,0,0.4)"
        });
        
        map.addOverlay(overlay);
        appState.polygons.push({ overlay: overlay, geoJson: geoJson });
    }
</script>






























<!-- <!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <style type="text/css">
        body, html, #allmap {width: 100%;height: 100%;overflow: hidden;margin:0;font-family:"微软雅黑";}
        .anchorBL{display:none;}
    </style>
    
    <script type="text/javascript" src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
    <script src="turf.min.js"></script>
    <title>GIS Engine Final</title>
</head>
<body>
    <div id="allmap"></div>
</body>
</html>
<script type="text/javascript">
    var map = new BMapGL.Map("allmap", {enableMapClick:false});
    var point = new BMapGL.Point(116.404, 39.915);
    map.centerAndZoom(point, 15);
	
	map.enableScrollWheelZoom(true); 
    <!-- map.setTilt(60); // 3D 视角 -->
    
    // 全局状态升级
    var appState = {
        mode: 'browse', // browse | edit | snap (新增吸附模式)
        polygons: [],   // 存储结构: { overlay: BMapObject, geoJson: TurfObject }
        selectedId: null, // 当前选中的板块ID (用于吸附操作)
        history: [],    // 用于撤销栈
        // ... 其他临时变量
    };

    // 辅助：生成唯一默认名
    function generateUniqueName() {
        let base = "未命名板块";
        let count = 1;
        while (appState.polygons.some(p => p.geoJson.properties.name === `${base}_${count}`)) {
            count++;
        }
        return `${base}_${count}`;
    }

    // 引入 Turf.js 的布尔运算模块 (需确保 turf.min.js 完整版包含 boolean 模块)

/**
 * 执行吸附逻辑 (对应需求 a.iii)
 * @param {Object} snapBoxGeoJson - 用户画出的矩形框 GeoJSON
 */
function executeSnap(snapBoxGeoJson) {
    if (!appState.selectedId) {
        alert("请先选择一个要编辑的板块！");
        return;
    }

    // 1. 找到当前选中的板块
    let targetIndex = appState.polygons.findIndex(p => p.geoJson.properties.id === appState.selectedId);
    if (targetIndex === -1) return;
    let targetPoly = appState.polygons[targetIndex];

    // 2. 第一步：合并 (Union) - 将矩形框并入原板块
    // 这实现了"最大程度填满长方形选框"
    var unionResult = turf.union(targetPoly.geoJson, snapBoxGeoJson);

    if (!unionResult) return; // 合并失败（无重叠可能导致 null）

    // 3. 第二步：切除 (Difference) - 保证"不越过已有的其他多边形"
    // 遍历所有其他多边形，如果有重叠，就切掉重叠部分
    appState.polygons.forEach(otherPoly => {
        if (otherPoly.geoJson.properties.id !== appState.selectedId) {
            // 检查是否相交，如果相交则执行差集运算
            if (!turf.booleanDisjoint(unionResult, otherPoly.geoJson)) {
                try {
                    unionResult = turf.difference(unionResult, otherPoly.geoJson);
                } catch (e) {
                    console.warn("裁剪计算异常，可能是几何错误", e);
                }
            }
        }
    });

    // 4. 更新数据与视图
    if (unionResult) {
        // 记录历史用于撤销
        saveHistory(); 
        
        // 移除旧的图形
        map.removeOverlay(targetPoly.overlay);
        
        // 继承旧属性 (ID, Name, Desc)，更新几何数据
        unionResult.properties = targetPoly.geoJson.properties;
        
        // 重新绘制并计算分数
        updatePolygonGeometry(targetIndex, unionResult);
    }
}

    // 辅助：更新几何体并重绘
    function updatePolygonGeometry(index, newGeoJson) {
        // 重新计算分数 (需求 d)
        calculateScore(newGeoJson);
        
        // 生成百度地图 Overlay
        var coords = newGeoJson.geometry.coordinates; // 注意处理 MultiPolygon
        // 这里简化处理单多边形，实际需递归
        var path = coords[0].map(p => new BMapGL.Point(p[0], p[1]));
        
        var newOverlay = new BMapGL.Polygon(path, {
            strokeColor: "blue", strokeWeight: 2, fillColor: "rgba(0,0,0,0.4)"
        });
        
        // 绑定点击事件用于"选中"
        newOverlay.addEventListener('click', function(e) {
            if (appState.mode === 'edit') {
                selectPolygon(newGeoJson.properties.id);
                // 阻止地图底图的点击传播
                e.domEvent.stopPropagation(); 
            }
        });

        map.addOverlay(newOverlay);
        
        // 更新内存数据
        appState.polygons[index] = { overlay: newOverlay, geoJson: newGeoJson };
        
        // 如果是当前选中，加高亮边框
        if(appState.selectedId === newGeoJson.properties.id) highlightPolygon(newOverlay);
    }

     // 计算分数 (需求 d)
    function calculateScore(geoJson) {
        // 示例算法：基于面积和顶点数量
        var area = turf.area(geoJson); // 平方米
        var points = turf.explode(geoJson).features.length; // 顶点数
        
        // 假定的业务公式
        var subScore1 = Math.floor(area * 0.1); 
        var subScore2 = points * 5;
        
        geoJson.properties.scores = {
            areaScore: subScore1,
            complexityScore: subScore2,
            total: subScore1 + subScore2
        };
        
        // 更新质心 (需求 a.i 添加质心)
        var center = turf.centerOfMass(geoJson);
        geoJson.properties.center = center.geometry.coordinates;
        
        // 可视化质心（可选）
        // renderCentroidMarker(center, geoJson.properties.name);
    }

    // 供 UE5 调用：搜索多边形
    window.searchPolygon = function(keyword) {
        var found = appState.polygons.find(p => p.geoJson.properties.name === keyword);
        
        if (found) {
            // 1. 高亮展示
            selectPolygon(found.geoJson.properties.id);
            
            // 2. 跳转视口 (Get Bounds and Zoom)
            var path = found.overlay.getPath();
            var bounds = new BMapGL.Bounds();
            path.forEach(pt => bounds.extend(pt));
            map.setViewport(bounds); // 自动缩放至多边形范围
            
            return JSON.stringify(found.geoJson.properties); // 返回属性给 UE5 显示
        } else {
            return "NOT_FOUND";
        }
    };

    function selectPolygon(id) {
        appState.selectedId = id;
        // 遍历所有 Overlay，重置颜色，唯独高亮 ID 匹配的
        appState.polygons.forEach(p => {
            if (p.geoJson.properties.id === id) {
                p.overlay.setStrokeColor("red"); // 高亮色
                p.overlay.setStrokeWeight(4);
            } else {
                p.overlay.setStrokeColor("blue"); // 默认色
                p.overlay.setStrokeWeight(2);
            }
        });
    }


    // 鼠标交互状态机
    var dragStartPoint = null;
    var rectOverlay = null;

    map.addEventListener('mousedown', function(e) {
        if (appState.mode === 'snap') {
            dragStartPoint = e.latlng;
            map.disableDragging(); // 画框时禁止地图移动
        }
    });

    map.addEventListener('mousemove', function(e) {
        if (appState.mode === 'snap' && dragStartPoint) {
            // 实时绘制矩形框视觉反馈
            var currentPoint = e.latlng;
            drawTempRect(dragStartPoint, currentPoint);
        }
    });

    map.addEventListener('mouseup', function(e) {
        if (appState.mode === 'snap' && dragStartPoint) {
            var dragEndPoint = e.latlng;
            
            // 1. 构造矩形 GeoJSON
            // 注意：Turf 需要 [minX, minY, maxX, maxY] 或 Polygon 坐标闭环
            var coords = [[
                [dragStartPoint.lng, dragStartPoint.lat],
                [dragEndPoint.lng, dragStartPoint.lat],
                [dragEndPoint.lng, dragEndPoint.lat],
                [dragStartPoint.lng, dragEndPoint.lat],
                [dragStartPoint.lng, dragStartPoint.lat] // 闭合
            ]];
            var snapBox = turf.polygon(coords);
            
            // 2. 执行核心吸附计算
            executeSnap(snapBox);
            
            // 3. 清理
            if(rectOverlay) map.removeOverlay(rectOverlay);
            dragStartPoint = null;
            rectOverlay = null;
            map.enableDragging();
        }
    });

    function drawTempRect(pt1, pt2) {
        if(rectOverlay) map.removeOverlay(rectOverlay);
        var rectPoints = [
            new BMapGL.Point(pt1.lng, pt1.lat),
            new BMapGL.Point(pt2.lng, pt1.lat),
            new BMapGL.Point(pt2.lng, pt2.lat),
            new BMapGL.Point(pt1.lng, pt2.lat)
        ];
        rectOverlay = new BMapGL.Polygon(rectPoints, {
            strokeColor: "green", strokeWeight: 2, strokeStyle: 'dashed', fillColor: "transparent"
        });
        map.addOverlay(rectOverlay);
    }







    // --- 2. 状态管理 ---
    var appState = {
        mode: 'browse', // 'browse' | 'edit'
        polygons: [],   // 存所有闭合区域 {overlay, geoJson}
        markers: [],    // 存所有标记点
        drawingPts: [], // 当前绘制的点
        tempLine: null  // 当前绘制的辅助线
    };

    // --- 3. 交互逻辑 ---
    
    // 切换模式 (UE调用)
    window.setMode = function(modeName) {
        appState.mode = modeName;
        if(modeName === 'browse') {
            map.enableDragging(); // 浏览模式允许拖拽
            clearTempDrawing();
        } else {
            map.disableDragging(); // 编辑模式禁止地图移动，防止画歪
        }
    };
	
	// --- 辅助函数：创建黄色标记点 ---
	// 我们使用 BMapGL.Circle 来创建一个简单的实心圆点，实现“黄色点”效果。
	function createYellowDot(point) {
		// 创建一个半径为 5 像素的黄色圆点
		var yellowDot = new BMapGL.Circle(point, 5, { 
			strokeColor: "yellow", // 描边颜色
			strokeWeight: 1,       // 描边粗细
			fillColor: "yellow",   // 填充颜色
			fillOpacity: 1         // 完全不透明
		});
		map.addOverlay(yellowDot);
		return yellowDot;
	}

    // 鼠标左键：画点
    map.addEventListener('click', function(e) {
		// 确保在编辑模式
		if(appState.mode !== 'edit') return; 

		var pt = e.latlng;
		var point = new BMapGL.Point(pt.lng, pt.lat);
		appState.drawingPts.push(point);
		
		// 1. **新增：** 在点击位置放置一个黄色点
		var newDot = createYellowDot(point);

		// 2. 绘制临时线条（确保是蓝色）
		if (appState.tempLine) {
			map.removeOverlay(appState.tempLine);
		}
		appState.tempLine = new BMapGL.Polyline(appState.drawingPts, {
			strokeColor:"blue", // **蓝色连线**
			strokeWeight: 3, 
			strokeOpacity: 0.8
		});
		map.addOverlay(appState.tempLine);
    });

    // 鼠标右键：闭合多边形（需要清理掉临时绘制的黄色点和蓝线）
    map.addEventListener('rightclick', function(e) {
        if(appState.mode !== 'edit' || appState.drawingPts.length < 3) return;

        // 1. 生成闭合多边形显示
        var polygon = new BMapGL.Polygon(appState.drawingPts, {
            strokeColor: "blue", strokeWeight: 2, strokeOpacity: 0.5,
            fillColor: "rgba(0,0,0,0.4)" 
        });
        map.addOverlay(polygon);

        // 2. 生成 GeoJSON 数据用于数学计算
        var coords = appState.drawingPts.map(p => [p.lng, p.lat]);
        coords.push(coords[0]); // 首尾相连
        var newGeoJson = turf.polygon([coords]);

        // 3. 计算拓扑交叉 (商业级核心需求)
        checkAndHighlightIntersection(newGeoJson);

        // 4. 入库
        appState.polygons.push({ overlay: polygon, geoJson: newGeoJson });
        clearTempDrawing();
		
		// 清理临时状态
		drawingPoints = [];
		if(appState.tempLine) map.removeOverlay(appState.tempLine);
		appState.tempLine = null;
		
		// **新增清理：** 移除临时绘制的黄色点 (这是生产环境中需要的额外逻辑)
		// 完整实现应在 drawingPts 中同时保存点的引用并在此处遍历移除。
		// 由于地图Overlay较多，建议在每次闭合时执行 map.clearOverlays()，然后重绘所有已保存的多边形。
		
		// 2. **关键：** 成功闭合后，执行清理
		clearTempDrawing();
    });

	// --- 辅助函数：清理临时绘制状态 ---
    function clearTempDrawing() {
			// 确保清空用于绘制点的数组
		appState.drawingPts = []; 

		// 移除临时线条
		if(appState.tempLine) {
			map.removeOverlay(appState.tempLine);
			appState.tempLine = null;
    }
    
    // **重要新增：** 移除所有临时绘制的黄色点
    appState.tempDots.forEach(dot => map.removeOverlay(dot));
    appState.tempDots = [];
    }

    // --- 4. 拓扑算法 (Turf.js) ---
    function checkAndHighlightIntersection(newPolyGeo) {
        // 遍历所有已存在的多边形
        appState.polygons.forEach(existPoly => {
            var intersection = turf.intersect(newPolyGeo, existPoly.geoJson);
            if(intersection) {
                // 如果有交集，绘制红色高亮块
                var rawCoords = intersection.geometry.coordinates;
                // 注意：Turf 返回的结构可能是多重数组，这里简化处理单区域
                // 生产环境需递归解析 MultiPolygon
                var path = rawCoords[0].map(p => new BMapGL.Point(p[0], p[1]));
                
                var highLight = new BMapGL.Polygon(path, {
                    strokeColor: "red", fillColor: "red", fillOpacity: 0.6
                });
                map.addOverlay(highLight);
            }
        });
    }

    // --- 5. 标点系统 (Req 8) ---
    window.addMapMarker = function(lng, lat, typeStr) {
        var pt = new BMapGL.Point(lng, lat);
        // 实际开发请根据 typeStr 切换 iconUrl
        var marker = new BMapGL.Marker(pt); 
        map.addOverlay(marker);
        appState.markers.push({mk: marker, type: typeStr});
    };

    window.filterMarkers = function(typeStr) {
        appState.markers.forEach(item => {
            if(item.type === typeStr || typeStr === "All") item.mk.show();
            else item.mk.hide();
        });
    };

    // --- 6. 数据 IO (与 UE5 通信) ---
    
    // 导出数据 -> UE5
    window.exportData = function() {
        var saveData = {
            polys: appState.polygons.map(p => p.geoJson),
            markers: appState.markers.map(m => ({
                lat: m.mk.getPosition().lat,
                lng: m.mk.getPosition().lng,
                type: m.type
            }))
        };
        // 核心 Hack：通过修改 Title 触发 UE5 回调
        document.title = "UE_SAVE:" + JSON.stringify(saveData);
    };

    // 导入数据 <- UE5
    window.importData = function(jsonStr) {
        var data = JSON.parse(jsonStr);
        map.clearOverlays();
        appState.polygons = [];
        
        // 恢复多边形
        if(data.polys) {
            data.polys.forEach(geo => {
                var coords = geo.geometry.coordinates[0];
                var path = coords.map(p => new BMapGL.Point(p[0], p[1]));
                var poly = new BMapGL.Polygon(path, {
                    strokeColor: "blue", strokeWeight: 2, fillColor: "rgba(0,0,0,0.4)"
                });
                map.addOverlay(poly);
                appState.polygons.push({ overlay: poly, geoJson: geo });
            });
        }
        // 恢复标记... (逻辑同上)
    };
</script> -->



<!--
<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <style type="text/css">
        body, html, #allmap {width: 100%;height: 100%;overflow: hidden;margin:0;font-family:"微软雅黑";}
        .anchorBL{display:none;} /* 隐藏百度Logo */
    </style>
    
    <script type="text/javascript" src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
    
    <title>GIS Engine GL</title>
</head>
<body>
    <div id="allmap"></div>
</body>
</html>
<script type="text/javascript">
    // 【关键修正】使用 BMapGL 对象进行初始化
    // BMapGL 是百度 WebGL 版本的入口对象
    var map = new BMapGL.Map("allmap", {enableMapClick:false});
    
    // 初始化中心点 (北京)
    var point = new BMapGL.Point(116.404, 39.915);
    map.centerAndZoom(point, 15);
    
    // 启用交互功能
    map.enableScrollWheelZoom(true);
    map.disableDoubleClickZoom(); 

	// === 新增：UE 驱动地图的控制函数 ===

	// 参数：地图中心经度, 纬度, 缩放级别
	function setMapState(lng, lat, zoom) {
		var newPoint = new BMapGL.Point(lng, lat);
		map.centerAndZoom(newPoint, zoom);
		// 注意：这里调用 centerAndZoom 会触发 'moveend'/'zoomend'，进而调用 syncState() 回传给 UE
	}

	// 参数：经度差值, 纬度差值 (用于平移)
	function panMapBy(deltaLng, deltaLat) {
		var center = map.getCenter();
		var newLng = center.lng + deltaLng;
		var newLat = center.lat + deltaLat;
		var newPoint = new BMapGL.Point(newLng, newLat);
		map.panTo(newPoint, { noAnimation: true }); // 禁用动画，保证即时同步
		// panTo 也会触发 'moveend'，进而调用 syncState()
	}

    // === 核心：极速状态同步 (URL Hash Messaging) ===
    function syncState() {
        // BMapGL 和 BMap 的 API 保持一致
        var c = map.getCenter();
        var z = map.getZoom();
        
        // 格式: #s=lng,lat,zoom
        var hash = "s=" + c.lng.toFixed(6) + "," + c.lat.toFixed(6) + "," + z;
        
        // 只有变化时才写入，避免无意义刷新
        if(window.location.hash !== "#" + hash) {
            window.location.hash = hash;
        }
    }

    // 监听所有可能改变视图的事件
    map.addEventListener("dragend", syncState);
    map.addEventListener("zoomend", syncState);
    map.addEventListener("moving", syncState); 
    map.addEventListener("zoom_changed", syncState); 
    
    // 初始化发送
    setTimeout(syncState, 500);
</script>
-->













<!--
<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <style type="text/css">
        body, html, #allmap {width: 100%;height: 100%;overflow: hidden;margin:0;font-family:"微软雅黑";}
        .anchorBL{display:none;} /* 隐藏百度Logo */
    </style>
    
    <script type="text/javascript" src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
    
    <title>GIS Engine GL</title>
</head>
<body>
    <div id="allmap"></div>
</body>
</html>
<script type="text/javascript">
    // 【关键修正】使用 BMapGL 对象进行初始化
    // BMapGL 是百度 WebGL 版本的入口对象
    var map = new BMapGL.Map("allmap", {enableMapClick:false});
    
    // 初始化中心点 (北京)
    var point = new BMapGL.Point(116.404, 39.915);
    map.centerAndZoom(point, 15);
    
    // 启用交互功能
    map.enableScrollWheelZoom(true);
    map.disableDoubleClickZoom(); 

    // === 核心：极速状态同步 (URL Hash Messaging) ===
    function syncState() {
        // BMapGL 和 BMap 的 API 保持一致
        var c = map.getCenter();
        var z = map.getZoom();
        
        // 格式: #s=lng,lat,zoom
        var hash = "s=" + c.lng.toFixed(6) + "," + c.lat.toFixed(6) + "," + z;
        
        // 只有变化时才写入，避免无意义刷新
        if(window.location.hash !== "#" + hash) {
            window.location.hash = hash;
        }
    }

    // 监听所有可能改变视图的事件
    map.addEventListener("dragend", syncState);
    map.addEventListener("zoomend", syncState);
    map.addEventListener("moving", syncState); 
    map.addEventListener("zoom_changed", syncState); 
    
    // 初始化发送
    setTimeout(syncState, 500);
</script>
-->




<!--
<!doctype html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>百度地图</title>
    <style>
        #map { width: 100%; height: 100vh; }
    </style>
    <script src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
</head>


<body>
    <div id="map"></div>
    <script>
        const map = new BMapGL.Map('map');  // 创建地图实例
        const center = new BMapGL.Point(116.404, 39.915);  // 设置地图中心点（北京）
        map.centerAndZoom(center, 15);  // 初始化地图，设置中心点坐标和缩放级别
        map.enableScrollWheelZoom(true);  // 启用滚轮缩放
		map.disableDoubleClickZoom(); // UE接管双击
        
		// === 核心：极速状态同步 ===
		function syncState() {
			var c = map.getCenter();
			var z = map.getZoom();
			// 保留6位小数足矣，减少字符串长度
			var hash = "s=" + c.lng.toFixed(6) + "," + c.lat.toFixed(6) + "," + z;
			
			// 只有变化时才写入，避免无意义刷新
			if(window.location.hash !== "#" + hash) {
				window.location.hash = hash;
			}
		}
		
		// 监听所有可能改变视图的事件
		map.addEventListener("dragend", syncState);
		map.addEventListener("zoomend", syncState);
		map.addEventListener("moving", syncState); // 拖拽中实时同步
		map.addEventListener("zoom_changed", syncState); // 缩放中实时同步
		
		// 初始化发送
		setTimeout(syncState, 500);
		
		// JS → UE 交互：例如地图点击位置
        //map.addEventListener('click', function (e) {
        //    console.log(JSON.stringify({ type: 'click', lng: e.latlng.lng, lat: e.latlng.lat }));
        //});

        // UE → JS 交互：例如改变视角
        //window.setView = (lng, lat, zoom = 15) => {
        //    map.centerAndZoom(new BMapGL.Point(lng, lat), zoom);
        //};
    </script>
</body>
</html>
-->




<!--
<!DOCTYPE html>
<html>
<head>
     <meta charset="utf-8"/>
	<title>GIS Tool</title>
    <style type="text/css">
        #map { width: 100%; height: 100vh; }
    </style>
    <script src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
</head>

<body>
    <div id="map"></div>
    <script>
		// 初始化北京
		const map = new BMapGL.Map('map');  // 创建地图实例
		const center = new BMapGL.Point(116.404, 39.915);  // 设置地图中心点（北京）
		map.centerAndZoom(center, 15);
		map.enableScrollWheelZoom(true);
		map.disableDoubleClickZoom(); // 禁用双击放大，留给UE做交互
		
		// 【关键1】开启滚轮，但尽量减少惯性 (百度API没有直接禁止惯性的开关，但我们可以高频监听)
		map.enableScrollWheelZoom(true);
		map.disableDoubleClickZoom();

		// === 核心逻辑：将地图状态发送给 UE ===
		// 我们通过修改 URL 的 Hash 部分来传递数据，这不会导致页面刷新
		function updateStateToUE() {
			var center = map.getCenter();
			var zoom = map.getZoom();
			
			// 【关键2】增加高精度的 hash 发送
			var hash = "state=" + center.lng.toFixed(6) + "," + center.lat.toFixed(6) + "," + zoom;
			
			// 只有当 hash 变化时才发送，避免死循环
			if(window.location.hash !== "#" + hash) {
				window.location.hash = hash;
			}
		}

		// 监听拖拽和缩放
		// 【关键3】监听所有可能导致视图变化的事件
		// 'moveend' 和 'zoomend' 是基础
		map.addEventListener("moveend", updateStateToUE);
		map.addEventListener("dragend", updateStateToUE); 
		map.addEventListener("zoomend", updateStateToUE);
		// 'moving' 和 'zoom_changed' 可以尝试捕获过程中的变化，减少视觉延迟
		map.addEventListener("moving", updateStateToUE);
		// 稍微延迟一下初始发送
		setTimeout(updateStateToUE, 500);
	</script>
</body>
</html>
-->

















<!--
<!DOCTYPE html>
<html>
<head>
     <meta charset="utf-8"/>
	<title>GIS Tool</title>
    <style type="text/css">
        #map { width: 100%; height: 100vh; }
    </style>
    <script src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
</head>

<body>
    <div id="map"></div>
    <script>
		// 初始化北京
		const map = new BMapGL.Map('map');  // 创建地图实例
		const center = new BMapGL.Point(116.404, 39.915);  // 设置地图中心点（北京）
		map.centerAndZoom(center, 15);
		map.enableScrollWheelZoom(true);
		map.disableDoubleClickZoom(); // 禁用双击放大，留给UE做交互

		// === 核心逻辑：将地图状态发送给 UE ===
		// 我们通过修改 URL 的 Hash 部分来传递数据，这不会导致页面刷新
		function updateStateToUE() {
			var center = map.getCenter();
			var zoom = map.getZoom();
			// 格式: #state=经度,纬度,缩放
			var hash = "state=" + center.lng.toFixed(6) + "," + center.lat.toFixed(6) + "," + zoom;
			window.location.hash = hash;
		}

		// 监听拖拽和缩放
		map.addEventListener("dragend", updateStateToUE); 
		map.addEventListener("zoomend", updateStateToUE);
		// 稍微延迟一下初始发送
		setTimeout(updateStateToUE, 10);
	</script>
</body>
</html>
-->









<!--
<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <style type="text/css">
        body, html, #allmap {width: 100%;height: 100%;overflow: hidden;margin:0;font-family:"微软雅黑";}
        /* 隐藏百度地图自带的UI，防止干扰 */
        .anchorBL{display:none;} 
    </style>
    <script type="text/javascript" src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script> 
    <title>UE5 GIS Map</title>

</head>
<body>
    <div id="allmap"></div>
</body>
</html>
<script type="text/javascript">
    var map = new BMap.Map("allmap");
    // 初始化中心点 (北京)
    var point = new BMap.Point(116.404, 39.915);
    map.centerAndZoom(point, 15);
    map.enableScrollWheelZoom(true);

    // 禁止双击放大，因为我们要用双击来闭合图形
    map.disableDoubleClickZoom();

    // === 核心：向 UE 发送状态 ===
    function sendStateToUE() {
        if (window.ue && window.ue.gisbridge) {
            var center = map.getCenter();
            var zoom = map.getZoom();
            // 调用 UE C++ 函数
            window.ue.gisbridge.onmapstatechanged(center.lng, center.lat, zoom);
        }
    }
	
	// 在 map.html 文件中，用于替换旧的 BindUObject 调用
	function sendCommand(command, data) {
		// 确保数据是 URL 安全的
		var payload = data ? '&data=' + encodeURIComponent(data) : '';
		
		// 关键：通过修改 hash 触发 OnUrlChanged 事件
		// 完整 URL Hash 示例: #ue_command=save&data={...geojson...}
		window.location.hash = `#ue_command=${command}${payload}`;
	}

	function handleSave() {
		var geoJsonData = getMapDataAsGeoJson(); // 假设这是获取数据的函数
		sendCommand('save', geoJsonData); 
	}

	function handleEditMode(enable) {
		if (enable) {
			sendCommand('mode_edit', '');
		} else {
			sendCommand('mode_view', '');
		}
	}

    // 绑定事件：拖拽中、缩放中都需要高频更新
    map.addEventListener("moving", sendStateToUE); 
    map.addEventListener("zoomend", sendStateToUE);
    map.addEventListener("dragend", sendStateToUE);
    
    // 初始化时发送一次
    setTimeout(sendStateToUE, 1000);
</script>
-->