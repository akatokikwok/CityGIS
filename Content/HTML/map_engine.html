<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <style>
        html, body, #map_container { width: 100%; height: 100%; overflow: hidden; margin: 0; }
        /* 隐藏百度版权(商业发布需获授权) */
        .anchorBL, .BMap_cpyCtrl { display: none; } 
    </style>
    <script type="text/javascript" src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
    <script src="turf.min.js"></script>
</head>
<body>
    <div id="map_container"></div>
</body>
</html>

<script>
    // ============================================
    // 1. 全局状态管理 (State Management)
    // ============================================
    var map = new BMapGL.Map("map_container");
    map.centerAndZoom(new BMapGL.Point(116.404, 39.915), 18); 
    map.enableScrollWheelZoom(true); 
    map.setTilt(30); 

    var appState = {
        mode: 'browse', // 'browse'(浏览), 'edit'(绘图), 'snap'(框选吸附)
        polygons: [],   // 存所有板块: [{overlay, geoJson, id}]
        drawingPts: [], // 当前正在画的点数组
        tempDots: [],   // 当前画出的黄色临时点
        tempLine: null, // 当前画出的蓝色临时线
        selectedId: null, // 当前选中的板块ID
        dragStart: null,  // 框选起手点
        snapRect: null    // 框选的临时矩形
    };

    var ID_COUNTER = 1; // 简单的ID生成器

    // ============================================
    // 2. 交互模式控制 (UE5 -> JS 接口)
    // ============================================
    window.setMode = function(modeName) {
        appState.mode = modeName;
        console.log("Mode Switch:", modeName);
        
        if(modeName === 'browse') {
            map.enableDragging();
            clearTempDrawing();
            deselectAll();
        } else if (modeName === 'edit') {
            map.disableDragging(); // 编辑时禁止拖拽以防误触
        } else if (modeName === 'snap') {
            map.disableDragging();
            if(!appState.selectedId) {
                alert("请先在编辑模式下点选一个板块！");
                window.setMode('edit'); // 回退
            }
        }
    };

    // ============================================
    // 3. 核心绘图逻辑 (点、线、面)
    // ============================================
    
    // 辅助：画黄色点
    function createYellowDot(pt) {
        var dot = new BMapGL.Circle(pt, 5, { 
            strokeColor: "yellow", strokeWeight: 1, fillColor: "yellow", fillOpacity: 1 
        });
        map.addOverlay(dot);
        return dot;
    }

    // 事件：左键点击 (画点)
    map.addEventListener('click', function(e) {
        if(appState.mode !== 'edit') return;

        var pt = e.latlng; // 获取点击经纬度
        var bPoint = new BMapGL.Point(pt.lng, pt.lat);
        
        // 记录数据
        appState.drawingPts.push(bPoint);
        
        // 视觉：画黄点
        var dot = createYellowDot(bPoint);
        appState.tempDots.push(dot);

        // 视觉：画蓝线 (连接所有点)
        updateTempLine();
    });

    function updateTempLine() {
        if (appState.tempLine) map.removeOverlay(appState.tempLine);
        if (appState.drawingPts.length > 0) {
            appState.tempLine = new BMapGL.Polyline(appState.drawingPts, {
                strokeColor: "blue", strokeWeight: 3, strokeOpacity: 0.8
            });
            map.addOverlay(appState.tempLine);
        }
    }

    // 事件：右键点击 (闭合多边形)
    map.addEventListener('rightclick', function(e) {
        if(appState.mode !== 'edit' || appState.drawingPts.length < 3) return;

        // 1. 构建 GeoJSON (Turf 格式)
        var coords = appState.drawingPts.map(p => [p.lng, p.lat]);
        coords.push(coords[0]); // 闭合
        var geoPoly = turf.polygon([coords]);
        
        // 2. 赋予属性 (ID, 名字, 分数)
        geoPoly.properties = {
            id: 'poly_' + (ID_COUNTER++),
            name: '未命名板块',
            score: calculateScore(geoPoly)
        };

        // 3. 生成并保存
        addPolygonToMap(geoPoly);

        // 4. 清理临时绘画
        clearTempDrawing();
    });

    // 辅助：计算分数 (需求 d)
    function calculateScore(geo) {
        var area = turf.area(geo);
        // 简单的打分公式：面积 * 0.1
        return Math.floor(area * 0.1); 
    }

    // ============================================
    // 4. 进阶功能：吸附框选 (Snapping Logic)
    // ============================================
    // 逻辑：画个框 -> 框与选中板块 Union (合并) -> 结果与所有其他板块 Difference (切除)

    map.addEventListener('mousedown', function(e) {
        if(appState.mode === 'snap') {
            appState.dragStart = e.latlng;
        }
    });

    map.addEventListener('mousemove', function(e) {
        if(appState.mode === 'snap' && appState.dragStart) {
            // 画绿色虚线框示意
            var p1 = appState.dragStart;
            var p2 = e.latlng;
            var path = [
                new BMapGL.Point(p1.lng, p1.lat), new BMapGL.Point(p2.lng, p1.lat),
                new BMapGL.Point(p2.lng, p2.lat), new BMapGL.Point(p1.lng, p2.lat)
            ];
            if(appState.snapRect) map.removeOverlay(appState.snapRect);
            appState.snapRect = new BMapGL.Polygon(path, {
                strokeColor: "green", strokeWeight: 2, strokeStyle: 'dashed', fillColor: "transparent"
            });
            map.addOverlay(appState.snapRect);
        }
    });

    map.addEventListener('mouseup', function(e) {
        if(appState.mode === 'snap' && appState.dragStart) {
            var p1 = appState.dragStart;
            var p2 = e.latlng;
            
            // 1. 构造选框 GeoJSON
            var boxGeo = turf.bboxPolygon([
                Math.min(p1.lng, p2.lng), Math.min(p1.lat, p2.lat),
                Math.max(p1.lng, p2.lng), Math.max(p1.lat, p2.lat)
            ]);

            // 2. 执行布尔运算
            executeBooleanOp(boxGeo);

            // 3. 清理
            if(appState.snapRect) map.removeOverlay(appState.snapRect);
            appState.dragStart = null;
            appState.snapRect = null;
            
            // 自动切回编辑模式
            window.setMode('edit'); 
        }
    });

    function executeBooleanOp(boxGeo) {
        var targetObj = appState.polygons.find(p => p.geoJson.properties.id === appState.selectedId);
        if(!targetObj) return;

        // A. 合并 (Union)
        var unionRes = turf.union(targetObj.geoJson, boxGeo);
        if(!unionRes) return;

        // B. 切除 (Difference) - 遍历所有其他多边形，切掉重叠
        appState.polygons.forEach(other => {
            if(other.geoJson.properties.id !== appState.selectedId) {
                // 如果相交，切掉
                if(!turf.booleanDisjoint(unionRes, other.geoJson)) {
                    try {
                        unionRes = turf.difference(unionRes, other.geoJson);
                    } catch(err) { console.error("Cut error", err); }
                }
            }
        });

        // C. 更新数据
        if(unionRes) {
            // 保持旧属性，更新几何
            unionRes.properties = targetObj.geoJson.properties;
            unionRes.properties.score = calculateScore(unionRes); // 重算分

            // 移除旧图，画新图
            map.removeOverlay(targetObj.overlay);
            // 替换数组中的对象
            var idx = appState.polygons.indexOf(targetObj);
            appState.polygons.splice(idx, 1);
            
            addPolygonToMap(unionRes, true); // true表示保持选中
        }
    }

    // ============================================
    // 5. 通用功能 (撤销, 保存, 加载, 搜索)
    // ============================================

    // 撤销上一个点
    window.undoLastPoint = function() {
        if(appState.mode !== 'edit' || appState.drawingPts.length === 0) return;
        
        appState.drawingPts.pop(); // 移除数据
        
        var dot = appState.tempDots.pop(); // 移除视觉点
        if(dot) map.removeOverlay(dot);
        
        updateTempLine(); // 重绘线
    };

    // 导出数据 (供UE5调用)
    window.exportData = function() {
        var data = appState.polygons.map(p => p.geoJson);
        // Hack: 修改标题触发 UE5 监听
        document.title = "UE_SAVE:" + JSON.stringify(data);
    };

    // 导入数据 (供UE5调用)
    window.importData = function(jsonStr) {
        map.clearOverlays();
        appState.polygons = [];
        appState.drawingPts = []; // 清理
        
        var list = JSON.parse(jsonStr);
        list.forEach(geo => {
            // 恢复最大ID防止重复
            var pid = parseInt(geo.properties.id.split('_')[1]);
            if(pid >= ID_COUNTER) ID_COUNTER = pid + 1;
            
            addPolygonToMap(geo);
        });
    };
    
    // 搜索
    window.searchPoly = function(name) {
        var found = appState.polygons.find(p => p.geoJson.properties.name === name);
        if(found) {
            // 聚焦
            var path = found.overlay.getPath();
            var b = new BMapGL.Bounds();
            path.forEach(pt => b.extend(pt));
            map.setViewport(b);
            // 选中
            selectPolygon(found.geoJson.properties.id);
        }
    };

    // ============================================
    // 6. 辅助工具函数
    // ============================================

    function addPolygonToMap(geoJson, autoSelect=false) {
        var coords = geoJson.geometry.coordinates[0]; // 简化处理单环
        var path = coords.map(p => new BMapGL.Point(p[0], p[1]));
        
        var overlay = new BMapGL.Polygon(path, {
            strokeColor: "blue", strokeWeight: 2, strokeOpacity: 0.5,
            fillColor: "rgba(0,0,0,0.4)"
        });

        // 绑定点击选中事件
        overlay.addEventListener('click', function(e) {
            if(appState.mode === 'edit') {
                selectPolygon(geoJson.properties.id);
                e.domEvent.stopPropagation();
            }
        });

        map.addOverlay(overlay);
        appState.polygons.push({ overlay: overlay, geoJson: geoJson });

        if(autoSelect) selectPolygon(geoJson.properties.id);
    }

    function selectPolygon(id) {
        appState.selectedId = id;
        appState.polygons.forEach(p => {
            if(p.geoJson.properties.id === id) {
                p.overlay.setStrokeColor("red"); // 选中变红
                p.overlay.setStrokeWeight(4);
            } else {
                p.overlay.setStrokeColor("blue");
                p.overlay.setStrokeWeight(2);
            }
        });
    }

    function deselectAll() {
        appState.selectedId = null;
        appState.polygons.forEach(p => {
            p.overlay.setStrokeColor("blue");
            p.overlay.setStrokeWeight(2);
        });
    }

    function clearTempDrawing() {
        appState.drawingPts = [];
        appState.tempDots.forEach(d => map.removeOverlay(d));
        appState.tempDots = [];
        if(appState.tempLine) map.removeOverlay(appState.tempLine);
        appState.tempLine = null;
    }
</script>






























<!-- <!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <style type="text/css">
        body, html, #allmap {width: 100%;height: 100%;overflow: hidden;margin:0;font-family:"微软雅黑";}
        .anchorBL{display:none;}
    </style>
    
    <script type="text/javascript" src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
    <script src="turf.min.js"></script>
    <title>GIS Engine Final</title>
</head>
<body>
    <div id="allmap"></div>
</body>
</html>
<script type="text/javascript">
    var map = new BMapGL.Map("allmap", {enableMapClick:false});
    var point = new BMapGL.Point(116.404, 39.915);
    map.centerAndZoom(point, 15);
	
	map.enableScrollWheelZoom(true); 
    <!-- map.setTilt(60); // 3D 视角 -->
    
    // 全局状态升级
    var appState = {
        mode: 'browse', // browse | edit | snap (新增吸附模式)
        polygons: [],   // 存储结构: { overlay: BMapObject, geoJson: TurfObject }
        selectedId: null, // 当前选中的板块ID (用于吸附操作)
        history: [],    // 用于撤销栈
        // ... 其他临时变量
    };

    // 辅助：生成唯一默认名
    function generateUniqueName() {
        let base = "未命名板块";
        let count = 1;
        while (appState.polygons.some(p => p.geoJson.properties.name === `${base}_${count}`)) {
            count++;
        }
        return `${base}_${count}`;
    }

    // 引入 Turf.js 的布尔运算模块 (需确保 turf.min.js 完整版包含 boolean 模块)

/**
 * 执行吸附逻辑 (对应需求 a.iii)
 * @param {Object} snapBoxGeoJson - 用户画出的矩形框 GeoJSON
 */
function executeSnap(snapBoxGeoJson) {
    if (!appState.selectedId) {
        alert("请先选择一个要编辑的板块！");
        return;
    }

    // 1. 找到当前选中的板块
    let targetIndex = appState.polygons.findIndex(p => p.geoJson.properties.id === appState.selectedId);
    if (targetIndex === -1) return;
    let targetPoly = appState.polygons[targetIndex];

    // 2. 第一步：合并 (Union) - 将矩形框并入原板块
    // 这实现了"最大程度填满长方形选框"
    var unionResult = turf.union(targetPoly.geoJson, snapBoxGeoJson);

    if (!unionResult) return; // 合并失败（无重叠可能导致 null）

    // 3. 第二步：切除 (Difference) - 保证"不越过已有的其他多边形"
    // 遍历所有其他多边形，如果有重叠，就切掉重叠部分
    appState.polygons.forEach(otherPoly => {
        if (otherPoly.geoJson.properties.id !== appState.selectedId) {
            // 检查是否相交，如果相交则执行差集运算
            if (!turf.booleanDisjoint(unionResult, otherPoly.geoJson)) {
                try {
                    unionResult = turf.difference(unionResult, otherPoly.geoJson);
                } catch (e) {
                    console.warn("裁剪计算异常，可能是几何错误", e);
                }
            }
        }
    });

    // 4. 更新数据与视图
    if (unionResult) {
        // 记录历史用于撤销
        saveHistory(); 
        
        // 移除旧的图形
        map.removeOverlay(targetPoly.overlay);
        
        // 继承旧属性 (ID, Name, Desc)，更新几何数据
        unionResult.properties = targetPoly.geoJson.properties;
        
        // 重新绘制并计算分数
        updatePolygonGeometry(targetIndex, unionResult);
    }
}

    // 辅助：更新几何体并重绘
    function updatePolygonGeometry(index, newGeoJson) {
        // 重新计算分数 (需求 d)
        calculateScore(newGeoJson);
        
        // 生成百度地图 Overlay
        var coords = newGeoJson.geometry.coordinates; // 注意处理 MultiPolygon
        // 这里简化处理单多边形，实际需递归
        var path = coords[0].map(p => new BMapGL.Point(p[0], p[1]));
        
        var newOverlay = new BMapGL.Polygon(path, {
            strokeColor: "blue", strokeWeight: 2, fillColor: "rgba(0,0,0,0.4)"
        });
        
        // 绑定点击事件用于"选中"
        newOverlay.addEventListener('click', function(e) {
            if (appState.mode === 'edit') {
                selectPolygon(newGeoJson.properties.id);
                // 阻止地图底图的点击传播
                e.domEvent.stopPropagation(); 
            }
        });

        map.addOverlay(newOverlay);
        
        // 更新内存数据
        appState.polygons[index] = { overlay: newOverlay, geoJson: newGeoJson };
        
        // 如果是当前选中，加高亮边框
        if(appState.selectedId === newGeoJson.properties.id) highlightPolygon(newOverlay);
    }

     // 计算分数 (需求 d)
    function calculateScore(geoJson) {
        // 示例算法：基于面积和顶点数量
        var area = turf.area(geoJson); // 平方米
        var points = turf.explode(geoJson).features.length; // 顶点数
        
        // 假定的业务公式
        var subScore1 = Math.floor(area * 0.1); 
        var subScore2 = points * 5;
        
        geoJson.properties.scores = {
            areaScore: subScore1,
            complexityScore: subScore2,
            total: subScore1 + subScore2
        };
        
        // 更新质心 (需求 a.i 添加质心)
        var center = turf.centerOfMass(geoJson);
        geoJson.properties.center = center.geometry.coordinates;
        
        // 可视化质心（可选）
        // renderCentroidMarker(center, geoJson.properties.name);
    }

    // 供 UE5 调用：搜索多边形
    window.searchPolygon = function(keyword) {
        var found = appState.polygons.find(p => p.geoJson.properties.name === keyword);
        
        if (found) {
            // 1. 高亮展示
            selectPolygon(found.geoJson.properties.id);
            
            // 2. 跳转视口 (Get Bounds and Zoom)
            var path = found.overlay.getPath();
            var bounds = new BMapGL.Bounds();
            path.forEach(pt => bounds.extend(pt));
            map.setViewport(bounds); // 自动缩放至多边形范围
            
            return JSON.stringify(found.geoJson.properties); // 返回属性给 UE5 显示
        } else {
            return "NOT_FOUND";
        }
    };

    function selectPolygon(id) {
        appState.selectedId = id;
        // 遍历所有 Overlay，重置颜色，唯独高亮 ID 匹配的
        appState.polygons.forEach(p => {
            if (p.geoJson.properties.id === id) {
                p.overlay.setStrokeColor("red"); // 高亮色
                p.overlay.setStrokeWeight(4);
            } else {
                p.overlay.setStrokeColor("blue"); // 默认色
                p.overlay.setStrokeWeight(2);
            }
        });
    }


    // 鼠标交互状态机
    var dragStartPoint = null;
    var rectOverlay = null;

    map.addEventListener('mousedown', function(e) {
        if (appState.mode === 'snap') {
            dragStartPoint = e.latlng;
            map.disableDragging(); // 画框时禁止地图移动
        }
    });

    map.addEventListener('mousemove', function(e) {
        if (appState.mode === 'snap' && dragStartPoint) {
            // 实时绘制矩形框视觉反馈
            var currentPoint = e.latlng;
            drawTempRect(dragStartPoint, currentPoint);
        }
    });

    map.addEventListener('mouseup', function(e) {
        if (appState.mode === 'snap' && dragStartPoint) {
            var dragEndPoint = e.latlng;
            
            // 1. 构造矩形 GeoJSON
            // 注意：Turf 需要 [minX, minY, maxX, maxY] 或 Polygon 坐标闭环
            var coords = [[
                [dragStartPoint.lng, dragStartPoint.lat],
                [dragEndPoint.lng, dragStartPoint.lat],
                [dragEndPoint.lng, dragEndPoint.lat],
                [dragStartPoint.lng, dragEndPoint.lat],
                [dragStartPoint.lng, dragStartPoint.lat] // 闭合
            ]];
            var snapBox = turf.polygon(coords);
            
            // 2. 执行核心吸附计算
            executeSnap(snapBox);
            
            // 3. 清理
            if(rectOverlay) map.removeOverlay(rectOverlay);
            dragStartPoint = null;
            rectOverlay = null;
            map.enableDragging();
        }
    });

    function drawTempRect(pt1, pt2) {
        if(rectOverlay) map.removeOverlay(rectOverlay);
        var rectPoints = [
            new BMapGL.Point(pt1.lng, pt1.lat),
            new BMapGL.Point(pt2.lng, pt1.lat),
            new BMapGL.Point(pt2.lng, pt2.lat),
            new BMapGL.Point(pt1.lng, pt2.lat)
        ];
        rectOverlay = new BMapGL.Polygon(rectPoints, {
            strokeColor: "green", strokeWeight: 2, strokeStyle: 'dashed', fillColor: "transparent"
        });
        map.addOverlay(rectOverlay);
    }







    // --- 2. 状态管理 ---
    var appState = {
        mode: 'browse', // 'browse' | 'edit'
        polygons: [],   // 存所有闭合区域 {overlay, geoJson}
        markers: [],    // 存所有标记点
        drawingPts: [], // 当前绘制的点
        tempLine: null  // 当前绘制的辅助线
    };

    // --- 3. 交互逻辑 ---
    
    // 切换模式 (UE调用)
    window.setMode = function(modeName) {
        appState.mode = modeName;
        if(modeName === 'browse') {
            map.enableDragging(); // 浏览模式允许拖拽
            clearTempDrawing();
        } else {
            map.disableDragging(); // 编辑模式禁止地图移动，防止画歪
        }
    };
	
	// --- 辅助函数：创建黄色标记点 ---
	// 我们使用 BMapGL.Circle 来创建一个简单的实心圆点，实现“黄色点”效果。
	function createYellowDot(point) {
		// 创建一个半径为 5 像素的黄色圆点
		var yellowDot = new BMapGL.Circle(point, 5, { 
			strokeColor: "yellow", // 描边颜色
			strokeWeight: 1,       // 描边粗细
			fillColor: "yellow",   // 填充颜色
			fillOpacity: 1         // 完全不透明
		});
		map.addOverlay(yellowDot);
		return yellowDot;
	}

    // 鼠标左键：画点
    map.addEventListener('click', function(e) {
		// 确保在编辑模式
		if(appState.mode !== 'edit') return; 

		var pt = e.latlng;
		var point = new BMapGL.Point(pt.lng, pt.lat);
		appState.drawingPts.push(point);
		
		// 1. **新增：** 在点击位置放置一个黄色点
		var newDot = createYellowDot(point);

		// 2. 绘制临时线条（确保是蓝色）
		if (appState.tempLine) {
			map.removeOverlay(appState.tempLine);
		}
		appState.tempLine = new BMapGL.Polyline(appState.drawingPts, {
			strokeColor:"blue", // **蓝色连线**
			strokeWeight: 3, 
			strokeOpacity: 0.8
		});
		map.addOverlay(appState.tempLine);
    });

    // 鼠标右键：闭合多边形（需要清理掉临时绘制的黄色点和蓝线）
    map.addEventListener('rightclick', function(e) {
        if(appState.mode !== 'edit' || appState.drawingPts.length < 3) return;

        // 1. 生成闭合多边形显示
        var polygon = new BMapGL.Polygon(appState.drawingPts, {
            strokeColor: "blue", strokeWeight: 2, strokeOpacity: 0.5,
            fillColor: "rgba(0,0,0,0.4)" 
        });
        map.addOverlay(polygon);

        // 2. 生成 GeoJSON 数据用于数学计算
        var coords = appState.drawingPts.map(p => [p.lng, p.lat]);
        coords.push(coords[0]); // 首尾相连
        var newGeoJson = turf.polygon([coords]);

        // 3. 计算拓扑交叉 (商业级核心需求)
        checkAndHighlightIntersection(newGeoJson);

        // 4. 入库
        appState.polygons.push({ overlay: polygon, geoJson: newGeoJson });
        clearTempDrawing();
		
		// 清理临时状态
		drawingPoints = [];
		if(appState.tempLine) map.removeOverlay(appState.tempLine);
		appState.tempLine = null;
		
		// **新增清理：** 移除临时绘制的黄色点 (这是生产环境中需要的额外逻辑)
		// 完整实现应在 drawingPts 中同时保存点的引用并在此处遍历移除。
		// 由于地图Overlay较多，建议在每次闭合时执行 map.clearOverlays()，然后重绘所有已保存的多边形。
		
		// 2. **关键：** 成功闭合后，执行清理
		clearTempDrawing();
    });

	// --- 辅助函数：清理临时绘制状态 ---
    function clearTempDrawing() {
			// 确保清空用于绘制点的数组
		appState.drawingPts = []; 

		// 移除临时线条
		if(appState.tempLine) {
			map.removeOverlay(appState.tempLine);
			appState.tempLine = null;
    }
    
    // **重要新增：** 移除所有临时绘制的黄色点
    appState.tempDots.forEach(dot => map.removeOverlay(dot));
    appState.tempDots = [];
    }

    // --- 4. 拓扑算法 (Turf.js) ---
    function checkAndHighlightIntersection(newPolyGeo) {
        // 遍历所有已存在的多边形
        appState.polygons.forEach(existPoly => {
            var intersection = turf.intersect(newPolyGeo, existPoly.geoJson);
            if(intersection) {
                // 如果有交集，绘制红色高亮块
                var rawCoords = intersection.geometry.coordinates;
                // 注意：Turf 返回的结构可能是多重数组，这里简化处理单区域
                // 生产环境需递归解析 MultiPolygon
                var path = rawCoords[0].map(p => new BMapGL.Point(p[0], p[1]));
                
                var highLight = new BMapGL.Polygon(path, {
                    strokeColor: "red", fillColor: "red", fillOpacity: 0.6
                });
                map.addOverlay(highLight);
            }
        });
    }

    // --- 5. 标点系统 (Req 8) ---
    window.addMapMarker = function(lng, lat, typeStr) {
        var pt = new BMapGL.Point(lng, lat);
        // 实际开发请根据 typeStr 切换 iconUrl
        var marker = new BMapGL.Marker(pt); 
        map.addOverlay(marker);
        appState.markers.push({mk: marker, type: typeStr});
    };

    window.filterMarkers = function(typeStr) {
        appState.markers.forEach(item => {
            if(item.type === typeStr || typeStr === "All") item.mk.show();
            else item.mk.hide();
        });
    };

    // --- 6. 数据 IO (与 UE5 通信) ---
    
    // 导出数据 -> UE5
    window.exportData = function() {
        var saveData = {
            polys: appState.polygons.map(p => p.geoJson),
            markers: appState.markers.map(m => ({
                lat: m.mk.getPosition().lat,
                lng: m.mk.getPosition().lng,
                type: m.type
            }))
        };
        // 核心 Hack：通过修改 Title 触发 UE5 回调
        document.title = "UE_SAVE:" + JSON.stringify(saveData);
    };

    // 导入数据 <- UE5
    window.importData = function(jsonStr) {
        var data = JSON.parse(jsonStr);
        map.clearOverlays();
        appState.polygons = [];
        
        // 恢复多边形
        if(data.polys) {
            data.polys.forEach(geo => {
                var coords = geo.geometry.coordinates[0];
                var path = coords.map(p => new BMapGL.Point(p[0], p[1]));
                var poly = new BMapGL.Polygon(path, {
                    strokeColor: "blue", strokeWeight: 2, fillColor: "rgba(0,0,0,0.4)"
                });
                map.addOverlay(poly);
                appState.polygons.push({ overlay: poly, geoJson: geo });
            });
        }
        // 恢复标记... (逻辑同上)
    };
</script> -->



<!--
<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <style type="text/css">
        body, html, #allmap {width: 100%;height: 100%;overflow: hidden;margin:0;font-family:"微软雅黑";}
        .anchorBL{display:none;} /* 隐藏百度Logo */
    </style>
    
    <script type="text/javascript" src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
    
    <title>GIS Engine GL</title>
</head>
<body>
    <div id="allmap"></div>
</body>
</html>
<script type="text/javascript">
    // 【关键修正】使用 BMapGL 对象进行初始化
    // BMapGL 是百度 WebGL 版本的入口对象
    var map = new BMapGL.Map("allmap", {enableMapClick:false});
    
    // 初始化中心点 (北京)
    var point = new BMapGL.Point(116.404, 39.915);
    map.centerAndZoom(point, 15);
    
    // 启用交互功能
    map.enableScrollWheelZoom(true);
    map.disableDoubleClickZoom(); 

	// === 新增：UE 驱动地图的控制函数 ===

	// 参数：地图中心经度, 纬度, 缩放级别
	function setMapState(lng, lat, zoom) {
		var newPoint = new BMapGL.Point(lng, lat);
		map.centerAndZoom(newPoint, zoom);
		// 注意：这里调用 centerAndZoom 会触发 'moveend'/'zoomend'，进而调用 syncState() 回传给 UE
	}

	// 参数：经度差值, 纬度差值 (用于平移)
	function panMapBy(deltaLng, deltaLat) {
		var center = map.getCenter();
		var newLng = center.lng + deltaLng;
		var newLat = center.lat + deltaLat;
		var newPoint = new BMapGL.Point(newLng, newLat);
		map.panTo(newPoint, { noAnimation: true }); // 禁用动画，保证即时同步
		// panTo 也会触发 'moveend'，进而调用 syncState()
	}

    // === 核心：极速状态同步 (URL Hash Messaging) ===
    function syncState() {
        // BMapGL 和 BMap 的 API 保持一致
        var c = map.getCenter();
        var z = map.getZoom();
        
        // 格式: #s=lng,lat,zoom
        var hash = "s=" + c.lng.toFixed(6) + "," + c.lat.toFixed(6) + "," + z;
        
        // 只有变化时才写入，避免无意义刷新
        if(window.location.hash !== "#" + hash) {
            window.location.hash = hash;
        }
    }

    // 监听所有可能改变视图的事件
    map.addEventListener("dragend", syncState);
    map.addEventListener("zoomend", syncState);
    map.addEventListener("moving", syncState); 
    map.addEventListener("zoom_changed", syncState); 
    
    // 初始化发送
    setTimeout(syncState, 500);
</script>
-->













<!--
<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <style type="text/css">
        body, html, #allmap {width: 100%;height: 100%;overflow: hidden;margin:0;font-family:"微软雅黑";}
        .anchorBL{display:none;} /* 隐藏百度Logo */
    </style>
    
    <script type="text/javascript" src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
    
    <title>GIS Engine GL</title>
</head>
<body>
    <div id="allmap"></div>
</body>
</html>
<script type="text/javascript">
    // 【关键修正】使用 BMapGL 对象进行初始化
    // BMapGL 是百度 WebGL 版本的入口对象
    var map = new BMapGL.Map("allmap", {enableMapClick:false});
    
    // 初始化中心点 (北京)
    var point = new BMapGL.Point(116.404, 39.915);
    map.centerAndZoom(point, 15);
    
    // 启用交互功能
    map.enableScrollWheelZoom(true);
    map.disableDoubleClickZoom(); 

    // === 核心：极速状态同步 (URL Hash Messaging) ===
    function syncState() {
        // BMapGL 和 BMap 的 API 保持一致
        var c = map.getCenter();
        var z = map.getZoom();
        
        // 格式: #s=lng,lat,zoom
        var hash = "s=" + c.lng.toFixed(6) + "," + c.lat.toFixed(6) + "," + z;
        
        // 只有变化时才写入，避免无意义刷新
        if(window.location.hash !== "#" + hash) {
            window.location.hash = hash;
        }
    }

    // 监听所有可能改变视图的事件
    map.addEventListener("dragend", syncState);
    map.addEventListener("zoomend", syncState);
    map.addEventListener("moving", syncState); 
    map.addEventListener("zoom_changed", syncState); 
    
    // 初始化发送
    setTimeout(syncState, 500);
</script>
-->




<!--
<!doctype html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>百度地图</title>
    <style>
        #map { width: 100%; height: 100vh; }
    </style>
    <script src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
</head>


<body>
    <div id="map"></div>
    <script>
        const map = new BMapGL.Map('map');  // 创建地图实例
        const center = new BMapGL.Point(116.404, 39.915);  // 设置地图中心点（北京）
        map.centerAndZoom(center, 15);  // 初始化地图，设置中心点坐标和缩放级别
        map.enableScrollWheelZoom(true);  // 启用滚轮缩放
		map.disableDoubleClickZoom(); // UE接管双击
        
		// === 核心：极速状态同步 ===
		function syncState() {
			var c = map.getCenter();
			var z = map.getZoom();
			// 保留6位小数足矣，减少字符串长度
			var hash = "s=" + c.lng.toFixed(6) + "," + c.lat.toFixed(6) + "," + z;
			
			// 只有变化时才写入，避免无意义刷新
			if(window.location.hash !== "#" + hash) {
				window.location.hash = hash;
			}
		}
		
		// 监听所有可能改变视图的事件
		map.addEventListener("dragend", syncState);
		map.addEventListener("zoomend", syncState);
		map.addEventListener("moving", syncState); // 拖拽中实时同步
		map.addEventListener("zoom_changed", syncState); // 缩放中实时同步
		
		// 初始化发送
		setTimeout(syncState, 500);
		
		// JS → UE 交互：例如地图点击位置
        //map.addEventListener('click', function (e) {
        //    console.log(JSON.stringify({ type: 'click', lng: e.latlng.lng, lat: e.latlng.lat }));
        //});

        // UE → JS 交互：例如改变视角
        //window.setView = (lng, lat, zoom = 15) => {
        //    map.centerAndZoom(new BMapGL.Point(lng, lat), zoom);
        //};
    </script>
</body>
</html>
-->




<!--
<!DOCTYPE html>
<html>
<head>
     <meta charset="utf-8"/>
	<title>GIS Tool</title>
    <style type="text/css">
        #map { width: 100%; height: 100vh; }
    </style>
    <script src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
</head>

<body>
    <div id="map"></div>
    <script>
		// 初始化北京
		const map = new BMapGL.Map('map');  // 创建地图实例
		const center = new BMapGL.Point(116.404, 39.915);  // 设置地图中心点（北京）
		map.centerAndZoom(center, 15);
		map.enableScrollWheelZoom(true);
		map.disableDoubleClickZoom(); // 禁用双击放大，留给UE做交互
		
		// 【关键1】开启滚轮，但尽量减少惯性 (百度API没有直接禁止惯性的开关，但我们可以高频监听)
		map.enableScrollWheelZoom(true);
		map.disableDoubleClickZoom();

		// === 核心逻辑：将地图状态发送给 UE ===
		// 我们通过修改 URL 的 Hash 部分来传递数据，这不会导致页面刷新
		function updateStateToUE() {
			var center = map.getCenter();
			var zoom = map.getZoom();
			
			// 【关键2】增加高精度的 hash 发送
			var hash = "state=" + center.lng.toFixed(6) + "," + center.lat.toFixed(6) + "," + zoom;
			
			// 只有当 hash 变化时才发送，避免死循环
			if(window.location.hash !== "#" + hash) {
				window.location.hash = hash;
			}
		}

		// 监听拖拽和缩放
		// 【关键3】监听所有可能导致视图变化的事件
		// 'moveend' 和 'zoomend' 是基础
		map.addEventListener("moveend", updateStateToUE);
		map.addEventListener("dragend", updateStateToUE); 
		map.addEventListener("zoomend", updateStateToUE);
		// 'moving' 和 'zoom_changed' 可以尝试捕获过程中的变化，减少视觉延迟
		map.addEventListener("moving", updateStateToUE);
		// 稍微延迟一下初始发送
		setTimeout(updateStateToUE, 500);
	</script>
</body>
</html>
-->

















<!--
<!DOCTYPE html>
<html>
<head>
     <meta charset="utf-8"/>
	<title>GIS Tool</title>
    <style type="text/css">
        #map { width: 100%; height: 100vh; }
    </style>
    <script src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
</head>

<body>
    <div id="map"></div>
    <script>
		// 初始化北京
		const map = new BMapGL.Map('map');  // 创建地图实例
		const center = new BMapGL.Point(116.404, 39.915);  // 设置地图中心点（北京）
		map.centerAndZoom(center, 15);
		map.enableScrollWheelZoom(true);
		map.disableDoubleClickZoom(); // 禁用双击放大，留给UE做交互

		// === 核心逻辑：将地图状态发送给 UE ===
		// 我们通过修改 URL 的 Hash 部分来传递数据，这不会导致页面刷新
		function updateStateToUE() {
			var center = map.getCenter();
			var zoom = map.getZoom();
			// 格式: #state=经度,纬度,缩放
			var hash = "state=" + center.lng.toFixed(6) + "," + center.lat.toFixed(6) + "," + zoom;
			window.location.hash = hash;
		}

		// 监听拖拽和缩放
		map.addEventListener("dragend", updateStateToUE); 
		map.addEventListener("zoomend", updateStateToUE);
		// 稍微延迟一下初始发送
		setTimeout(updateStateToUE, 10);
	</script>
</body>
</html>
-->









<!--
<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <style type="text/css">
        body, html, #allmap {width: 100%;height: 100%;overflow: hidden;margin:0;font-family:"微软雅黑";}
        /* 隐藏百度地图自带的UI，防止干扰 */
        .anchorBL{display:none;} 
    </style>
    <script type="text/javascript" src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script> 
    <title>UE5 GIS Map</title>

</head>
<body>
    <div id="allmap"></div>
</body>
</html>
<script type="text/javascript">
    var map = new BMap.Map("allmap");
    // 初始化中心点 (北京)
    var point = new BMap.Point(116.404, 39.915);
    map.centerAndZoom(point, 15);
    map.enableScrollWheelZoom(true);

    // 禁止双击放大，因为我们要用双击来闭合图形
    map.disableDoubleClickZoom();

    // === 核心：向 UE 发送状态 ===
    function sendStateToUE() {
        if (window.ue && window.ue.gisbridge) {
            var center = map.getCenter();
            var zoom = map.getZoom();
            // 调用 UE C++ 函数
            window.ue.gisbridge.onmapstatechanged(center.lng, center.lat, zoom);
        }
    }
	
	// 在 map.html 文件中，用于替换旧的 BindUObject 调用
	function sendCommand(command, data) {
		// 确保数据是 URL 安全的
		var payload = data ? '&data=' + encodeURIComponent(data) : '';
		
		// 关键：通过修改 hash 触发 OnUrlChanged 事件
		// 完整 URL Hash 示例: #ue_command=save&data={...geojson...}
		window.location.hash = `#ue_command=${command}${payload}`;
	}

	function handleSave() {
		var geoJsonData = getMapDataAsGeoJson(); // 假设这是获取数据的函数
		sendCommand('save', geoJsonData); 
	}

	function handleEditMode(enable) {
		if (enable) {
			sendCommand('mode_edit', '');
		} else {
			sendCommand('mode_view', '');
		}
	}

    // 绑定事件：拖拽中、缩放中都需要高频更新
    map.addEventListener("moving", sendStateToUE); 
    map.addEventListener("zoomend", sendStateToUE);
    map.addEventListener("dragend", sendStateToUE);
    
    // 初始化时发送一次
    setTimeout(sendStateToUE, 1000);
</script>
-->