<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <style>
        /* ================= 1. åŸºç¡€æ ·å¼ ================= */
        html, body, #map_container { width: 100%; height: 100%; overflow: hidden; margin: 0; font-family: "å¾®è½¯é›…é»‘"; }
        .anchorBL, .BMap_cpyCtrl { display: none; } /* éšè—ç™¾åº¦ç‰ˆæƒ */

        /* ================= 2. è‡ªå®šä¹‰ä¿å­˜å¼¹çª— (å±å¹•æ­£ä¸‹æ–¹) ================= */
        #save_modal {
            display: none; 
            position: fixed; 
            left: 50%; bottom: 80px; transform: translateX(-50%);
            z-index: 9999;
            background: rgba(255, 255, 255, 0.95); 
            backdrop-filter: blur(10px);
            width: 260px; padding: 20px;
            border-radius: 12px; 
            box-shadow: 0 8px 30px rgba(0,0,0,0.3);
            border: 1px solid #eee;
            animation: popUp 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }

        @keyframes popUp { from { bottom: -200px; opacity: 0; } to { bottom: 80px; opacity: 1; } }

        #save_modal h4 { margin: 0 0 15px 0; font-size: 16px; color: #333; text-align: center; }
        #save_modal select { width: 100%; padding: 8px; margin-bottom: 15px; border: 1px solid #ddd; border-radius: 6px; outline: none; }
        #save_modal input { width: 92%; padding: 8px; margin-bottom: 20px; border: 1px solid #ddd; border-radius: 6px; outline: none; }

        .btn-group { display: flex; justify-content: space-between; gap: 10px; }
        .btn-group button { flex: 1; padding: 8px; cursor: pointer; border: none; border-radius: 6px; color: white; font-weight: bold; }
        #btn_confirm { background-color: #007bff; } 
        #btn_confirm:hover { background-color: #0056b3; }
        #btn_cancel { background-color: #6c757d; } 
        #btn_cancel:hover { background-color: #5a6268; }
    </style>
    
    <script type="text/javascript" src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
    <script src="turf.min.js"></script>
</head>
<body>
    <div id="map_container"></div>

    <div id="save_modal">
        <h4 id="modal_title">åˆ†æå®Œæˆ</h4>
        <select id="color_selector">
            <option value="yellow" selected>ğŸŸ¡ ä»…ä¿ç•™é»„è‰² (æ–°æ‹“å±•åŒº)</option>
            <option value="purple">ğŸŸ£ ä»…ä¿ç•™ç´«è‰² (å•ä¾§è¦†ç›–)</option>
            <option value="pink">ğŸŒ¸ ä»…ä¿ç•™æ·¡çº¢ (é‡å æ ¸å¿ƒ)</option>
            <option value="all">ğŸ’  ä¿ç•™æ‰€æœ‰åŒºåŸŸ</option>
        </select>
        <input type="text" id="poly_name_input" placeholder="è¯·è¾“å…¥åŒºåŸŸåç§°" value="æˆ‘çš„åŒºåŸŸ">
        <div class="btn-group">
            <button id="btn_cancel" onclick="closeModal()">ä¸¢å¼ƒ</button>
            <button id="btn_confirm" onclick="confirmSave()">ä¿å­˜</button>
        </div>
    </div>
</body>
</html>

<script>
    // ================= 1. å…¨å±€é…ç½®ä¸çŠ¶æ€ =================
    window.onerror = function(msg, url, line) { console.log("UE_ERROR:JS_Error:" + msg + " Line:" + line); };

    var map = new BMapGL.Map("map_container");
    map.centerAndZoom(new BMapGL.Point(116.404, 39.915), 17);
    map.enableScrollWheelZoom(true);
    map.setTilt(0);

    var appState = {
        mode: 'browse', 
        polygons: [],   // æ°¸ä¹…æ•°æ®
        drawPath: [], isDrawing: false, tempPolyline: null,
        canSnapClose: false, snapHintCircle: null,
        analysisOverlays: [], tempResultData: [],
        isSaving: false 
    };
    var ID_COUNTER = 1;

    // ================= 2. äº¤äº’é€»è¾‘ =================
    window.setMode = function(mode) {
        appState.mode = mode;
        closeModal(); clearAnalysis(); clearTemp();
        if(mode === 'browse') map.enableDragging();
        else map.disableDragging();
    };

    map.addEventListener('mousedown', function(e) {
        if(appState.mode === 'browse') return;
        if(e.target.closest('#save_modal')) return;
        appState.isDrawing = true; appState.drawPath = [e.latlng]; appState.canSnapClose = false;
    });

    map.addEventListener('mousemove', function(e) {
        if(!appState.isDrawing || appState.mode === 'browse') return;
        var currentPt = e.latlng;
        appState.drawPath.push(currentPt);
        if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline);
        appState.tempPolyline = new BMapGL.Polyline(appState.drawPath.map(p=>new BMapGL.Point(p.lng, p.lat)), {strokeColor:"blue", strokeWeight:2});
        map.addOverlay(appState.tempPolyline);
        checkSnapProximity(currentPt);
    });

    map.addEventListener('mouseup', function(e) {
        if(!appState.isDrawing || appState.mode === 'browse') return;
        appState.isDrawing = false;
        if(appState.drawPath.length < 3) { clearTemp(); return; }

        if (appState.canSnapClose) appState.drawPath.push(appState.drawPath[0]);
        else appState.drawPath.push(appState.drawPath[0]);

        var coords = appState.drawPath.map(p => [p.lng, p.lat]);
        var rawGeo = turf.polygon([coords]);
        var simpleGeo = turf.simplify(rawGeo, {tolerance: 0.00001, highQuality: false});

        if (appState.mode === 'edit') prepareSingleSave(simpleGeo);
        else if (appState.mode === 'reconstruct') executeAnalysis(simpleGeo);
        
        clearTemp();
    });

    function checkSnapProximity(currentPt) {
        if (appState.drawPath.length < 10) return; 
        var startPt = appState.drawPath[0];
        var pixStart = map.pointToPixel(new BMapGL.Point(startPt.lng, startPt.lat));
        var pixCurrent = map.pointToPixel(new BMapGL.Point(currentPt.lng, currentPt.lat));
        var dist = Math.sqrt(Math.pow(pixStart.x - pixCurrent.x, 2) + Math.pow(pixStart.y - pixCurrent.y, 2));

        if (dist < 20) {
            appState.canSnapClose = true;
            if (!appState.snapHintCircle) {
                appState.snapHintCircle = new BMapGL.Circle(new BMapGL.Point(startPt.lng, startPt.lat), 5, {
                    strokeColor: "white", strokeWeight: 2, fillColor: "#FFD700", fillOpacity: 0.9
                });
                map.addOverlay(appState.snapHintCircle);
            }
        } else {
            appState.canSnapClose = false;
            if (appState.snapHintCircle) {
                map.removeOverlay(appState.snapHintCircle);
                appState.snapHintCircle = null;
            }
        }
    }

    // ================= 4. åˆ†æä¸ä¿å­˜ =================
    function executeAnalysis(polyX) {
        clearAnalysis(); appState.tempResultData = [];
        if(appState.polygons.length === 0) { prepareSingleSave(polyX); return; }

        try {
            var featX = turf.feature(polyX.geometry);
            var existFeats = appState.polygons.map(p => turf.feature(p.geoJson.geometry));

            var unionC = null;
            for(let i=0; i<existFeats.length; i++) {
                for(let j=i+1; j<existFeats.length; j++) {
                    var inter = turf.intersect(existFeats[i], existFeats[j]);
                    if(inter) unionC = unionC ? turf.union(unionC, inter) : inter;
                }
            }
            var interXC = unionC ? turf.intersect(featX, unionC) : null;
            if(interXC) cacheResult(interXC, "#FFC0CB", 0.6, "é‡å æ ¸å¿ƒ", false, 'pink');

            var unionAll = existFeats[0];
            for(let i=1; i<existFeats.length; i++) unionAll = turf.union(unionAll, existFeats[i]);
            var interTotal = turf.intersect(featX, unionAll);
            var interPurple = (interTotal && interXC) ? turf.difference(interTotal, interXC) : interTotal;
            if(interPurple) cacheResult(interPurple, "#800080", 0.4, "å•ä¾§è¦†ç›–", false, 'purple');

            if(interTotal) {
                var lines = turf.polygonToLine(interTotal);
                cacheResult(lines, "#FFA500", 1.0, "äº¤ç•Œçº¿", true, 'orange');
            }

            var resE = turf.difference(featX, unionAll);
            if(resE) cacheResult(resE, "yellow", 0.3, "æ–°æ‹“å±•åŒº", false, 'yellow');

            showModal(true); 

        } catch(e) { console.log("UE_ERROR:" + e.message); alert("åˆ†æé”™è¯¯"); }
    }

    // ã€é‡è¦ä¿®å¤ã€‘è¿™é‡Œä¹‹å‰å†™äº†ä¸¤éæ·»åŠ æ•°æ®ï¼Œå¯¼è‡´ tempResultData é‡Œæœ‰ä¸¤ä»½
    function prepareSingleSave(geoJson) {
        // 1. å…ˆæ¸…ç©ºæ•°ç»„
        appState.tempResultData = [];
        // 2. ä»…é€šè¿‡ cacheResult æ·»åŠ ä¸€æ¬¡ï¼ä¸è¦æ‰‹åŠ¨èµ‹å€¼ï¼
        cacheResult(geoJson, 'blue', 0.5, 'Temp', false, 'single');
        showModal(false);
    }

    function showModal(isMulti) {
        var modal = document.getElementById('save_modal');
        var sel = document.getElementById('color_selector');
        var title = document.getElementById('modal_title');
        
        if(isMulti) { sel.style.display = 'block'; sel.value = 'yellow'; title.innerText = "é‡æ„åˆ†æå®Œæˆ"; } 
        else { sel.style.display = 'none'; title.innerText = "ç»˜åˆ¶å®Œæˆ"; }
        
        modal.style.display = 'block';
        setTimeout(() => document.getElementById('poly_name_input').focus(), 50);
    }

    function closeModal() {
        document.getElementById('save_modal').style.display = 'none';
        clearAnalysis();
    }

    window.confirmSave = function() {
        if (appState.isSaving) return; 
        
        var nameInput = document.getElementById('poly_name_input').value || "æœªå‘½å";
        var sel = document.getElementById('color_selector');
        var choice = (sel.style.display === 'none') ? 'single' : sel.value;

        var toSave = [];
        if(choice === 'all' || choice === 'single') toSave = appState.tempResultData;
        else toSave = appState.tempResultData.filter(i => i.rawType === choice);

        if(toSave.length === 0) { alert("æ²¡æœ‰è¯¥é¢œè‰²çš„åŒºåŸŸï¼"); return; }

        document.getElementById('save_modal').style.display = 'none';
        appState.isSaving = true;

        processSaveQueue(toSave, nameInput, 0);
    };

    function processSaveQueue(list, baseName, index) {
        if(index >= list.length) {
            appState.tempResultData = [];
            appState.isSaving = false;
            return;
        }

        var item = list[index];
        var finalName = (list.length > 1) ? (baseName + "_" + item.rawType + "_" + (index+1)) : baseName;
        
        addPermanent(item.geoJson, item.color, item.opacity, item.isLine, finalName);

        setTimeout(function() {
            processSaveQueue(list, baseName, index + 1);
        }, 300);
    }

    // ================= 6. è¾…åŠ©å‡½æ•° =================
    function cacheResult(geo, col, op, name, line, type) {
        var geoms = flattenGeo(geo);
        geoms.forEach(path => {
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4}) 
                          : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1});
            map.addOverlay(ov);
            appState.analysisOverlays.push(ov);
        });
        // åªæœ‰è¿™é‡Œå¯ä»¥ push æ•°æ®ï¼Œå…¶ä»–åœ°æ–¹ä¸è¦ push
        appState.tempResultData.push({geoJson:geo, color:col, opacity:op, rawType:type, isLine:line});
    }

    function addPermanent(geo, col, op, line, name) {
        var id = 'poly_' + (ID_COUNTER++);
        geo.properties = { id: id, name: name, svCol: col, svOp: op, svLine: line };
        var geoms = flattenGeo(geo);
        geoms.forEach(path => {
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4, strokeOpacity:op}) 
                          : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1});
            ov.addEventListener('click', function(){ window.focusPoly(id); });
            map.addOverlay(ov);
            appState.polygons.push({overlay:ov, geoJson:geo});
        });
        
        var randomTag = new Date().getTime(); 
        console.log("UE_ADD:" + id + "|" + name + "|" + randomTag);
    }

    function flattenGeo(geo) {
        var coords = [];
        if(!geo || !geo.geometry) return [];
        var type = geo.geometry.type;
        if(type === 'MultiPolygon') coords = geo.geometry.coordinates.map(c=>c[0]);
        else if(type === 'Polygon') coords = [geo.geometry.coordinates[0]];
        else if(type === 'LineString') coords = [geo.geometry.coordinates];
        else if(type === 'MultiLineString') coords = geo.geometry.coordinates;
        var res = [];
        coords.forEach(c => { if(c) res.push(c.map(p => new BMapGL.Point(p[0], p[1]))); });
        return res;
    }

    function clearTemp() { 
        appState.drawPath=[]; 
        if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline); 
        if(appState.snapHintCircle) { map.removeOverlay(appState.snapHintCircle); appState.snapHintCircle = null; }
        appState.canSnapClose = false;
    }

    function clearAnalysis() { appState.analysisOverlays.forEach(o=>map.removeOverlay(o)); appState.analysisOverlays=[]; appState.tempResultData=[]; }

    // ================= 7. IO æ¥å£ =================
    window.exportMap = function(fname) {
        var data = appState.polygons.map(p => p.geoJson);
        console.log("UE_SAVE:" + fname + "|" + JSON.stringify(data));
    };
    window.importMap = function(json) {
        map.clearOverlays(); appState.polygons=[];
        var list = JSON.parse(json);
        list.forEach((g, i) => {
            var p = g.properties;
            setTimeout(() => addPermanent(g, p.svCol, p.svOp, p.svLine, p.name), i * 50);
        });
    };
    window.focusPoly = function(id) {
        var targets = appState.polygons.filter(p => p.geoJson.properties.id === id);
        if(targets.length > 0) {
            var b = new BMapGL.Bounds();
            targets.forEach(t => {
                var ovs = Array.isArray(t.overlay) ? t.overlay : [t.overlay];
                ovs.forEach(o => {
                    var path = o.getPath(); path.forEach(pt=>b.extend(pt));
                    var oldColor = o.getStrokeColor();
                    o.setStrokeColor("red"); o.setStrokeWeight(4);
                    setTimeout(() => { o.setStrokeColor(oldColor); o.setStrokeWeight(1); }, 800);
                });
            });
            map.setViewport(b);
        }
    };
    window.deletePoly = function(id) {
        var targets = appState.polygons.filter(p => p.geoJson.properties.id === id);
        if(targets.length > 0) {
            targets.forEach(t => {
                var ovs = Array.isArray(t.overlay) ? t.overlay : [t.overlay];
                ovs.forEach(o => map.removeOverlay(o));
            });
            appState.polygons = appState.polygons.filter(p => p.geoJson.properties.id !== id);
            console.log("UE_LOG: Deleted poly " + id);
        }
    };
</script>









<!--
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <style>
        /* ================= 1. åŸºç¡€æ ·å¼ ================= */
        html, body, #map_container { width: 100%; height: 100%; overflow: hidden; margin: 0; font-family: "å¾®è½¯é›…é»‘"; }
        .anchorBL, .BMap_cpyCtrl { display: none; } /* éšè—ç™¾åº¦ç‰ˆæƒ */

        /* ================= 2. è‡ªå®šä¹‰ä¿å­˜å¼¹çª— (å±å¹•æ­£ä¸‹æ–¹) ================= */
        #save_modal {
            display: none; 
            position: fixed; 
            left: 50%; bottom: 80px; transform: translateX(-50%);
            z-index: 9999;
            background: rgba(255, 255, 255, 0.95); 
            backdrop-filter: blur(10px);
            width: 260px; padding: 20px;
            border-radius: 12px; 
            box-shadow: 0 8px 30px rgba(0,0,0,0.3);
            border: 1px solid #eee;
            animation: popUp 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }

        @keyframes popUp { from { bottom: -200px; opacity: 0; } to { bottom: 80px; opacity: 1; } }

        #save_modal h4 { margin: 0 0 15px 0; font-size: 16px; color: #333; text-align: center; }
        #save_modal select { width: 100%; padding: 8px; margin-bottom: 15px; border: 1px solid #ddd; border-radius: 6px; outline: none; }
        #save_modal input { width: 92%; padding: 8px; margin-bottom: 20px; border: 1px solid #ddd; border-radius: 6px; outline: none; }

        .btn-group { display: flex; justify-content: space-between; gap: 10px; }
        .btn-group button { flex: 1; padding: 8px; cursor: pointer; border: none; border-radius: 6px; color: white; font-weight: bold; }
        #btn_confirm { background-color: #007bff; } 
        #btn_confirm:hover { background-color: #0056b3; }
        #btn_cancel { background-color: #6c757d; } 
        #btn_cancel:hover { background-color: #5a6268; }
    </style>
    
    <script type="text/javascript" src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
    <script src="turf.min.js"></script>
</head>
<body>
    <div id="map_container"></div>

    <div id="save_modal">
        <h4 id="modal_title">åˆ†æå®Œæˆ</h4>
        <select id="color_selector">
            <option value="yellow" selected>ğŸŸ¡ ä»…ä¿ç•™é»„è‰² (æ–°æ‹“å±•åŒº)</option>
            <option value="purple">ğŸŸ£ ä»…ä¿ç•™ç´«è‰² (å•ä¾§è¦†ç›–)</option>
            <option value="pink">ğŸŒ¸ ä»…ä¿ç•™æ·¡çº¢ (é‡å æ ¸å¿ƒ)</option>
            <option value="all">ğŸ’  ä¿ç•™æ‰€æœ‰åŒºåŸŸ</option>
        </select>
        <input type="text" id="poly_name_input" placeholder="è¯·è¾“å…¥åŒºåŸŸåç§°" value="æˆ‘çš„åŒºåŸŸ">
        <div class="btn-group">
            <button id="btn_cancel" onclick="closeModal()">ä¸¢å¼ƒ</button>
            <button id="btn_confirm" onclick="confirmSave()">ä¿å­˜</button>
        </div>
    </div>
</body>
</html>
<script>
    // ================= 1. å…¨å±€é…ç½®ä¸çŠ¶æ€ =================
    // æ•è·æ‰€æœ‰JSé”™è¯¯å¹¶æ‰“å°åˆ°æ§åˆ¶å°ï¼Œä¾›UE5 OutputLogæŸ¥çœ‹
    window.onerror = function(msg, url, line) { console.log("UE_ERROR:JS_Error:" + msg + " Line:" + line); };

    var map = new BMapGL.Map("map_container");
    map.centerAndZoom(new BMapGL.Point(116.404, 39.915), 17);
    map.enableScrollWheelZoom(true);
    map.setTilt(0);

    var appState = {
        mode: 'browse', 
        polygons: [],   // æ°¸ä¹…æ•°æ®
        
        // ç»˜å›¾ç›¸å…³
        drawPath: [], 
        isDrawing: false, 
        tempPolyline: null,
        
        // å¸é™„ç›¸å…³
        canSnapClose: false,
        snapHintCircle: null,
        
        // åˆ†æç›¸å…³
        analysisOverlays: [], 
        tempResultData: [],
        isSaving: false // ã€æ–°å¢ã€‘ä¿å­˜é”
    };
    var ID_COUNTER = 1;

    // ================= 2. äº¤äº’é€»è¾‘ (C++ è°ƒç”¨) =================
    window.setMode = function(mode) {
        appState.mode = mode;
        closeModal(); clearAnalysis(); clearTemp();
        if(mode === 'browse') map.enableDragging();
        else map.disableDragging();
    };

    // ================= 3. æ‰‹ç»˜é€»è¾‘ (å«æ™ºèƒ½å¸é™„) =================
    map.addEventListener('mousedown', function(e) {
        if(appState.mode === 'browse') return;
        if(e.target.closest('#save_modal')) return;
        
        appState.isDrawing = true;
        appState.drawPath = [e.latlng];
        appState.canSnapClose = false;
    });

    map.addEventListener('mousemove', function(e) {
        if(!appState.isDrawing || appState.mode === 'browse') return;
        
        var currentPt = e.latlng;
        appState.drawPath.push(currentPt);
        
        // å®æ—¶ç”»çº¿
        if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline);
        appState.tempPolyline = new BMapGL.Polyline(appState.drawPath.map(p=>new BMapGL.Point(p.lng, p.lat)), {strokeColor:"blue", strokeWeight:2});
        map.addOverlay(appState.tempPolyline);

        // æ£€æµ‹å¸é™„
        checkSnapProximity(currentPt);
    });

    map.addEventListener('mouseup', function(e) {
        if(!appState.isDrawing || appState.mode === 'browse') return;
        appState.isDrawing = false;
        
        if(appState.drawPath.length < 3) { clearTemp(); return; }

        // --- å¸é™„åˆ¤å®š ---
        if (appState.canSnapClose) {
            // å¦‚æœå¸é™„æ¿€æ´»ï¼Œå¼ºåˆ¶é—­åˆåˆ°èµ·ç‚¹
            appState.drawPath.push(appState.drawPath[0]);
        } else {
            // æ­£å¸¸é—­åˆ
            appState.drawPath.push(appState.drawPath[0]);
        }

        // æ„å»ºå‡ ä½•ä½“å¹¶å¹³æ»‘
        var coords = appState.drawPath.map(p => [p.lng, p.lat]);
        var rawGeo = turf.polygon([coords]);
        var simpleGeo = turf.simplify(rawGeo, {tolerance: 0.00001, highQuality: false});

        // æ¨¡å¼åˆ†å‘
        if (appState.mode === 'edit') {
            prepareSingleSave(simpleGeo);
        } 
        else if (appState.mode === 'reconstruct') {
            executeAnalysis(simpleGeo);
        }
        
        clearTemp();
    });

    // å¸é™„æ£€æµ‹å‡½æ•°
    function checkSnapProximity(currentPt) {
        if (appState.drawPath.length < 10) return; // ç”»äº†ä¸€æ®µæ‰æ£€æµ‹

        var startPt = appState.drawPath[0];
        var pixStart = map.pointToPixel(new BMapGL.Point(startPt.lng, startPt.lat));
        var pixCurrent = map.pointToPixel(new BMapGL.Point(currentPt.lng, currentPt.lat));
        var dist = Math.sqrt(Math.pow(pixStart.x - pixCurrent.x, 2) + Math.pow(pixStart.y - pixCurrent.y, 2));

        // é˜ˆå€¼ 20px
        if (dist < 20) {
            appState.canSnapClose = true;
            if (!appState.snapHintCircle) {
                appState.snapHintCircle = new BMapGL.Circle(new BMapGL.Point(startPt.lng, startPt.lat), 5, {
                    strokeColor: "white", strokeWeight: 2, fillColor: "#FFD700", fillOpacity: 0.9
                });
                map.addOverlay(appState.snapHintCircle);
            }
        } else {
            appState.canSnapClose = false;
            if (appState.snapHintCircle) {
                map.removeOverlay(appState.snapHintCircle);
                appState.snapHintCircle = null;
            }
        }
    }

    // ================= 4. æ ¸å¿ƒåˆ†æç®—æ³• =================
    function executeAnalysis(polyX) {
        clearAnalysis(); appState.tempResultData = [];
        if(appState.polygons.length === 0) { prepareSingleSave(polyX); return; }

        try {
            var featX = turf.feature(polyX.geometry);
            var existFeats = appState.polygons.map(p => turf.feature(p.geoJson.geometry));

            // A. Union C
            var unionC = null;
            for(let i=0; i<existFeats.length; i++) {
                for(let j=i+1; j<existFeats.length; j++) {
                    var inter = turf.intersect(existFeats[i], existFeats[j]);
                    if(inter) unionC = unionC ? turf.union(unionC, inter) : inter;
                }
            }
            // B. X n C (Pink)
            var interXC = unionC ? turf.intersect(featX, unionC) : null;
            if(interXC) cacheResult(interXC, "#FFC0CB", 0.6, "é‡å æ ¸å¿ƒ", false, 'pink');

            // C. X n All - C (Purple)
            var unionAll = existFeats[0];
            for(let i=1; i<existFeats.length; i++) unionAll = turf.union(unionAll, existFeats[i]);
            var interTotal = turf.intersect(featX, unionAll);
            var interPurple = (interTotal && interXC) ? turf.difference(interTotal, interXC) : interTotal;
            if(interPurple) cacheResult(interPurple, "#800080", 0.4, "å•ä¾§è¦†ç›–", false, 'purple');

            // D. Lines (Orange)
            if(interTotal) {
                var lines = turf.polygonToLine(interTotal);
                cacheResult(lines, "#FFA500", 1.0, "äº¤ç•Œçº¿", true, 'orange');
            }

            // E. X - All (Yellow)
            var resE = turf.difference(featX, unionAll);
            if(resE) cacheResult(resE, "yellow", 0.3, "æ–°æ‹“å±•åŒº", false, 'yellow');

            showModal(true); 

        } catch(e) { console.log("UE_ERROR:" + e.message); alert("åˆ†æé”™è¯¯"); }
    }

    // ================= 5. å¼¹çª—ä¸ä¿å­˜é€»è¾‘ =================
    function prepareSingleSave(geoJson) {
        appState.tempResultData = [{
            geoJson: geoJson, color: 'blue', opacity: 0.5, rawType: 'single', isLine: false
        }];
        cacheResult(geoJson, 'blue', 0.5, 'Temp', false, 'single');
        showModal(false);
    }

    function showModal(isMulti) {
        var modal = document.getElementById('save_modal');
        var sel = document.getElementById('color_selector');
        var title = document.getElementById('modal_title');
        
        if(isMulti) { sel.style.display = 'block'; sel.value = 'yellow'; title.innerText = "é‡æ„åˆ†æå®Œæˆ"; } 
        else { sel.style.display = 'none'; title.innerText = "ç»˜åˆ¶å®Œæˆ"; }
        
        modal.style.display = 'block';
        setTimeout(() => document.getElementById('poly_name_input').focus(), 50);
    }

    function closeModal() {
        document.getElementById('save_modal').style.display = 'none';
        clearAnalysis();
    }

    window.confirmSave = function() {
        // ã€æ ¸å¿ƒä¿®å¤ 4ã€‘å¦‚æœæ­£åœ¨ä¿å­˜ä¸­ï¼Œç›´æ¥æŠŠå¤šä½™çš„ç‚¹å‡»æŒ¡å›å»
        if (appState.isSaving) return; 
        
        var nameInput = document.getElementById('poly_name_input').value || "æœªå‘½å";
        var sel = document.getElementById('color_selector');
        var choice = (sel.style.display === 'none') ? 'single' : sel.value;

        var toSave = [];
        if(choice === 'all' || choice === 'single') toSave = appState.tempResultData;
        else toSave = appState.tempResultData.filter(i => i.rawType === choice);

        if(toSave.length === 0) { alert("æ²¡æœ‰è¯¥é¢œè‰²çš„åŒºåŸŸï¼"); return; }

        document.getElementById('save_modal').style.display = 'none';
        
        // å¼€å¯é”
        appState.isSaving = true;

        // å¯åŠ¨é˜Ÿåˆ—
        processSaveQueue(toSave, nameInput, 0);
    };

    function processSaveQueue(list, baseName, index) {
        if(index >= list.length) {
            appState.tempResultData = [];
            appState.isSaving = false; // ã€è§£é”ã€‘å…¨éƒ¨å‘å®Œæ‰å…è®¸ä¸‹ä¸€æ¬¡ä¿å­˜
            return;
        }

        var item = list[index];
        var finalName = (list.length > 1) ? (baseName + "_" + item.rawType + "_" + (index+1)) : baseName;
        
        addPermanent(item.geoJson, item.color, item.opacity, item.isLine, finalName);

        // é—´éš”å‘é€
        setTimeout(function() {
            processSaveQueue(list, baseName, index + 1);
        }, 300);
    }

    // ================= 6. è¾…åŠ©å‡½æ•° =================
    function cacheResult(geo, col, op, name, line, type) {
        var geoms = flattenGeo(geo);
        geoms.forEach(path => {
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4}) 
                          : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1});
            map.addOverlay(ov);
            appState.analysisOverlays.push(ov);
        });
        appState.tempResultData.push({geoJson:geo, color:col, opacity:op, rawType:type, isLine:line});
    }

    function addPermanent(geo, col, op, line, name) {
        var id = 'poly_' + (ID_COUNTER++);
        geo.properties = { id: id, name: name, svCol: col, svOp: op, svLine: line };
        var geoms = flattenGeo(geo);
        geoms.forEach(path => {
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4, strokeOpacity:op}) 
                          : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1});
            ov.addEventListener('click', function(){ window.focusPoly(id); });
            map.addOverlay(ov);
            appState.polygons.push({overlay:ov, geoJson:geo});
        });
        
        // ä½¿ç”¨ console.log é€šä¿¡ (åŒ¹é… OnConsoleMessage)
        var randomTag = new Date().getTime(); 
        console.log("UE_ADD:" + id + "|" + name + "|" + randomTag);
    }

    function flattenGeo(geo) {
        var coords = [];
        if(!geo || !geo.geometry) return [];
        var type = geo.geometry.type;
        if(type === 'MultiPolygon') coords = geo.geometry.coordinates.map(c=>c[0]);
        else if(type === 'Polygon') coords = [geo.geometry.coordinates[0]];
        else if(type === 'LineString') coords = [geo.geometry.coordinates];
        else if(type === 'MultiLineString') coords = geo.geometry.coordinates;
        var res = [];
        coords.forEach(c => { if(c) res.push(c.map(p => new BMapGL.Point(p[0], p[1]))); });
        return res;
    }

    function clearTemp() { 
        appState.drawPath=[]; 
        if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline); 
        if(appState.snapHintCircle) { map.removeOverlay(appState.snapHintCircle); appState.snapHintCircle = null; }
        appState.canSnapClose = false;
    }

    function clearAnalysis() { appState.analysisOverlays.forEach(o=>map.removeOverlay(o)); appState.analysisOverlays=[]; appState.tempResultData=[]; }

    // ================= 7. IO æ¥å£ =================
    window.exportMap = function(fname) {
        var data = appState.polygons.map(p => p.geoJson);
        console.log("UE_SAVE:" + fname + "|" + JSON.stringify(data));
    };
    window.importMap = function(json) {
        map.clearOverlays(); appState.polygons=[];
        var list = JSON.parse(json);
        list.forEach((g, i) => {
            var p = g.properties;
            setTimeout(() => addPermanent(g, p.svCol, p.svOp, p.svLine, p.name), i * 50);
        });
    };
    
    // èšç„¦åŠŸèƒ½ (æ”¯æŒ MultiPolygon)
    window.focusPoly = function(id) {
        var targets = appState.polygons.filter(p => p.geoJson.properties.id === id);
        if(targets.length > 0) {
            var b = new BMapGL.Bounds();
            targets.forEach(t => {
                var ovs = Array.isArray(t.overlay) ? t.overlay : [t.overlay];
                ovs.forEach(o => {
                    var path = o.getPath(); path.forEach(pt=>b.extend(pt));
                    var oldColor = o.getStrokeColor();
                    o.setStrokeColor("red"); o.setStrokeWeight(4);
                    setTimeout(() => { o.setStrokeColor(oldColor); o.setStrokeWeight(1); }, 800);
                });
            });
            map.setViewport(b);
        } else {
            console.log("UE_ERROR: JS focusPoly not found: " + id);
        }
    };
    
    // åˆ é™¤åŠŸèƒ½ (æ”¯æŒ MultiPolygon)
    window.deletePoly = function(id) {
        var targets = appState.polygons.filter(p => p.geoJson.properties.id === id);
        if(targets.length > 0) {
            targets.forEach(t => {
                var ovs = Array.isArray(t.overlay) ? t.overlay : [t.overlay];
                ovs.forEach(o => map.removeOverlay(o));
            });
            appState.polygons = appState.polygons.filter(p => p.geoJson.properties.id !== id);
            console.log("UE_LOG: Deleted poly " + id);
        } else {
            console.log("UE_ERROR: JS deletePoly not found: " + id);
        }
    };
</script>
-->