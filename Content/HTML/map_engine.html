<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <style>
        /* ================= 1. åŸºç¡€æ ·å¼ ================= */
        html, body, #map_container { width: 100%; height: 100%; overflow: hidden; margin: 0; font-family: "å¾®è½¯é›…é»‘"; }
        .anchorBL, .BMap_cpyCtrl { display: none; } 

        /* ================= 2. å¼¹çª—æ ·å¼ ================= */
        #save_modal {
            display: none; position: fixed; 
            left: 50%; bottom: 80px; transform: translateX(-50%);
            z-index: 9999;
            background: rgba(255, 255, 255, 0.98); backdrop-filter: blur(12px);
            width: 280px; padding: 20px;
            border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            border: 1px solid #eee;
            animation: popUp 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }
        @keyframes popUp { from { bottom: -200px; opacity: 0; } to { bottom: 80px; opacity: 1; } }

        #save_modal h4 { margin: 0 0 10px 0; font-size: 16px; color: #333; text-align: center; }
        .input-label { font-size: 12px; color: #666; margin-bottom: 4px; display: block; }
        select, input { width: 100%; padding: 8px; margin-bottom: 12px; box-sizing: border-box; border: 1px solid #ddd; border-radius: 6px; outline: none; font-size: 14px; }
        .btn-group { display: flex; justify-content: space-between; gap: 10px; margin-top: 10px;}
        .btn-group button { flex: 1; padding: 8px; cursor: pointer; border: none; border-radius: 6px; color: white; font-weight: bold; }
        #btn_confirm { background-color: #007bff; } #btn_confirm:hover { background-color: #0056b3; }
        #btn_cancel { background-color: #6c757d; } #btn_cancel:hover { background-color: #5a6268; }
    </style>
    
    <script type="text/javascript" src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
    <script src="turf.min.js"></script>
</head>
<body>
    <div id="map_container"></div>

    <div id="save_modal">
        <h4 id="modal_title">åŒºåŸŸä¿å­˜</h4>
        
        <div id="color_filter_box">
            <span class="input-label">ä¿ç•™é¢œè‰²:</span>
            <select id="color_selector">
                <option value="yellow" selected>ğŸŸ¡ æ–°æ‹“å±•åŒº (é»„è‰²)</option>
                <option value="purple">ğŸŸ£ å•ä¾§è¦†ç›– (ç´«è‰²)</option>
                <option value="pink">ğŸŒ¸ é‡å æ ¸å¿ƒ (æ·¡çº¢)</option>
                <option value="all">ğŸ’  æ‰€æœ‰åŒºåŸŸ</option>
            </select>
        </div>

        <span class="input-label">å½’å±å±‚çº§:</span>
        <select id="type_selector">
            <option value="District">1çº§ - åŒºé•‡ (District)</option>
            <option value="Street">2çº§ - è¡—é“ (Street)</option>
            <option value="Community">3çº§ - å°åŒº/å»ºç­‘ (Community)</option>
            <option value="Reconstruct">âš¡ é‡æ„å›¾å— (Reconstruct)</option>
        </select>

        <span class="input-label">åŒºåŸŸåç§°:</span>
        <input type="text" id="poly_name_input" placeholder="è¯·è¾“å…¥åç§°">

        <div class="btn-group">
            <button id="btn_cancel" onclick="closeModal()">ä¸¢å¼ƒ</button>
            <button id="btn_confirm" onclick="confirmSave()">ä¿å­˜</button>
        </div>
    </div>
</body>
</html>

<script>
    // ================= 1. å…¨å±€é…ç½® =================
    window.onerror = function(msg, url, line) { console.log("UE_ERROR:JS_Error:" + msg + " Line:" + line); };
    var map = new BMapGL.Map("map_container");
    map.centerAndZoom(new BMapGL.Point(116.404, 39.915), 17);
    map.enableScrollWheelZoom(true);
    map.setTilt(0);

    var appState = {
        mode: 'browse', polygons: [], 
        drawPath: [], isDrawing: false, tempPolyline: null,
        canSnapClose: false, snapHintCircle: null,
        analysisOverlays: [], tempResultData: [],
        isSaving: false 
    };
    var ID_COUNTER = 1;
    var DEFAULT_NAME_IDX = 1; 

    // ================= 2. äº¤äº’é€»è¾‘ =================
    window.setMode = function(mode) {
        appState.mode = mode;
        closeModal(); clearAnalysis(); clearTemp();
        if(mode === 'browse') map.enableDragging();
        else map.disableDragging();
    };

    map.addEventListener('mousedown', function(e) {
        if(appState.mode === 'browse') return; if(e.target.closest('#save_modal')) return;
        appState.isDrawing = true; appState.drawPath = [e.latlng]; appState.canSnapClose = false;
    });
    map.addEventListener('mousemove', function(e) {
        if(!appState.isDrawing || appState.mode === 'browse') return;
        var currentPt = e.latlng; appState.drawPath.push(currentPt);
        if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline);
        appState.tempPolyline = new BMapGL.Polyline(appState.drawPath.map(p=>new BMapGL.Point(p.lng, p.lat)), {strokeColor:"blue", strokeWeight:2});
        map.addOverlay(appState.tempPolyline);
        checkSnapProximity(currentPt);
    });
    map.addEventListener('mouseup', function(e) {
        if(!appState.isDrawing || appState.mode === 'browse') return;
        appState.isDrawing = false;
        if(appState.drawPath.length < 3) { clearTemp(); return; }
        if(appState.canSnapClose) appState.drawPath.push(appState.drawPath[0]); else appState.drawPath.push(appState.drawPath[0]);
        var coords = appState.drawPath.map(p => [p.lng, p.lat]);
        var rawGeo = turf.polygon([coords]);
        var simpleGeo = turf.simplify(rawGeo, {tolerance: 0.00001, highQuality: false});
        if(appState.mode === 'edit') prepareSingleSave(simpleGeo); else if(appState.mode === 'reconstruct') executeAnalysis(simpleGeo);
        clearTemp();
    });
    function checkSnapProximity(currentPt) {
        if(appState.drawPath.length < 10) return;
        var startPt = appState.drawPath[0];
        var pixStart = map.pointToPixel(new BMapGL.Point(startPt.lng, startPt.lat));
        var pixCurrent = map.pointToPixel(new BMapGL.Point(currentPt.lng, currentPt.lat));
        var dist = Math.sqrt(Math.pow(pixStart.x - pixCurrent.x, 2) + Math.pow(pixStart.y - pixCurrent.y, 2));
        if(dist < 20) {
            appState.canSnapClose = true;
            if(!appState.snapHintCircle) {
                appState.snapHintCircle = new BMapGL.Circle(new BMapGL.Point(startPt.lng, startPt.lat), 5, {strokeColor: "white", strokeWeight: 2, fillColor: "#FFD700", fillOpacity: 0.9});
                map.addOverlay(appState.snapHintCircle);
            }
        } else {
            appState.canSnapClose = false;
            if(appState.snapHintCircle) { map.removeOverlay(appState.snapHintCircle); appState.snapHintCircle = null; }
        }
    }

    function executeAnalysis(polyX) {
        clearAnalysis(); appState.tempResultData = [];
        if(appState.polygons.length === 0) { prepareSingleSave(polyX); return; }
        try {
            var featX = turf.feature(polyX.geometry);
            var existFeats = appState.polygons.map(p => turf.feature(p.geoJson.geometry));
            var unionC = null;
            for(let i=0; i<existFeats.length; i++) {
                for(let j=i+1; j<existFeats.length; j++) {
                    var inter = turf.intersect(existFeats[i], existFeats[j]);
                    if(inter) unionC = unionC ? turf.union(unionC, inter) : inter;
                }
            }
            var interXC = unionC ? turf.intersect(featX, unionC) : null;
            if(interXC) cacheResult(interXC, "#FFC0CB", 0.6, "é‡å æ ¸å¿ƒ", false, 'pink');
            var unionAll = existFeats[0];
            for(let i=1; i<existFeats.length; i++) unionAll = turf.union(unionAll, existFeats[i]);
            var interTotal = turf.intersect(featX, unionAll);
            var interPurple = (interTotal && interXC) ? turf.difference(interTotal, interXC) : interTotal;
            if(interPurple) cacheResult(interPurple, "#800080", 0.4, "å•ä¾§è¦†ç›–", false, 'purple');
            if(interTotal) {
                var lines = turf.polygonToLine(interTotal);
                cacheResult(lines, "#FFA500", 1.0, "äº¤ç•Œçº¿", true, 'orange');
            }
            var resE = turf.difference(featX, unionAll);
            if(resE) cacheResult(resE, "yellow", 0.3, "æ–°æ‹“å±•åŒº", false, 'yellow');
            showModal(true); 
        } catch(e) { console.log("UE_ERROR:" + e.message); alert("åˆ†æé”™è¯¯"); }
    }
    function cacheResult(geo, col, op, name, line, type) {
        var geoms = flattenGeo(geo);
        geoms.forEach(path => {
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4}) 
                          : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1});
            map.addOverlay(ov);
            appState.analysisOverlays.push(ov);
        });
        // ç¡®ä¿ type ä¸ä¸ºç©ºï¼Œé˜²æ­¢ç­›é€‰bug
        if(!type) type = "Reconstruct"; 
        appState.tempResultData.push({geoJson:geo, color:col, opacity:op, rawType:type, isLine:line});
    }

    // ================= 3. å¼¹çª—ä¸ä¿å­˜ =================
    
    function prepareSingleSave(geoJson) {
        appState.tempResultData = [];
        cacheResult(geoJson, 'blue', 0.5, 'Temp', false, 'single');
        showModal(false);
    }

    function showModal(isMulti) {
        var modal = document.getElementById('save_modal');
        var colorBox = document.getElementById('color_filter_box');
        if(isMulti) { 
            colorBox.style.display = 'block'; 
            document.getElementById('color_selector').value = 'yellow';
        } else { 
            colorBox.style.display = 'none'; 
        }
        document.getElementById('poly_name_input').value = "æˆ‘çš„åŒºåŸŸ" + DEFAULT_NAME_IDX;
        
        // é»˜è®¤ç±»å‹
        document.getElementById('type_selector').value = 'District'; // é»˜è®¤ä¸ºåŒºé•‡
        
        modal.style.display = 'block';
    }

    function closeModal() {
        document.getElementById('save_modal').style.display = 'none';
        clearAnalysis();
    }

    window.confirmSave = function() {
        if(appState.isSaving) return;
        var nameInput = document.getElementById('poly_name_input').value || "æœªå‘½å";
        if(nameInput === "æˆ‘çš„åŒºåŸŸ" + DEFAULT_NAME_IDX) { DEFAULT_NAME_IDX++; }
        
        var selectedType = document.getElementById('type_selector').value; 
        
        var colorSel = document.getElementById('color_selector');
        var choice = (document.getElementById('color_filter_box').style.display === 'none') ? 'single' : colorSel.value;

        var toSave = [];
        if(choice === 'all' || choice === 'single') toSave = appState.tempResultData;
        else toSave = appState.tempResultData.filter(i => i.rawType === choice);

        if(toSave.length === 0) { alert("æ— æ•°æ®"); return; }

        document.getElementById('save_modal').style.display = 'none';
        appState.isSaving = true;
        
        // å¦‚æœæ˜¯å•é€‰æ¨¡å¼ï¼Œå¼ºåˆ¶ä½¿ç”¨ä¸‹æ‹‰æ¡†çš„ç±»å‹
        // å¦‚æœæ˜¯å¤šé€‰æ¨¡å¼(reconstruct)ï¼Œä¸”ç”¨æˆ·é€‰çš„æ˜¯é¢œè‰²ç­›é€‰ï¼Œæˆ‘ä»¬è¦æŠŠè¿™ä¸ªâ€œé‡æ„â€å±æ€§ä¼ ä¸‹å»å—ï¼Ÿ
        // éœ€æ±‚è¯´ï¼šé‡æ„å›¾å—å•ç‹¬ä¸€åˆ—ã€‚æ‰€ä»¥å¦‚æœæ˜¯åœ¨é‡æ„æ¨¡å¼ä¸‹ï¼Œæˆ‘ä»¬å¼ºåˆ¶è¦†ç›– Type ä¸º Reconstructï¼Œ
        // æˆ–è€…ç”¨æˆ·æ‰‹åŠ¨é€‰ Reconstructã€‚ä¸ºäº†æ–¹ä¾¿ï¼Œæˆ‘ä»¬ä¼˜å…ˆä¿¡ä»»ä¸‹æ‹‰æ¡†ã€‚
        processSaveQueue(toSave, nameInput, selectedType, 0);
    };

    function processSaveQueue(list, baseName, typeStr, index) {
        if(index >= list.length) {
            appState.tempResultData = [];
            appState.isSaving = false;
            return;
        }
        var item = list[index];
        var finalName = (list.length > 1) ? (baseName + "_" + item.rawType + "_" + (index+1)) : baseName;
        addPermanent(item.geoJson, item.color, item.opacity, item.isLine, finalName, typeStr);
        setTimeout(function() { processSaveQueue(list, baseName, typeStr, index + 1); }, 300);
    }

    // ================= 4. æ•°æ®ä¸é€šä¿¡ =================
    
    function addPermanent(geo, col, op, line, name, typeStr) {
        var id = 'poly_' + (ID_COUNTER++);
        geo.properties = { id: id, name: name, svCol: col, svOp: op, svLine: line, customType: typeStr };
        var geoms = flattenGeo(geo);
        geoms.forEach(path => {
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4, strokeOpacity:op}) 
                          : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1});
            ov.addEventListener('click', function(){ window.focusPoly(id); });
            ov.customData = { id: id, type: typeStr }; 
            map.addOverlay(ov);
            appState.polygons.push({overlay:ov, geoJson:geo});
        });
        var randomTag = new Date().getTime(); 
        console.log("UE_ADD:" + id + "|" + name + "|" + typeStr + "|" + randomTag);
    }

    // ================= 5. äº¤äº’æ¥å£ =================
    window.focusPoly = function(id) {
        var targets = appState.polygons.filter(p => p.geoJson.properties.id === id);
        if(targets.length > 0) {
            var allPoints = [];
            targets.forEach(t => {
                var ovs = Array.isArray(t.overlay) ? t.overlay : [t.overlay];
                ovs.forEach(o => {
                    var path = o.getPath(); if(path) allPoints = allPoints.concat(path);
                    var oldColor = o.getStrokeColor();
                    o.setStrokeColor("red"); o.setStrokeWeight(4);
                    setTimeout(() => { o.setStrokeColor(oldColor); o.setStrokeWeight(1); }, 1000);
                });
            });
            if(allPoints.length > 0) {
                map.setViewport(allPoints, { margins: [60, 60, 60, 300], enableAnimation: true, zoomFactor: 0 });
            }
        } else { console.log("UE_ERROR: Not found " + id); }
    };

    window.filterPolys = function(filterType) {
        appState.polygons.forEach(p => {
            var pType = p.geoJson.properties.customType || "Normal"; 
            var ovs = Array.isArray(p.overlay) ? p.overlay : [p.overlay];
            var shouldShow = (filterType === 'all') || (pType === filterType);
            ovs.forEach(o => { if(shouldShow) o.show(); else o.hide(); });
        });
    };

    function flattenGeo(geo) {
        var coords = []; if(!geo || !geo.geometry) return [];
        var type = geo.geometry.type;
        if(type === 'MultiPolygon') coords = geo.geometry.coordinates.map(c=>c[0]);
        else if(type === 'Polygon') coords = [geo.geometry.coordinates[0]];
        else if(type === 'LineString') coords = [geo.geometry.coordinates];
        else if(type === 'MultiLineString') coords = geo.geometry.coordinates;
        var res = []; coords.forEach(c => { if(c) res.push(c.map(p => new BMapGL.Point(p[0], p[1]))); });
        return res;
    }
    function clearTemp() { appState.drawPath=[]; if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline); if(appState.snapHintCircle) { map.removeOverlay(appState.snapHintCircle); appState.snapHintCircle = null; } appState.canSnapClose = false;}
    function clearAnalysis() { appState.analysisOverlays.forEach(o=>map.removeOverlay(o)); appState.analysisOverlays=[]; appState.tempResultData=[]; }
    window.exportMap = function(fname) { var data = appState.polygons.map(p => p.geoJson); console.log("UE_SAVE:" + fname + "|" + JSON.stringify(data)); };
    window.importMap = function(json) { map.clearOverlays(); appState.polygons=[]; var list = JSON.parse(json); list.forEach((g, i) => { var p = g.properties; setTimeout(() => addPermanent(g, p.svCol, p.svOp, p.svLine, p.name, p.customType), i * 50); }); };
    window.deletePoly = function(id) { var targets = appState.polygons.filter(p => p.geoJson.properties.id === id); if(targets.length > 0) { targets.forEach(t => { var ovs = Array.isArray(t.overlay) ? t.overlay : [t.overlay]; ovs.forEach(o => map.removeOverlay(o)); }); appState.polygons = appState.polygons.filter(p => p.geoJson.properties.id !== id); console.log("UE_LOG: Deleted poly " + id); } };
</script>