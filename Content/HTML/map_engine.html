<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <style>
        /* ================= 1. åŸºç¡€æ ·å¼ ================= */
        html, body, #map_container { width: 100%; height: 100%; overflow: hidden; margin: 0; font-family: "å¾®è½¯é›…é»‘"; }
        .anchorBL, .BMap_cpyCtrl { display: none; } 

        /* ================= 2. å¼¹çª—æ ·å¼ ================= */
        #mode_select_modal {
            display: none; position: fixed; 
            left: 50%; top: 50%; transform: translate(-50%, -50%);
            z-index: 10000;
            background: white; width: 320px; padding: 25px;
            border-radius: 16px; box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            text-align: center;
        }
        #mode_select_modal h3 { margin: 0 0 20px 0; color: #333; }
        .mode-btn {
            display: block; width: 100%; padding: 15px; margin-bottom: 15px;
            border: 2px solid #eee; border-radius: 10px; background: #f9f9f9;
            cursor: pointer; transition: 0.2s; text-align: left;
        }
        .mode-btn:hover { border-color: #007bff; background: #eef7ff; }
        .mode-btn strong { display: block; font-size: 16px; margin-bottom: 4px; color: #333; }
        .mode-btn span { font-size: 12px; color: #666; }
        .color-preview-box { display: flex; justify-content: space-between; margin-bottom: 20px; }
        .color-opt { width: 40px; height: 40px; border-radius: 50%; border: 3px solid transparent; cursor: pointer; transition: 0.2s; }
        .color-opt.active { border-color: #333; transform: scale(1.1); }

        /* ================= 3. ä¿å­˜å¼¹çª—æ ·å¼ ================= */
        #save_modal {
            display: none; position: fixed; 
            left: 50%; bottom: 80px; transform: translateX(-50%);
            z-index: 9999;
            background: rgba(255, 255, 255, 0.98); backdrop-filter: blur(12px);
            width: 280px; padding: 20px;
            border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            border: 1px solid #eee;
            animation: popUp 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }
        @keyframes popUp { from { bottom: -200px; opacity: 0; } to { bottom: 80px; opacity: 1; } }
        #save_modal h4 { margin: 0 0 10px 0; font-size: 16px; color: #333; text-align: center; }
        .input-label { font-size: 12px; color: #666; margin-bottom: 4px; display: block; }
        select, input { width: 100%; padding: 8px; margin-bottom: 12px; box-sizing: border-box; border: 1px solid #ddd; border-radius: 6px; outline: none; font-size: 14px; }
        #parent_container { display: none; background: #f9f9f9; padding: 8px; border-radius: 6px; margin-bottom: 10px; border: 1px dashed #ccc;}
        .btn-group { display: flex; justify-content: space-between; gap: 10px; margin-top: 10px;}
        .btn-group button { flex: 1; padding: 8px; cursor: pointer; border: none; border-radius: 6px; color: white; font-weight: bold; }
        #btn_confirm { background-color: #007bff; } #btn_confirm:hover { background-color: #0056b3; }
        #btn_cancel { background-color: #6c757d; } #btn_cancel:hover { background-color: #5a6268; }
        #hint_bar {
            display: none; position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 14px;
            z-index: 9998; pointer-events: none;
        }
    </style>
    <script type="text/javascript" src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
    <script src="turf.min.js"></script>
</head>
<body>
    <div id="map_container"></div>
    <div id="hint_bar">æ“ä½œæç¤º...</div>

    <div id="mode_select_modal">
        <h3>ğŸ› ï¸ é€‰æ‹©ç»˜åˆ¶æ–¹æ¡ˆ</h3>
        <div class="input-label" style="text-align:left; margin-bottom:10px;">é¢„è®¾å¡«å……é¢œè‰²:</div>
        <div class="color-preview-box" id="color_opts">
            <div class="color-opt active" style="background:rgba(0,0,255,0.5)" data-col="blue" onclick="selectPreColor(this)"></div>
            <div class="color-opt" style="background:rgba(255,0,0,0.5)" data-col="red" onclick="selectPreColor(this)"></div>
            <div class="color-opt" style="background:rgba(0,255,0,0.5)" data-col="green" onclick="selectPreColor(this)"></div>
            <div class="color-opt" style="background:rgba(255,165,0,0.5)" data-col="orange" onclick="selectPreColor(this)"></div>
            <div class="color-opt" style="background:rgba(128,0,128,0.5)" data-col="purple" onclick="selectPreColor(this)"></div>
        </div>
        <div class="mode-btn" onclick="startDraw('Freehand')">
            <strong>æ–¹æ¡ˆä¸€ï¼šæ‰‹ç»˜æ‹–æ‹½</strong>
            <span>æŒ‰ä½å·¦é”®æ‹–åŠ¨ï¼Œæ¾å¼€å³é—­åˆã€‚<br>(é€‚åˆå°å‹ã€ä¸è§„åˆ™åŒºåŸŸ)</span>
        </div>
        <div class="mode-btn" onclick="startDraw('Polyline')">
            <strong>æ–¹æ¡ˆäºŒï¼šç‚¹å¯¹ç‚¹æŠ˜çº¿</strong>
            <span>ç‚¹å‡»å®šç‚¹ï¼ŒåŒå‡»é—­åˆã€‚<br>(é€‚åˆå¤§å‹ã€é•¿è·ç¦»åŒºåŸŸ)</span>
        </div>
        <div style="margin-top:15px; font-size:12px; color:#999; cursor:pointer;" onclick="setMode('browse')">å–æ¶ˆè¿”å›</div>
    </div>

    <div id="save_modal">
        <h4 id="modal_title">åŒºåŸŸä¿å­˜</h4>
        <div id="color_filter_box">
            <span class="input-label">åˆ†æç»“æœ (æ™ºèƒ½ç­›é€‰):</span>
            <select id="color_selector">
                <option value="yellow">ğŸŸ¡ æ–°æ‹“å±•åŒº (é»„è‰²)</option>
                <option value="purple">ğŸŸ£ å•ä¾§è¦†ç›– (ç´«è‰²)</option>
                <option value="pink">ğŸŒ¸ é‡å æ ¸å¿ƒ (æ·¡çº¢)</option>
                <option value="all">ğŸ’  æ‰€æœ‰åŒºåŸŸ</option>
            </select>
        </div>
        <span class="input-label">å½’å±å±‚çº§:</span>
        <select id="type_selector" onchange="onTypeChanged()">
            <option value="District">1çº§ - åŒºé•‡ (District)</option>
            <option value="Street" selected>2çº§ - è¡—é“ (Street)</option>
            <option value="Community">3çº§ - å»ºç­‘/å°åŒº (Community)</option>
            <option value="Reconstruct">âš¡ é‡æ„å›¾å— (Reconstruct)</option>
        </select>
        <div id="parent_container">
            <span class="input-label" id="parent_label">é™„ç€åˆ°:</span>
            <select id="parent_selector">
                <option value="">è¯·é€‰æ‹©...</option>
            </select>
        </div>
        <span class="input-label">åŒºåŸŸåç§°:</span>
        <input type="text" id="poly_name_input" placeholder="è¯·è¾“å…¥åç§°">
        <div class="btn-group">
            <button id="btn_cancel" onclick="closeModal()">ä¸¢å¼ƒ</button>
            <button id="btn_confirm" onclick="confirmSave()">ä¿å­˜</button>
        </div>
    </div>
</body>
</html>
<script>
    window.onerror = function(msg, url, line) { console.log("UE_ERROR:JS_Error:" + msg + " Line:" + line); };
    document.oncontextmenu = function() { return false; }; 

    var map = new BMapGL.Map("map_container");
    map.centerAndZoom(new BMapGL.Point(116.404, 39.915), 17);
    map.enableScrollWheelZoom(true);
    map.setTilt(0);

    const MOVE_SPEED = 15; 

    var appState = {
        mode: 'browse', 
        drawMethod: 'None',
        preColor: 'blue',
        polygons: [], 
        drawPath: [], 
        tempPolyline: null,
        tempMouseLine: null,
        canSnapClose: false, snapHintCircle: null,
        analysisOverlays: [], tempResultData: [],
        isSaving: false,
        isDrawing: false 
    };
    var ID_COUNTER = 1;
    var DEFAULT_NAME_IDX = 1; 

    // ================= 1. æ¨¡å¼ä¸çŠ¶æ€æ§åˆ¶ =================
    window.setMode = function(mode) {
        appState.mode = mode;
        closeModal(); clearAnalysis(); clearTemp();
        document.getElementById('mode_select_modal').style.display = 'none';
        hideHint();

        if(mode === 'browse') {
            map.enableDragging();
            map.setDefaultCursor("default");
        }
        else if (mode === 'edit') {
            map.disableDragging();
            document.getElementById('mode_select_modal').style.display = 'block';
        }
        else if (mode === 'reconstruct') {
            map.disableDragging();
            appState.drawMethod = 'Freehand';
            appState.preColor = 'blue';
            showHint("WASDç§»åŠ¨ | å·¦é”®æ‰‹ç»˜ | é‡æ„æ¨¡å¼");
        }
    };

    window.selectPreColor = function(el) {
        document.querySelectorAll('.color-opt').forEach(d => d.classList.remove('active'));
        el.classList.add('active');
        appState.preColor = el.getAttribute('data-col');
    };

    window.startDraw = function(method) {
        appState.drawMethod = method;
        document.getElementById('mode_select_modal').style.display = 'none';
        
        if (method === 'Freehand') {
            showHint("ã€WASDã€‘ç§»åŠ¨åœ°å›¾ | ã€å·¦é”®æ‹–æ‹½ã€‘ç»˜åˆ¶åŒºåŸŸ");
            map.setDefaultCursor("crosshair");
        } else {
            showHint("ã€WASDã€‘ç§»åŠ¨åœ°å›¾ | ã€å·¦é”®ç‚¹å‡»ã€‘å®šç‚¹ | ã€åŒå‡»ã€‘é—­åˆ");
            map.setDefaultCursor("crosshair");
        }
    };

    // ================= 2. WASD ç§»åŠ¨é€»è¾‘ =================
    var keyState = { w: false, a: false, s: false, d: false };
    var isPanningLoopActive = false;

    document.addEventListener('keydown', function(e) {
        if(e.target.tagName === 'INPUT') return;
        var k = e.key.toLowerCase();
        if(['w','a','s','d'].includes(k)) { 
            keyState[k] = true; 
            if(!isPanningLoopActive) { isPanningLoopActive=true; panMapLoop(); } 
        }
    });
    
    document.addEventListener('keyup', function(e) {
        var k = e.key.toLowerCase(); 
        if(['w','a','s','d'].includes(k)) keyState[k] = false;
    });

    function panMapLoop() {
        if (!keyState.w && !keyState.a && !keyState.s && !keyState.d) { 
            isPanningLoopActive = false; 
            return; 
        }
        var centerPt = map.getCenter();
        var centerPx = map.pointToPixel(centerPt);
        var dx = 0; var dy = 0;
        if (keyState.w) dy -= MOVE_SPEED; 
        if (keyState.s) dy += MOVE_SPEED; 
        if (keyState.a) dx -= MOVE_SPEED; 
        if (keyState.d) dx += MOVE_SPEED; 
        var newCenterPx = new BMapGL.Pixel(centerPx.x + dx, centerPx.y + dy);
        var newCenterPt = map.pixelToPoint(newCenterPx);
        map.setCenter(newCenterPt, { noAnimation: true });
        requestAnimationFrame(panMapLoop);
    }

    // ================= 3. ç»Ÿä¸€äº¤äº’è·¯ç”± =================
    var container = document.getElementById('map_container');

    container.addEventListener('mousedown', function(e) {
        if(appState.mode === 'browse') return; 
        if(e.target.closest('#save_modal') || e.target.closest('#mode_select_modal')) return;
        if(e.button !== 0) return; 

        if (appState.drawMethod === 'Freehand') handleFreehandDown(e);
        else if (appState.drawMethod === 'Polyline') handlePolylineDown(e);
    });

    container.addEventListener('mousemove', function(e) {
        if(appState.mode === 'browse') return;
        
        if (appState.drawMethod === 'Freehand') handleFreehandMove(e);
        else if (appState.drawMethod === 'Polyline') handlePolylineMove(e);
    });

    container.addEventListener('mouseup', function(e) {
        if(appState.mode === 'browse') return;
        if(e.button !== 0) return;

        if (appState.drawMethod === 'Freehand') handleFreehandUp(e);
    });
    
    container.addEventListener('dblclick', function(e) {
        if (appState.mode === 'browse') return;
        if (appState.drawMethod === 'Polyline') finishPolyline();
    });

    // ================= 4. æ‰‹ç»˜é€»è¾‘ =================
    function handleFreehandDown(e) {
        if (!appState.isDrawing) {
            appState.isDrawing = true;
            var pt = map.pixelToPoint(new BMapGL.Pixel(e.clientX, e.clientY));
            appState.drawPath = [pt];
            appState.canSnapClose = false;
        }
    }
    function handleFreehandMove(e) {
        if (appState.isDrawing) {
            var currentPt = map.pixelToPoint(new BMapGL.Pixel(e.clientX, e.clientY));
            appState.drawPath.push(currentPt);
            redrawTempPolyline();
            checkSnapProximity(currentPt);
        }
    }
    function handleFreehandUp(e) {
        if (appState.isDrawing) {
            appState.isDrawing = false;
            finishDraw();
        }
    }

    // ================= 5. æŠ˜çº¿é€»è¾‘ =================
    function handlePolylineDown(e) {
        var pt = map.pixelToPoint(new BMapGL.Pixel(e.clientX, e.clientY));
        appState.drawPath.push(pt);
        redrawTempPolyline(); 
        appState.isDrawing = true; 
    }
    function handlePolylineMove(e) {
        if (appState.isDrawing && appState.drawPath.length > 0) {
            var lastPt = appState.drawPath[appState.drawPath.length - 1];
            var mousePt = map.pixelToPoint(new BMapGL.Pixel(e.clientX, e.clientY));
            if (appState.tempMouseLine) map.removeOverlay(appState.tempMouseLine);
            appState.tempMouseLine = new BMapGL.Polyline([lastPt, mousePt], {
                strokeColor: appState.preColor, strokeWeight: 2, strokeStyle: 'dashed'
            });
            map.addOverlay(appState.tempMouseLine);
        }
    }
    function finishPolyline() {
        if (appState.drawPath.length < 3) return; 
        if (appState.tempMouseLine) map.removeOverlay(appState.tempMouseLine);
        finishDraw();
    }

    // ================= 6. ç»˜å›¾è¾…åŠ© =================
    function redrawTempPolyline() {
        if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline);
        appState.tempPolyline = new BMapGL.Polyline(appState.drawPath, {
            strokeColor: appState.preColor, strokeWeight: 2
        });
        map.addOverlay(appState.tempPolyline);
    }

    function checkSnapProximity(currentPt) {
        if(appState.drawPath.length < 10) return;
        var startPt = appState.drawPath[0];
        var pixStart = map.pointToPixel(new BMapGL.Point(startPt.lng, startPt.lat));
        var pixCurrent = map.pointToPixel(new BMapGL.Point(currentPt.lng, currentPt.lat));
        var dist = Math.sqrt(Math.pow(pixStart.x - pixCurrent.x, 2) + Math.pow(pixStart.y - pixCurrent.y, 2));
        if(dist < 20) {
            appState.canSnapClose = true;
            if(!appState.snapHintCircle) {
                appState.snapHintCircle = new BMapGL.Circle(new BMapGL.Point(startPt.lng, startPt.lat), 5, {strokeColor: "white", strokeWeight: 2, fillColor: "#FFD700", fillOpacity: 0.9});
                map.addOverlay(appState.snapHintCircle);
            }
        } else {
            appState.canSnapClose = false;
            if(appState.snapHintCircle) { map.removeOverlay(appState.snapHintCircle); appState.snapHintCircle = null; }
        }
    }

    function finishDraw() {
        if(appState.drawPath.length < 3) { clearTemp(); return; }
        if(appState.canSnapClose) appState.drawPath.push(appState.drawPath[0]); 
        else appState.drawPath.push(appState.drawPath[0]);

        var coords = appState.drawPath.map(p => [p.lng, p.lat]);
        var rawGeo = turf.polygon([coords]);
        var simpleGeo = turf.simplify(rawGeo, {tolerance: 0.00001, highQuality: false});

        if(appState.mode === 'edit') prepareSingleSave(simpleGeo); 
        else if(appState.mode === 'reconstruct') executeAnalysis(simpleGeo);
        
        clearTemp();
        hideHint();
    }

    // ================= 7. ä¸šåŠ¡é€»è¾‘ =================
    function executeAnalysis(polyX) {
        clearAnalysis(); appState.tempResultData = [];
        if(appState.polygons.length === 0) { prepareSingleSave(polyX); return; }
        try {
            var featX = turf.feature(polyX.geometry);
            var existFeats = appState.polygons.map(p => turf.feature(p.geoJson.geometry));
            var unionC = null;
            for(let i=0; i<existFeats.length; i++) {
                for(let j=i+1; j<existFeats.length; j++) {
                    var inter = turf.intersect(existFeats[i], existFeats[j]);
                    if(inter) unionC = unionC ? turf.union(unionC, inter) : inter;
                }
            }
            var interXC = unionC ? turf.intersect(featX, unionC) : null;
            if(interXC) cacheResult(interXC, "#FFC0CB", 0.6, "é‡å æ ¸å¿ƒ", false, 'pink');
            var unionAll = existFeats[0];
            for(let i=1; i<existFeats.length; i++) unionAll = turf.union(unionAll, existFeats[i]);
            var interTotal = turf.intersect(featX, unionAll);
            var interPurple = (interTotal && interXC) ? turf.difference(interTotal, interXC) : interTotal;
            if(interPurple) cacheResult(interPurple, "#800080", 0.4, "å•ä¾§è¦†ç›–", false, 'purple');
            
            // è®¡ç®—é»„è‰²åŒºåŸŸ (æ–°æ‹“å±•)
            var resE = turf.difference(featX, unionAll);
            if(resE) cacheResult(resE, "yellow", 0.3, "æ–°æ‹“å±•åŒº", false, 'yellow');
            
            showModal(true); 
        } catch(e) { console.log("UE_ERROR:" + e.message); alert("åˆ†æé”™è¯¯"); }
    }
    
    function cacheResult(geo, col, op, name, line, type) {
        var geoms = flattenGeo(geo);
        geoms.forEach(path => {
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4}) 
                          : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1});
            map.addOverlay(ov);
            appState.analysisOverlays.push(ov);
        });
        if(!type) type = "Reconstruct"; 
        appState.tempResultData.push({geoJson:geo, color:col, opacity:op, rawType:type, isLine:line});
    }

    function prepareSingleSave(geoJson) {
        appState.tempResultData = [];
        cacheResult(geoJson, appState.preColor, 0.5, 'Temp', false, 'single');
        showModal(false);
    }

    // --- æ™ºèƒ½å¼¹çª—ï¼šæ ¹æ®æ•°æ®å¯ç”¨æ€§åŠ¨æ€æ›´æ–°é€‰é¡¹ ---
    function showModal(isMulti) {
        var modal = document.getElementById('save_modal');
        var colorBox = document.getElementById('color_filter_box');
        var colorSel = document.getElementById('color_selector');

        if(isMulti) { 
            colorBox.style.display = 'block'; 
            
            // 1. æ£€æŸ¥æ•°æ®
            var hasYellow = appState.tempResultData.some(i => i.rawType === 'yellow');
            var hasPurple = appState.tempResultData.some(i => i.rawType === 'purple');
            var hasPink   = appState.tempResultData.some(i => i.rawType === 'pink');

            // 2. æ›´æ–°é€‰é¡¹ (è¾…åŠ©å‡½æ•°)
            updateOption(colorSel, 'yellow', hasYellow, "ğŸŸ¡ æ–°æ‹“å±•åŒº (é»„è‰²)");
            updateOption(colorSel, 'purple', hasPurple, "ğŸŸ£ å•ä¾§è¦†ç›– (ç´«è‰²)");
            updateOption(colorSel, 'pink',   hasPink,   "ğŸŒ¸ é‡å æ ¸å¿ƒ (æ·¡çº¢)");
            
            // 3. è‡ªåŠ¨é€‰ä¸­ä¸€ä¸ªæœ‰æ•°æ®çš„
            if (hasYellow) colorSel.value = 'yellow';
            else if (hasPurple) colorSel.value = 'purple';
            else if (hasPink) colorSel.value = 'pink';
            else colorSel.value = 'all';

        } else { 
            colorBox.style.display = 'none'; 
        }
        
        document.getElementById('poly_name_input').value = "æˆ‘çš„åŒºåŸŸ" + DEFAULT_NAME_IDX;
        document.getElementById('type_selector').value = 'Street'; 
        onTypeChanged();
        modal.style.display = 'block';
    }

    // æ›´æ–°ä¸‹æ‹‰æ¡†é€‰é¡¹çŠ¶æ€
    function updateOption(sel, val, hasData, label) {
        for (var i=0; i<sel.options.length; i++) {
            if (sel.options[i].value === val) {
                if (!hasData) {
                    sel.options[i].text = label + " [æ— æ•°æ®]";
                    sel.options[i].disabled = true;
                } else {
                    sel.options[i].text = label;
                    sel.options[i].disabled = false;
                }
            }
        }
    }

    function closeModal() { document.getElementById('save_modal').style.display = 'none'; clearAnalysis(); }
    
    window.onTypeChanged = function() {
        var type = document.getElementById('type_selector').value;
        var parentContainer = document.getElementById('parent_container');
        var parentSelector = document.getElementById('parent_selector');
        var parentLabel = document.getElementById('parent_label');
        parentSelector.innerHTML = '<option value="">è¯·é€‰æ‹©...</option>';
        var targetParentType = "";
        if (type === 'District') { parentContainer.style.display = 'none'; return; } 
        else if (type === 'Street') { targetParentType = 'District'; parentLabel.innerText = "éš¶å±äºå“ªä¸ªåŒºé•‡:"; }
        else if (type === 'Community') { targetParentType = 'Street'; parentLabel.innerText = "éš¶å±äºå“ªä¸ªè¡—é“:"; }
        else { parentContainer.style.display = 'none'; return; }
        parentContainer.style.display = 'block';
        var parents = appState.polygons.filter(p => p.geoJson.properties.customType === targetParentType);
        if (parents.length === 0) {
            var opt = document.createElement('option'); opt.text = "âš ï¸ æš‚æ— ä¸Šçº§æ•°æ®"; opt.disabled = true; opt.selected = true; parentSelector.add(opt);
        } else {
            parents.forEach(p => { var opt = document.createElement('option'); opt.value = p.geoJson.properties.id; opt.text = p.geoJson.properties.name; parentSelector.add(opt); });
        }
    };
    window.confirmSave = function() {
        if(appState.isSaving) return;
        var nameInput = document.getElementById('poly_name_input').value || "æœªå‘½å";
        var selectedType = document.getElementById('type_selector').value; 
        var parentId = "";
        if (selectedType === 'Street' || selectedType === 'Community') {
            var pSel = document.getElementById('parent_selector');
            parentId = pSel.value;
            if (!parentId) { alert("è¯·é€‰æ‹©éš¶å±çš„çˆ¶çº§åŒºåŸŸï¼"); return; }
        }
        if(nameInput === "æˆ‘çš„åŒºåŸŸ" + DEFAULT_NAME_IDX) { DEFAULT_NAME_IDX++; }
        var colorSel = document.getElementById('color_selector');
        var choice = (document.getElementById('color_filter_box').style.display === 'none') ? 'single' : colorSel.value;
        var toSave = [];
        if(choice === 'all' || choice === 'single') toSave = appState.tempResultData;
        else toSave = appState.tempResultData.filter(i => i.rawType === choice);
        
        // è¿™é‡Œçš„æ ¡éªŒç°åœ¨æ›´æœ‰æ„ä¹‰äº†ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»é¢„å…ˆç¦ç”¨äº†æ— æ•°æ®çš„é€‰é¡¹
        if(toSave.length === 0) { alert("æ— æ•°æ® (è¯·æ£€æŸ¥æ˜¯å¦é€‰ä¸­äº†æœ‰æ•ˆåŒºåŸŸ)"); return; }

        document.getElementById('save_modal').style.display = 'none';
        appState.isSaving = true;
        processSaveQueue(toSave, nameInput, selectedType, parentId, 0);
    };
    function processSaveQueue(list, baseName, typeStr, pid, index) {
        if(index >= list.length) { appState.tempResultData = []; appState.isSaving = false; return; }
        var item = list[index];
        var finalName = (list.length > 1) ? (baseName + "_" + item.rawType + "_" + (index+1)) : baseName;
        addPermanent(item.geoJson, item.color, item.opacity, item.isLine, finalName, typeStr, pid);
        setTimeout(function() { processSaveQueue(list, baseName, typeStr, pid, index + 1); }, 300);
    }
    
    function addPermanent(geo, col, op, line, name, typeStr, parentId) {
        var id = 'poly_' + (ID_COUNTER++);
        if(!parentId) parentId = "None"; 
        geo.properties = { id: id, name: name, svCol: col, svOp: op, svLine: line, customType: typeStr, pid: parentId };
        var geoms = flattenGeo(geo);
        geoms.forEach(path => {
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4, strokeOpacity:op}) 
                          : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1});
            ov.addEventListener('click', function(){ window.focusPoly(id); });
            ov.customData = { id: id, type: typeStr }; 
            map.addOverlay(ov);
            appState.polygons.push({overlay:ov, geoJson:geo});
        });
        var randomTag = new Date().getTime(); 
        console.log("UE_ADD:" + id + "|" + name + "|" + typeStr + "|" + parentId + "|" + randomTag);
    }

    // ================= 8. è¾…åŠ©å‡½æ•° =================
    function showHint(text) { var bar = document.getElementById('hint_bar'); bar.innerText = text; bar.style.display = 'block'; }
    function hideHint() { document.getElementById('hint_bar').style.display = 'none'; }
    function clearTemp() { appState.drawPath=[]; if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline); if(appState.tempMouseLine) map.removeOverlay(appState.tempMouseLine); if(appState.snapHintCircle) { map.removeOverlay(appState.snapHintCircle); appState.snapHintCircle = null; } appState.canSnapClose = false; appState.isDrawing = false; }
    window.focusPoly = function(id) { var targets = appState.polygons.filter(p => p.geoJson.properties.id === id); if(targets.length > 0) { var allPoints = []; targets.forEach(t => { var ovs = Array.isArray(t.overlay) ? t.overlay : [t.overlay]; ovs.forEach(o => { var path = o.getPath(); if(path) allPoints = allPoints.concat(path); var oldColor = o.getStrokeColor(); o.setStrokeColor("red"); o.setStrokeWeight(4); setTimeout(() => { o.setStrokeColor(oldColor); o.setStrokeWeight(1); }, 1000); }); }); if(allPoints.length > 0) { map.setViewport(allPoints, { margins: [60, 60, 60, 300], enableAnimation: true, zoomFactor: 0 }); } } else { console.log("UE_ERROR: Not found " + id); } };
    window.filterPolys = function(filterType) { appState.polygons.forEach(p => { var pType = p.geoJson.properties.customType || "Normal"; var ovs = Array.isArray(p.overlay) ? p.overlay : [p.overlay]; var shouldShow = (filterType === 'all') || (pType === filterType); ovs.forEach(o => { if(shouldShow) o.show(); else o.hide(); }); }); };
    function flattenGeo(geo) { var coords = []; if(!geo || !geo.geometry) return []; var type = geo.geometry.type; if(type === 'MultiPolygon') coords = geo.geometry.coordinates.map(c=>c[0]); else if(type === 'Polygon') coords = [geo.geometry.coordinates[0]]; else if(type === 'LineString') coords = [geo.geometry.coordinates]; else if(type === 'MultiLineString') coords = geo.geometry.coordinates; var res = []; coords.forEach(c => { if(c) res.push(c.map(p => new BMapGL.Point(p[0], p[1]))); }); return res; }
    function clearAnalysis() { appState.analysisOverlays.forEach(o=>map.removeOverlay(o)); appState.analysisOverlays=[]; appState.tempResultData=[]; }
    window.exportMap = function(fname) { var data = appState.polygons.map(p => p.geoJson); console.log("UE_SAVE:" + fname + "|" + JSON.stringify(data)); };
    window.importMap = function(json) { map.clearOverlays(); appState.polygons=[]; var list = JSON.parse(json); list.forEach((g, i) => { var p = g.properties; setTimeout(() => addPermanent(g, p.svCol, p.svOp, p.svLine, p.name, p.customType, p.pid), i * 50); }); };
    window.deletePoly = function(id) { var targets = appState.polygons.filter(p => p.geoJson.properties.id === id); if(targets.length > 0) { targets.forEach(t => { var ovs = Array.isArray(t.overlay) ? t.overlay : [t.overlay]; ovs.forEach(o => map.removeOverlay(o)); }); appState.polygons = appState.polygons.filter(p => p.geoJson.properties.id !== id); console.log("UE_LOG: Deleted poly " + id); } };
</script>
