<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <style>
        /* ================= 1. åŸºç¡€æ ·å¼ ================= */
        html, body, #map_container { width: 100%; height: 100%; overflow: hidden; margin: 0; font-family: "å¾®è½¯é›…é»‘"; }
        .anchorBL, .BMap_cpyCtrl { display: none; } /* éšè—ç™¾åº¦ç‰ˆæƒ */

        /* ================= 2. è‡ªå®šä¹‰ä¿å­˜å¼¹çª— (å±å¹•æ­£ä¸‹æ–¹) ================= */
        #save_modal {
            display: none; 
            position: fixed; 
            left: 50%; bottom: 80px; transform: translateX(-50%);
            z-index: 9999;
            background: rgba(255, 255, 255, 0.95); 
            backdrop-filter: blur(10px);
            width: 260px; padding: 20px;
            border-radius: 12px; 
            box-shadow: 0 8px 30px rgba(0,0,0,0.3);
            border: 1px solid #eee;
            animation: popUp 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }

        @keyframes popUp { from { bottom: -200px; opacity: 0; } to { bottom: 80px; opacity: 1; } }

        #save_modal h4 { margin: 0 0 15px 0; font-size: 16px; color: #333; text-align: center; }
        #save_modal select { width: 100%; padding: 8px; margin-bottom: 15px; border: 1px solid #ddd; border-radius: 6px; outline: none; }
        #save_modal input { width: 92%; padding: 8px; margin-bottom: 20px; border: 1px solid #ddd; border-radius: 6px; outline: none; }

        .btn-group { display: flex; justify-content: space-between; gap: 10px; }
        .btn-group button { flex: 1; padding: 8px; cursor: pointer; border: none; border-radius: 6px; color: white; font-weight: bold; }
        #btn_confirm { background-color: #007bff; } 
        #btn_confirm:hover { background-color: #0056b3; }
        #btn_cancel { background-color: #6c757d; } 
        #btn_cancel:hover { background-color: #5a6268; }
    </style>
    
    <script type="text/javascript" src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
    <script src="turf.min.js"></script>
</head>
<body>
    <div id="map_container"></div>

    <div id="save_modal">
        <h4 id="modal_title">åˆ†æå®Œæˆ</h4>
        <select id="color_selector">
            <option value="yellow" selected>ğŸŸ¡ ä»…ä¿ç•™é»„è‰² (æ–°æ‹“å±•åŒº)</option>
            <option value="purple">ğŸŸ£ ä»…ä¿ç•™ç´«è‰² (å•ä¾§è¦†ç›–)</option>
            <option value="pink">ğŸŒ¸ ä»…ä¿ç•™æ·¡çº¢ (é‡å æ ¸å¿ƒ)</option>
            <option value="all">ğŸ’  ä¿ç•™æ‰€æœ‰åŒºåŸŸ</option>
        </select>
        <input type="text" id="poly_name_input" placeholder="è¯·è¾“å…¥åŒºåŸŸåç§°" value="æˆ‘çš„åŒºåŸŸ">
        <div class="btn-group">
            <button id="btn_cancel" onclick="closeModal()">ä¸¢å¼ƒ</button>
            <button id="btn_confirm" onclick="confirmSave()">ä¿å­˜</button>
        </div>
    </div>
</body>
</html>
<script>
    // ================= 1. å…¨å±€é…ç½®ä¸çŠ¶æ€ =================
    // æ•è·æ‰€æœ‰JSé”™è¯¯å¹¶æ‰“å°åˆ°æ§åˆ¶å°ï¼Œä¾›UE5 OutputLogæŸ¥çœ‹
    window.onerror = function(msg, url, line) { console.log("UE_ERROR:JS_Error:" + msg + " Line:" + line); };

    var map = new BMapGL.Map("map_container");
    map.centerAndZoom(new BMapGL.Point(116.404, 39.915), 17);
    map.enableScrollWheelZoom(true);
    map.setTilt(60);

    var appState = {
        mode: 'browse', 
        polygons: [],   // æ°¸ä¹…æ•°æ®
        
        // ç»˜å›¾ç›¸å…³
        drawPath: [], 
        isDrawing: false, 
        tempPolyline: null,
        
        // å¸é™„ç›¸å…³
        canSnapClose: false,
        snapHintCircle: null,
        
        // åˆ†æç›¸å…³
        analysisOverlays: [], 
        tempResultData: [] 
    };
    var ID_COUNTER = 1;

    // ================= 2. äº¤äº’é€»è¾‘ (C++ è°ƒç”¨) =================
    window.setMode = function(mode) {
        appState.mode = mode;
        closeModal(); clearAnalysis(); clearTemp();
        if(mode === 'browse') map.enableDragging();
        else map.disableDragging();
    };

    // ================= 3. æ‰‹ç»˜é€»è¾‘ (å«æ™ºèƒ½å¸é™„) =================
    map.addEventListener('mousedown', function(e) {
        if(appState.mode === 'browse') return;
        if(e.target.closest('#save_modal')) return;
        
        appState.isDrawing = true;
        appState.drawPath = [e.latlng];
        appState.canSnapClose = false;
    });

    map.addEventListener('mousemove', function(e) {
        if(!appState.isDrawing || appState.mode === 'browse') return;
        
        var currentPt = e.latlng;
        appState.drawPath.push(currentPt);
        
        // å®æ—¶ç”»çº¿
        if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline);
        appState.tempPolyline = new BMapGL.Polyline(appState.drawPath.map(p=>new BMapGL.Point(p.lng, p.lat)), {strokeColor:"blue", strokeWeight:2});
        map.addOverlay(appState.tempPolyline);

        // æ£€æµ‹å¸é™„
        checkSnapProximity(currentPt);
    });

    map.addEventListener('mouseup', function(e) {
        if(!appState.isDrawing || appState.mode === 'browse') return;
        appState.isDrawing = false;
        
        if(appState.drawPath.length < 3) { clearTemp(); return; }

        // --- å¸é™„åˆ¤å®š ---
        if (appState.canSnapClose) {
            // å¦‚æœå¸é™„æ¿€æ´»ï¼Œå¼ºåˆ¶é—­åˆåˆ°èµ·ç‚¹
            appState.drawPath.push(appState.drawPath[0]);
        } else {
            // æ­£å¸¸é—­åˆ
            appState.drawPath.push(appState.drawPath[0]);
        }

        // æ„å»ºå‡ ä½•ä½“å¹¶å¹³æ»‘
        var coords = appState.drawPath.map(p => [p.lng, p.lat]);
        var rawGeo = turf.polygon([coords]);
        var simpleGeo = turf.simplify(rawGeo, {tolerance: 0.00001, highQuality: false});

        // æ¨¡å¼åˆ†å‘
        if (appState.mode === 'edit') {
            prepareSingleSave(simpleGeo);
        } 
        else if (appState.mode === 'reconstruct') {
            executeAnalysis(simpleGeo);
        }
        
        clearTemp();
    });

    // å¸é™„æ£€æµ‹å‡½æ•°
    function checkSnapProximity(currentPt) {
        if (appState.drawPath.length < 10) return; // ç”»äº†ä¸€æ®µæ‰æ£€æµ‹

        var startPt = appState.drawPath[0];
        var pixStart = map.pointToPixel(new BMapGL.Point(startPt.lng, startPt.lat));
        var pixCurrent = map.pointToPixel(new BMapGL.Point(currentPt.lng, currentPt.lat));
        var dist = Math.sqrt(Math.pow(pixStart.x - pixCurrent.x, 2) + Math.pow(pixStart.y - pixCurrent.y, 2));

        // é˜ˆå€¼ 20px
        if (dist < 20) {
            appState.canSnapClose = true;
            if (!appState.snapHintCircle) {
                appState.snapHintCircle = new BMapGL.Circle(new BMapGL.Point(startPt.lng, startPt.lat), 5, {
                    strokeColor: "white", strokeWeight: 2, fillColor: "#FFD700", fillOpacity: 0.9
                });
                map.addOverlay(appState.snapHintCircle);
            }
        } else {
            appState.canSnapClose = false;
            if (appState.snapHintCircle) {
                map.removeOverlay(appState.snapHintCircle);
                appState.snapHintCircle = null;
            }
        }
    }

    // ================= 4. æ ¸å¿ƒåˆ†æç®—æ³• =================
    function executeAnalysis(polyX) {
        clearAnalysis(); appState.tempResultData = [];
        if(appState.polygons.length === 0) { prepareSingleSave(polyX); return; }

        try {
            var featX = turf.feature(polyX.geometry);
            var existFeats = appState.polygons.map(p => turf.feature(p.geoJson.geometry));

            // A. Union C
            var unionC = null;
            for(let i=0; i<existFeats.length; i++) {
                for(let j=i+1; j<existFeats.length; j++) {
                    var inter = turf.intersect(existFeats[i], existFeats[j]);
                    if(inter) unionC = unionC ? turf.union(unionC, inter) : inter;
                }
            }
            // B. X n C (Pink)
            var interXC = unionC ? turf.intersect(featX, unionC) : null;
            if(interXC) cacheResult(interXC, "#FFC0CB", 0.6, "é‡å æ ¸å¿ƒ", false, 'pink');

            // C. X n All - C (Purple)
            var unionAll = existFeats[0];
            for(let i=1; i<existFeats.length; i++) unionAll = turf.union(unionAll, existFeats[i]);
            var interTotal = turf.intersect(featX, unionAll);
            var interPurple = (interTotal && interXC) ? turf.difference(interTotal, interXC) : interTotal;
            if(interPurple) cacheResult(interPurple, "#800080", 0.4, "å•ä¾§è¦†ç›–", false, 'purple');

            // D. Lines (Orange)
            if(interTotal) {
                var lines = turf.polygonToLine(interTotal);
                cacheResult(lines, "#FFA500", 1.0, "äº¤ç•Œçº¿", true, 'orange');
            }

            // E. X - All (Yellow)
            var resE = turf.difference(featX, unionAll);
            if(resE) cacheResult(resE, "yellow", 0.3, "æ–°æ‹“å±•åŒº", false, 'yellow');

            showModal(true); 

        } catch(e) { console.log("UE_ERROR:" + e.message); alert("åˆ†æé”™è¯¯"); }
    }

    // ================= 5. å¼¹çª—ä¸ä¿å­˜é€»è¾‘ =================
    function prepareSingleSave(geoJson) {
        appState.tempResultData = [{
            geoJson: geoJson, color: 'blue', opacity: 0.5, rawType: 'single', isLine: false
        }];
        cacheResult(geoJson, 'blue', 0.5, 'Temp', false, 'single');
        showModal(false);
    }

    function showModal(isMulti) {
        var modal = document.getElementById('save_modal');
        var sel = document.getElementById('color_selector');
        var title = document.getElementById('modal_title');
        
        if(isMulti) { sel.style.display = 'block'; sel.value = 'yellow'; title.innerText = "é‡æ„åˆ†æå®Œæˆ"; } 
        else { sel.style.display = 'none'; title.innerText = "ç»˜åˆ¶å®Œæˆ"; }
        
        modal.style.display = 'block';
        setTimeout(() => document.getElementById('poly_name_input').focus(), 50);
    }

    function closeModal() {
        document.getElementById('save_modal').style.display = 'none';
        clearAnalysis();
    }

    window.confirmSave = function() {
        var nameInput = document.getElementById('poly_name_input').value || "æœªå‘½å";
        var sel = document.getElementById('color_selector');
        var choice = (sel.style.display === 'none') ? 'single' : sel.value;

        var toSave = [];
        if(choice === 'all' || choice === 'single') toSave = appState.tempResultData;
        else toSave = appState.tempResultData.filter(i => i.rawType === choice);

        if(toSave.length === 0) { alert("æ²¡æœ‰è¯¥é¢œè‰²çš„åŒºåŸŸï¼"); return; }
        document.getElementById('save_modal').style.display = 'none';

        // å»¶æ—¶é˜Ÿåˆ—å‘é€ï¼Œé˜²æ­¢ä¸¢åŒ…
        toSave.forEach((item, idx) => {
            setTimeout(function() {
                var finalName = (toSave.length > 1) ? (nameInput + "_" + item.rawType + "_" + (idx+1)) : nameInput;
                addPermanent(item.geoJson, item.color, item.opacity, item.isLine, finalName);
            }, idx * 300); 
        });
        appState.tempResultData = [];
    };

    // ================= 6. è¾…åŠ©å‡½æ•° =================
    function cacheResult(geo, col, op, name, line, type) {
        var geoms = flattenGeo(geo);
        geoms.forEach(path => {
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4}) 
                          : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1});
            map.addOverlay(ov);
            appState.analysisOverlays.push(ov);
        });
        appState.tempResultData.push({geoJson:geo, color:col, opacity:op, rawType:type, isLine:line});
    }

    function addPermanent(geo, col, op, line, name) {
        var id = 'poly_' + (ID_COUNTER++);
        geo.properties = { id: id, name: name, svCol: col, svOp: op, svLine: line };
        var geoms = flattenGeo(geo);
        geoms.forEach(path => {
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4, strokeOpacity:op}) 
                          : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1});
            ov.addEventListener('click', function(){ window.focusPoly(id); });
            map.addOverlay(ov);
            appState.polygons.push({overlay:ov, geoJson:geo});
        });
        
        // ä½¿ç”¨ console.log é€šä¿¡ (åŒ¹é… OnConsoleMessage)
        var randomTag = new Date().getTime(); 
        console.log("UE_ADD:" + id + "|" + name + "|" + randomTag);
    }

    function flattenGeo(geo) {
        var coords = [];
        if(!geo || !geo.geometry) return [];
        var type = geo.geometry.type;
        if(type === 'MultiPolygon') coords = geo.geometry.coordinates.map(c=>c[0]);
        else if(type === 'Polygon') coords = [geo.geometry.coordinates[0]];
        else if(type === 'LineString') coords = [geo.geometry.coordinates];
        else if(type === 'MultiLineString') coords = geo.geometry.coordinates;
        var res = [];
        coords.forEach(c => { if(c) res.push(c.map(p => new BMapGL.Point(p[0], p[1]))); });
        return res;
    }

    function clearTemp() { 
        appState.drawPath=[]; 
        if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline); 
        if(appState.snapHintCircle) { map.removeOverlay(appState.snapHintCircle); appState.snapHintCircle = null; }
        appState.canSnapClose = false;
    }

    function clearAnalysis() { appState.analysisOverlays.forEach(o=>map.removeOverlay(o)); appState.analysisOverlays=[]; appState.tempResultData=[]; }

    // ================= 7. IO æ¥å£ =================
    window.exportMap = function(fname) {
        var data = appState.polygons.map(p => p.geoJson);
        console.log("UE_SAVE:" + fname + "|" + JSON.stringify(data));
    };
    window.importMap = function(json) {
        map.clearOverlays(); appState.polygons=[];
        var list = JSON.parse(json);
        list.forEach((g, i) => {
            var p = g.properties;
            setTimeout(() => addPermanent(g, p.svCol, p.svOp, p.svLine, p.name), i * 50);
        });
    };
    
    // èšç„¦åŠŸèƒ½ (æ”¯æŒ MultiPolygon)
    window.focusPoly = function(id) {
        var targets = appState.polygons.filter(p => p.geoJson.properties.id === id);
        if(targets.length > 0) {
            var b = new BMapGL.Bounds();
            targets.forEach(t => {
                var ovs = Array.isArray(t.overlay) ? t.overlay : [t.overlay];
                ovs.forEach(o => {
                    var path = o.getPath(); path.forEach(pt=>b.extend(pt));
                    var oldColor = o.getStrokeColor();
                    o.setStrokeColor("red"); o.setStrokeWeight(4);
                    setTimeout(() => { o.setStrokeColor(oldColor); o.setStrokeWeight(1); }, 800);
                });
            });
            map.setViewport(b);
        } else {
            console.log("UE_ERROR: JS focusPoly not found: " + id);
        }
    };
    
    // åˆ é™¤åŠŸèƒ½ (æ”¯æŒ MultiPolygon)
    window.deletePoly = function(id) {
        var targets = appState.polygons.filter(p => p.geoJson.properties.id === id);
        if(targets.length > 0) {
            targets.forEach(t => {
                var ovs = Array.isArray(t.overlay) ? t.overlay : [t.overlay];
                ovs.forEach(o => map.removeOverlay(o));
            });
            appState.polygons = appState.polygons.filter(p => p.geoJson.properties.id !== id);
            console.log("UE_LOG: Deleted poly " + id);
        } else {
            console.log("UE_ERROR: JS deletePoly not found: " + id);
        }
    };
</script>










<!--
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <style>
        /* ================= æ ·å¼å®šä¹‰ ================= */
        html, body, #map_container { width: 100%; height: 100%; overflow: hidden; margin: 0; font-family: "å¾®è½¯é›…é»‘"; }
        .anchorBL, .BMap_cpyCtrl { display: none; } /* éšè—ç™¾åº¦ç‰ˆæƒ */

        /* è‡ªå®šä¹‰ä¿å­˜å¼¹çª— (å›ºå®šåœ¨å±å¹•ä¸‹æ–¹) */
        #save_modal {
            display: none; 
            position: fixed; 
            left: 50%; bottom: 80px; transform: translateX(-50%);
            z-index: 9999;
            background: rgba(255, 255, 255, 0.95); 
            backdrop-filter: blur(10px);
            width: 260px; padding: 20px;
            border-radius: 12px; 
            box-shadow: 0 8px 30px rgba(0,0,0,0.3);
            border: 1px solid #eee;
            animation: popUp 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }

        @keyframes popUp { from { bottom: -200px; opacity: 0; } to { bottom: 80px; opacity: 1; } }

        #save_modal h4 { margin: 0 0 15px 0; font-size: 16px; color: #333; text-align: center; }
        #save_modal select { width: 100%; padding: 8px; margin-bottom: 15px; border: 1px solid #ddd; border-radius: 6px; outline: none; }
        #save_modal input { width: 92%; padding: 8px; margin-bottom: 20px; border: 1px solid #ddd; border-radius: 6px; outline: none; }

        .btn-group { display: flex; justify-content: space-between; gap: 10px; }
        .btn-group button { flex: 1; padding: 8px; cursor: pointer; border: none; border-radius: 6px; color: white; font-weight: bold; }
        #btn_confirm { background-color: #007bff; } 
        #btn_confirm:hover { background-color: #0056b3; }
        #btn_cancel { background-color: #6c757d; } 
        #btn_cancel:hover { background-color: #5a6268; }
    </style>

    <script type="text/javascript" src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
    <script src="turf.min.js"></script>

</head>

<body>
    <div id="map_container"></div>

    <div id="save_modal">
        <h4 id="modal_title">åˆ†æå®Œæˆ</h4>
        <select id="color_selector">
            <option value="yellow" selected>ğŸŸ¡ ä»…ä¿ç•™é»„è‰² (æ–°æ‹“å±•åŒº)</option>
            <option value="purple">ğŸŸ£ ä»…ä¿ç•™ç´«è‰² (å•ä¾§è¦†ç›–)</option>
            <option value="pink">ğŸŒ¸ ä»…ä¿ç•™æ·¡çº¢ (é‡å æ ¸å¿ƒ)</option>
            <option value="all">ğŸ’  ä¿ç•™æ‰€æœ‰åŒºåŸŸ</option>
        </select>
        <input type="text" id="poly_name_input" placeholder="è¯·è¾“å…¥åŒºåŸŸåç§°" value="æˆ‘çš„åŒºåŸŸ">
        <div class="btn-group">
            <button id="btn_cancel" onclick="closeModal()">ä¸¢å¼ƒ</button>
            <button id="btn_confirm" onclick="confirmSave()">ä¿å­˜</button>
        </div>
    </div>
</body>
</html>

<script>
    // ================= 1. å…¨å±€é…ç½®ä¸çŠ¶æ€ =================
    // å¼ºåˆ¶æ•è·æŠ¥é”™
    window.onerror = function(msg, url, line) { console.log("UE_ERROR:JS_Error:" + msg + " Line:" + line); };

    var map = new BMapGL.Map("map_container");
    map.centerAndZoom(new BMapGL.Point(116.404, 39.915), 17);
    map.enableScrollWheelZoom(true);
    map.setTilt(60);

    var appState = {
        mode: 'browse', // browse | edit | reconstruct
        polygons: [],   // æ°¸ä¹…æ•°æ®
        drawPath: [], isDrawing: false, tempPolyline: null,
        analysisOverlays: [], tempResultData: [] // ä¸´æ—¶æ•°æ®
    };
    var ID_COUNTER = 1;

    // ================= 2. äº¤äº’é€»è¾‘ (C++ è°ƒç”¨) =================
    window.setMode = function(mode) {
        appState.mode = mode;
        closeModal(); clearAnalysis(); clearTemp();
        if(mode === 'browse') map.enableDragging();
        else map.disableDragging();
    };

    // ================= 3. æ‰‹ç»˜é€»è¾‘ (æŒ‰ä½æ‹–æ‹½) =================
    map.addEventListener('mousedown', function(e) {
        if(appState.mode === 'browse') return;
        if(e.target.closest('#save_modal')) return; // é˜²æ­¢ç‚¹åˆ°å¼¹çª—
        
        appState.isDrawing = true;
        appState.drawPath = [e.latlng];
    });

    map.addEventListener('mousemove', function(e) {
        if(!appState.isDrawing || appState.mode === 'browse') return;
        appState.drawPath.push(e.latlng);
        
        // å®æ—¶ç”»çº¿
        if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline);
        appState.tempPolyline = new BMapGL.Polyline(appState.drawPath.map(p=>new BMapGL.Point(p.lng, p.lat)), {strokeColor:"blue", strokeWeight:2});
        map.addOverlay(appState.tempPolyline);
    });

    map.addEventListener('mouseup', function(e) {
        if(!appState.isDrawing || appState.mode === 'browse') return;
        appState.isDrawing = false;
        
        if(appState.drawPath.length < 3) { clearTemp(); return; }

        // é—­åˆä¸å¹³æ»‘
        appState.drawPath.push(appState.drawPath[0]);
        var coords = appState.drawPath.map(p => [p.lng, p.lat]);
        var rawGeo = turf.polygon([coords]);
        var simpleGeo = turf.simplify(rawGeo, {tolerance: 0.00001, highQuality: false});

        if (appState.mode === 'edit') {
            prepareSingleSave(simpleGeo);
        } 
        else if (appState.mode === 'reconstruct') {
            executeAnalysis(simpleGeo);
        }
        clearTemp();
    });

    // ================= 4. æ ¸å¿ƒåˆ†æç®—æ³• =================
    function executeAnalysis(polyX) {
        clearAnalysis(); appState.tempResultData = [];
        if(appState.polygons.length === 0) { prepareSingleSave(polyX); return; }

        try {
            var featX = turf.feature(polyX.geometry);
            var existFeats = appState.polygons.map(p => turf.feature(p.geoJson.geometry));

            // A. è®¡ç®—æ‰€æœ‰ C (A n B)
            var unionC = null;
            for(let i=0; i<existFeats.length; i++) {
                for(let j=i+1; j<existFeats.length; j++) {
                    var inter = turf.intersect(existFeats[i], existFeats[j]);
                    if(inter) unionC = unionC ? turf.union(unionC, inter) : inter;
                }
            }

            // B. X n C (æ·¡çº¢)
            var interXC = unionC ? turf.intersect(featX, unionC) : null;
            if(interXC) cacheResult(interXC, "#FFC0CB", 0.6, "é‡å æ ¸å¿ƒ", false, 'pink');

            // C. X n (A U B) - C (ç´«è‰²)
            var unionAll = existFeats[0];
            for(let i=1; i<existFeats.length; i++) unionAll = turf.union(unionAll, existFeats[i]);
            
            var interTotal = turf.intersect(featX, unionAll);
            var interPurple = (interTotal && interXC) ? turf.difference(interTotal, interXC) : interTotal;
            if(interPurple) cacheResult(interPurple, "#800080", 0.4, "å•ä¾§è¦†ç›–", false, 'purple');

            // D. è¾¹çº¿ (æ©™è‰²)
            if(interTotal) {
                var lines = turf.polygonToLine(interTotal);
                cacheResult(lines, "#FFA500", 1.0, "äº¤ç•Œçº¿", true, 'orange');
            }

            // E. X - All (é»„è‰²)
            var resE = turf.difference(featX, unionAll);
            if(resE) cacheResult(resE, "yellow", 0.3, "æ–°æ‹“å±•åŒº", false, 'yellow');

            showModal(true); 

        } catch(e) { console.log("UE_ERROR:" + e.message); alert("åˆ†æé”™è¯¯"); }
    }

    // ================= 5. å¼¹çª—ä¸ä¿å­˜é€»è¾‘ =================
    function prepareSingleSave(geoJson) {
        appState.tempResultData = [{
            geoJson: geoJson, color: 'blue', opacity: 0.5, rawType: 'single', isLine: false
        }];
        cacheResult(geoJson, 'blue', 0.5, 'Temp', false, 'single');
        showModal(false);
    }

    function showModal(isMulti) {
        var modal = document.getElementById('save_modal');
        var sel = document.getElementById('color_selector');
        var title = document.getElementById('modal_title');
        
        if(isMulti) {
            sel.style.display = 'block';
            sel.value = 'yellow'; // é»˜è®¤é€‰é»„è‰²
            title.innerText = "é‡æ„åˆ†æå®Œæˆ";
        } else {
            sel.style.display = 'none'; 
            title.innerText = "ç»˜åˆ¶å®Œæˆ";
        }
        
        modal.style.display = 'block';
        setTimeout(() => document.getElementById('poly_name_input').focus(), 50);
    }

    function closeModal() {
        document.getElementById('save_modal').style.display = 'none';
        clearAnalysis(); 
    }

    window.confirmSave = function() {
        var nameInput = document.getElementById('poly_name_input').value || "æœªå‘½å";
        var sel = document.getElementById('color_selector');
        var choice = (sel.style.display === 'none') ? 'single' : sel.value;

        // ç­›é€‰
        var toSave = [];
        if(choice === 'all' || choice === 'single') toSave = appState.tempResultData;
        else toSave = appState.tempResultData.filter(i => i.rawType === choice);

        if(toSave.length === 0) { alert("æ²¡æœ‰è¯¥é¢œè‰²çš„åŒºåŸŸï¼"); return; }

        document.getElementById('save_modal').style.display = 'none';

        // --- æ ¸å¿ƒï¼šé˜Ÿåˆ—å‘é€ï¼Œè§£å†³UE5ä¸¢åŒ… ---
        processSaveQueue(toSave, nameInput, 0);
    };

    function processSaveQueue(list, baseName, index) {
        if(index >= list.length) {
            appState.tempResultData = [];
            return;
        }

        var item = list[index];
        var finalName = (list.length > 1) ? (baseName + "_" + item.rawType + "_" + (index+1)) : baseName;
        
        addPermanent(item.geoJson, item.color, item.opacity, item.isLine, finalName);

        // é—´éš” 150ms å‘é€ä¸‹ä¸€æ¡
        setTimeout(function() {
            processSaveQueue(list, baseName, index + 1);
        }, 150);
    }

    // ================= 6. è¾…åŠ©å‡½æ•° =================
    function cacheResult(geo, col, op, name, line, type) {
        var geoms = flattenGeo(geo);
        geoms.forEach(path => {
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4}) 
                          : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1});
            map.addOverlay(ov);
            appState.analysisOverlays.push(ov);
        });
        appState.tempResultData.push({geoJson:geo, color:col, opacity:op, rawType:type, isLine:line});
    }

    function addPermanent(geo, col, op, line, name) {
        var id = 'poly_' + (ID_COUNTER++);
        geo.properties = { id: id, name: name, svCol: col, svOp: op, svLine: line };
        
        var geoms = flattenGeo(geo);
        geoms.forEach(path => {
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4, strokeOpacity:op}) 
                          : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1});
            ov.addEventListener('click', function(){ window.focusPoly(id); });
            map.addOverlay(ov);
            appState.polygons.push({overlay:ov, geoJson:geo});
        });

        // ã€é€šä¿¡æ ¸å¿ƒã€‘ä½¿ç”¨ console.log å‘é€æ•°æ®ç»™ UE5
        console.log("UE_ADD:" + id + "|" + name);
    }

    // å¼ºåŠ›å±•å¹³å‡½æ•° (è§£å†³é»„è‰²åŒºåŸŸä¸¢å¤± BUG)
    function flattenGeo(geo) {
        var coords = [];
        if(!geo || !geo.geometry) return [];
        
        var type = geo.geometry.type;
        if(type === 'MultiPolygon') coords = geo.geometry.coordinates.map(c=>c[0]);
        else if(type === 'Polygon') coords = [geo.geometry.coordinates[0]];
        else if(type === 'LineString') coords = [geo.geometry.coordinates];
        else if(type === 'MultiLineString') coords = geo.geometry.coordinates;
        
        var res = [];
        coords.forEach(c => {
            if(c) res.push(c.map(p => new BMapGL.Point(p[0], p[1])));
        });
        return res;
    }

    function clearTemp() { appState.drawPath=[]; if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline); }
    function clearAnalysis() { appState.analysisOverlays.forEach(o=>map.removeOverlay(o)); appState.analysisOverlays=[]; appState.tempResultData=[]; }

    // ================= 7. IO æ¥å£ =================
    window.exportMap = function(fname) {
        var data = appState.polygons.map(p => p.geoJson);
        console.log("UE_SAVE:" + fname + "|" + JSON.stringify(data));
    };
    window.importMap = function(json) {
        map.clearOverlays(); appState.polygons=[];
        var list = JSON.parse(json);
        list.forEach((g, i) => {
            var p = g.properties;
            // è¯»æ¡£ä¹Ÿéœ€è¦é˜Ÿåˆ—ï¼Œå¦åˆ™åˆ—è¡¨ä¼šå¡æ­»
            setTimeout(() => addPermanent(g, p.svCol, p.svOp, p.svLine, p.name), i * 50);
        });
    };
    
    // --- ä¿®å¤ï¼šæ”¯æŒèšç„¦ç”±å¤šä¸ªç¢ç‰‡ç»„æˆçš„åŒºåŸŸ ---
    window.focusPoly = function(id) {
        // æ‰¾å‡ºæ‰€æœ‰å±äºè¿™ä¸ª ID çš„å¤šè¾¹å½¢ç¢ç‰‡ (é»„è‰²åŒºåŸŸå¯èƒ½æ˜¯ç”±3-5ä¸ªç¢ç‰‡ç»„æˆçš„)
        var targets = appState.polygons.filter(p => p.geoJson.properties.id === id);
        
        if(targets.length > 0) {
            var b = new BMapGL.Bounds();
            // éå†æ‰€æœ‰ç¢ç‰‡è®¡ç®—æ€»è¾¹ç•Œ
            targets.forEach(t => {
                var path = t.overlay.getPath();
                path.forEach(pt => b.extend(pt));
                
                // é—ªçƒç‰¹æ•ˆ
                var oldColor = t.overlay.getStrokeColor();
                var oldWeight = t.overlay.getStrokeWeight();
                t.overlay.setStrokeColor("red"); 
                t.overlay.setStrokeWeight(4);
                
                // 800ms åæ¢å¤
                setTimeout(() => { 
                    t.overlay.setStrokeColor(oldColor); 
                    t.overlay.setStrokeWeight(oldWeight); 
                }, 800);
            });
            
            // é•œå¤´è·³è½¬
            map.setViewport(b);
        } else {
            console.log("UE_ERROR: JS focusPoly - ID not found: " + id);
        }
    };
    
    // --- ä¿®å¤ï¼šå½»åº•åˆ é™¤IDå¯¹åº”çš„æ‰€æœ‰ç¢ç‰‡ ---
    window.deletePoly = function(id) {
        // 1. æ‰¾åˆ°æ‰€æœ‰åŒ¹é…çš„ç´¢å¼•
        var targets = appState.polygons.filter(p => p.geoJson.properties.id === id);
        
        if(targets.length > 0) {
            // 2. ä»åœ°å›¾ä¸Šç§»é™¤ Overlay
            targets.forEach(t => map.removeOverlay(t.overlay));
            
            // 3. ä»å†…å­˜æ•°ç»„ä¸­å½»åº•å‰”é™¤ (ä¿ç•™ä¸ç­‰äº id çš„)
            appState.polygons = appState.polygons.filter(p => p.geoJson.properties.id !== id);
            
            console.log("UE_LOG: Deleted " + targets.length + " parts for ID: " + id);
        } else {
            console.log("UE_ERROR: JS deletePoly - ID not found: " + id);
        }
    };
</script>
-->










<!--
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <style>
        /* ä¿æŒåŸæœ‰æ ·å¼ä¸å˜ */
        html, body, #map_container { width: 100%; height: 100%; overflow: hidden; margin: 0; font-family: "å¾®è½¯é›…é»‘"; }
        .anchorBL, .BMap_cpyCtrl { display: none; } 
        #save_modal {
            display: none; position: fixed; left: 50%; bottom: 80px; transform: translateX(-50%);
            z-index: 9999; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px);
            width: 260px; padding: 20px; border-radius: 12px; box-shadow: 0 8px 30px rgba(0,0,0,0.3);
            border: 1px solid #eee; animation: popUp 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }
        @keyframes popUp { from { bottom: -200px; opacity: 0; } to { bottom: 80px; opacity: 1; } }
        #save_modal h4 { margin: 0 0 15px 0; font-size: 16px; color: #333; text-align: center; }
        #save_modal select { width: 100%; padding: 8px; margin-bottom: 15px; border: 1px solid #ddd; border-radius: 6px; }
        #save_modal input { width: 92%; padding: 8px; margin-bottom: 20px; border: 1px solid #ddd; border-radius: 6px; }
        .btn-group { display: flex; justify-content: space-between; gap: 10px; }
        .btn-group button { flex: 1; padding: 8px; cursor: pointer; border: none; border-radius: 6px; color: white; font-weight: bold; }
        #btn_confirm { background-color: #007bff; }
        #btn_cancel { background-color: #6c757d; }
    </style>
        <script type="text/javascript" src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
    <script src="turf.min.js"></script>
</head>
<body>
    <div id="map_container"></div>
    <div id="save_modal">
        <h4 id="modal_title">åˆ†æå®Œæˆ</h4>
        <select id="color_selector">
            <option value="yellow" selected>ğŸŸ¡ ä»…ä¿ç•™é»„è‰² (æ–°æ‹“å±•åŒº)</option>
            <option value="purple">ğŸŸ£ ä»…ä¿ç•™ç´«è‰² (å•ä¾§è¦†ç›–)</option>
            <option value="pink">ğŸŒ¸ ä»…ä¿ç•™æ·¡çº¢ (é‡å æ ¸å¿ƒ)</option>
            <option value="all">ğŸ’  ä¿ç•™æ‰€æœ‰åŒºåŸŸ</option>
        </select>
        <input type="text" id="poly_name_input" placeholder="è¯·è¾“å…¥åŒºåŸŸåç§°" value="æˆ‘çš„åŒºåŸŸ">
        <div class="btn-group">
            <button id="btn_cancel" onclick="closeModal()">ä¸¢å¼ƒ</button>
            <button id="btn_confirm" onclick="confirmSave()">ä¿å­˜</button>
        </div>
    </div>
</body>
</html>


<script>
    var map = new BMapGL.Map("map_container");
    map.centerAndZoom(new BMapGL.Point(116.404, 39.915), 17);
    map.enableScrollWheelZoom(true);
    map.setTilt(60);

    var appState = {
        mode: 'browse', polygons: [], 
        drawPath: [], isDrawing: false, tempPolyline: null,
        analysisOverlays: [], tempResultData: []
    };
    var ID_COUNTER = 1;

    window.setMode = function(mode) {
        appState.mode = mode;
        closeModal(); clearAnalysis(); clearTemp();
        if(mode === 'browse') map.enableDragging();
        else map.disableDragging();
    };

    map.addEventListener('mousedown', function(e) {
        if(appState.mode === 'browse') return;
        if(e.target.closest('#save_modal')) return;
        appState.isDrawing = true; appState.drawPath = [e.latlng];
    });

    map.addEventListener('mousemove', function(e) {
        if(!appState.isDrawing || appState.mode === 'browse') return;
        appState.drawPath.push(e.latlng);
        if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline);
        appState.tempPolyline = new BMapGL.Polyline(appState.drawPath.map(p=>new BMapGL.Point(p.lng, p.lat)), {strokeColor:"blue", strokeWeight:2});
        map.addOverlay(appState.tempPolyline);
    });

    map.addEventListener('mouseup', function(e) {
        if(!appState.isDrawing || appState.mode === 'browse') return;
        appState.isDrawing = false;
        var screenX = e.clientX; var screenY = e.clientY;
        if(appState.drawPath.length < 3) { clearTemp(); return; }

        appState.drawPath.push(appState.drawPath[0]);
        var coords = appState.drawPath.map(p => [p.lng, p.lat]);
        var rawGeo = turf.polygon([coords]);
        var simpleGeo = turf.simplify(rawGeo, {tolerance: 0.00001, highQuality: false});

        if (appState.mode === 'edit') prepareSingleSave(simpleGeo);
        else if (appState.mode === 'reconstruct') executeAnalysis(simpleGeo, screenX, screenY);
        clearTemp();
    });

    function executeAnalysis(polyX, mx, my) {
        clearAnalysis(); appState.tempResultData = [];
        if(appState.polygons.length === 0) { prepareSingleSave(polyX); return; }

        try {
            var featX = turf.feature(polyX.geometry);
            var existFeats = appState.polygons.map(p => turf.feature(p.geoJson.geometry));
            
            var unionC = null;
            for(let i=0; i<existFeats.length; i++) {
                for(let j=i+1; j<existFeats.length; j++) {
                    var inter = turf.intersect(existFeats[i], existFeats[j]);
                    if(inter) unionC = unionC ? turf.union(unionC, inter) : inter;
                }
            }
            var interXC = unionC ? turf.intersect(featX, unionC) : null;
            if(interXC) cacheResult(interXC, "#FFC0CB", 0.6, "é‡å æ ¸å¿ƒ", false, 'pink');

            var unionAll = existFeats[0];
            for(let i=1; i<existFeats.length; i++) unionAll = turf.union(unionAll, existFeats[i]);
            var interTotal = turf.intersect(featX, unionAll);
            var interPurple = (interTotal && interXC) ? turf.difference(interTotal, interXC) : interTotal;
            if(interPurple) cacheResult(interPurple, "#800080", 0.4, "å•ä¾§è¦†ç›–", false, 'purple');

            if(interTotal) {
                var lines = turf.polygonToLine(interTotal);
                cacheResult(lines, "#FFA500", 1.0, "äº¤ç•Œçº¿", true, 'orange');
            }

            var resE = turf.difference(featX, unionAll);
            if(resE) cacheResult(resE, "yellow", 0.3, "æ–°æ‹“å±•åŒº", false, 'yellow');

            showModal(true); 
        } catch(e) { console.error(e); alert("åˆ†æé”™è¯¯"); }
    }

    function prepareSingleSave(geoJson) {
        appState.tempResultData = [{geoJson: geoJson, color: 'blue', opacity: 0.5, rawType: 'single', isLine: false}];
        cacheResult(geoJson, 'blue', 0.5, 'Temp', false, 'single');
        showModal(false);
    }

    function showModal(isMulti) {
        var modal = document.getElementById('save_modal');
        var sel = document.getElementById('color_selector');
        var title = document.getElementById('modal_title');
        
        if(isMulti) { sel.style.display = 'block'; sel.value = 'yellow'; title.innerText = "é‡æ„åˆ†æå®Œæˆ"; } 
        else { sel.style.display = 'none'; title.innerText = "ç»˜åˆ¶å®Œæˆ"; }
        
        modal.style.display = 'block';
        document.getElementById('poly_name_input').focus();
    }

    function closeModal() {
        document.getElementById('save_modal').style.display = 'none';
        clearAnalysis();
    }

    window.confirmSave = function() {
        var nameInput = document.getElementById('poly_name_input').value || "æœªå‘½å";
        var sel = document.getElementById('color_selector');
        var choice = (sel.style.display === 'none') ? 'single' : sel.value;

        // 1. ç­›é€‰æ•°æ®
        var toSave = [];
        if(choice === 'all' || choice === 'single') toSave = appState.tempResultData;
        else toSave = appState.tempResultData.filter(i => i.rawType === choice);

        if(toSave.length === 0) { alert("æ²¡æœ‰è¯¥é¢œè‰²çš„åŒºåŸŸï¼"); return; }

        // å…³é—­å¼¹çª—
        document.getElementById('save_modal').style.display = 'none';

        // 2. å¯åŠ¨é€’å½’å‘é€é˜Ÿåˆ— (æ¯” forEach + setTimeout æ›´ç¨³)
        processSaveQueue(toSave, nameInput, 0);
    };

    // é€’å½’å¤„ç†é˜Ÿåˆ—
    function processSaveQueue(list, baseName, index) {
        if (index >= list.length) {
            // å…¨éƒ¨å‘å®Œï¼Œæ¸…ç©ºä¸´æ—¶æ•°æ®
            appState.tempResultData = [];
            return;
        }

        var item = list[index];
        // æ„å»ºåå­—
        var finalName = (list.length > 1) ? (baseName + "_" + item.rawType + "_" + (index+1)) : baseName;
        
        // ä¿å­˜å¹¶å‘é€æ¶ˆæ¯
        addPermanent(item.geoJson, item.color, item.opacity, item.isLine, finalName);

        // **å…³é”®å»¶è¿Ÿ**ï¼šæ¯å¤„ç†å®Œä¸€ä¸ªï¼Œä¼‘æ¯ 100ms å†å¤„ç†ä¸‹ä¸€ä¸ªï¼Œç»™ UE5 å–˜æ¯æ—¶é—´
        setTimeout(function() {
            processSaveQueue(list, baseName, index + 1);
        }, 150); 
    }

    // --- ç”Ÿæˆæ°¸ä¹…æ•°æ® ---
    function addPermanent(geo, col, op, line, name) {
        var id = 'poly_' + (ID_COUNTER++);
        geo.properties = { id: id, name: name, svCol: col, svOp: op, svLine: line };
        
        var geoms = flattenGeo(geo);
        geoms.forEach(path => {
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4, strokeOpacity:op}) 
                          : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1});
            ov.addEventListener('click', function(){ window.focusPoly(id); });
            map.addOverlay(ov);
            appState.polygons.push({overlay:ov, geoJson:geo});
        });

        // ============================================================
        // ã€æ ¸å¿ƒä¿®å¤ã€‘å¼ºåˆ¶è§¦å‘æ›´æ–°
        // åœ¨æœ«å°¾åŠ ä¸€ä¸ªéšæœºæ—¶é—´æˆ³ï¼Œç¡®ä¿æ¯æ¬¡ title éƒ½ä¸ä¸€æ ·ï¼Œå¼ºåˆ¶ UE5 æ¥æ”¶
        // UE5 C++ é‚£è¾¹åªæˆªå–å‰ä¸¤ä¸ªéƒ¨åˆ†ï¼Œä¸ä¼šå—å½±å“
        // ============================================================
        var randomTag = new Date().getTime(); 
        document.title = "UE_ADD:" + id + "|" + name + "|" + randomTag;
    }

    function cacheResult(geo, col, op, name, line, type) {
        var geoms = flattenGeo(geo);
        geoms.forEach(path => {
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4}) 
                          : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1});
            map.addOverlay(ov);
            appState.analysisOverlays.push(ov);
        });
        appState.tempResultData.push({geoJson:geo, color:col, opacity:op, rawType:type, isLine:line});
    }

    function addPermanent(geo, col, op, line, name) {
        var id = 'poly_' + (ID_COUNTER++);
        geo.properties = { id: id, name: name, svCol: col, svOp: op, svLine: line };
        
        var geoms = flattenGeo(geo);
        geoms.forEach(path => {
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4, strokeOpacity:op}) 
                          : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1});
            ov.addEventListener('click', function(){ window.focusPoly(id); });
            map.addOverlay(ov);
            appState.polygons.push({overlay:ov, geoJson:geo});
        });

        // --- æ ¸å¿ƒä¿®å¤ï¼šé¿å… Title é‡å¤ï¼Œå¼ºåˆ¶è§¦å‘ ---
        // ä¹‹å‰åªå‘äº† ID|Nameï¼Œå¦‚æœåå­—ä¸€æ ·ï¼ŒUE5 å°±ä¸è§¦å‘äº†ã€‚
        // æˆ‘ä»¬åˆ©ç”¨ title çš„ç‰¹æ€§ï¼Œå®ƒåªæ˜¯ä¸ªä¿¡ä½¿ã€‚
        // è¿™é‡Œä¸éœ€è¦ Dateï¼Œåªè¦ç¡®ä¿ UE5 C++ é‚£è¾¹å¤„ç†æ­£ç¡®å³å¯ã€‚
        document.title = "UE_ADD:" + id + "|" + name;
    }

    function flattenGeo(geo) {
        var coords = [];
        // é²æ£’æ€§æ£€æŸ¥ï¼šé˜²æ­¢ MultiPolygon å¯¼è‡´çš„æ•°æ®ä¸¢å¤±
        if (!geo.geometry) return [];
        if(geo.geometry.type === 'MultiPolygon') coords = geo.geometry.coordinates.map(c=>c[0]);
        else if(geo.geometry.type === 'Polygon') coords = [geo.geometry.coordinates[0]];
        else if(geo.geometry.type === 'LineString') coords = [geo.geometry.coordinates];
        
        var res = [];
        coords.forEach(c => res.push(c.map(p => new BMapGL.Point(p[0], p[1]))));
        return res;
    }

    function clearTemp() { appState.drawPath=[]; if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline); }
    function clearAnalysis() { appState.analysisOverlays.forEach(o=>map.removeOverlay(o)); appState.analysisOverlays=[]; appState.tempResultData=[]; }

    window.exportMap = function(fname) {
        var data = appState.polygons.map(p => p.geoJson);
        document.title = "UE_SAVE:" + fname + "|" + JSON.stringify(data);
    };
    window.importMap = function(json) {
        map.clearOverlays(); appState.polygons=[];
        var list = JSON.parse(json);
        list.forEach(g => {
            var p = g.properties;
            setTimeout(() => addPermanent(g, p.svCol, p.svOp, p.svLine, p.name), 50);
        });
    };
    window.focusPoly = function(id) {
        var t = appState.polygons.find(p=>p.geoJson.properties.id === id);
        if(t) {
            var b = new BMapGL.Bounds();
            // ç®€å•å–ç¬¬ä¸€ä¸ªOverlayçš„èŒƒå›´
            if(Array.isArray(t.overlay)) { /* Handle Multi */ } 
            else { 
               var path = t.overlay.getPath(); path.forEach(pt=>b.extend(pt)); 
            }
            map.setViewport(b);
            var old = t.overlay.getStrokeColor();
            t.overlay.setStrokeColor("red"); t.overlay.setStrokeWeight(4);
            setTimeout(()=>{ t.overlay.setStrokeColor(old); t.overlay.setStrokeWeight(1); }, 800);
        }
    };
    window.deletePoly = function(id) {
        var idx = appState.polygons.findIndex(p=>p.geoJson.properties.id === id);
        if(idx>-1) { map.removeOverlay(appState.polygons[idx].overlay); appState.polygons.splice(idx,1); }
    };
</script>
-->









<!--
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <style>
        /* æ ·å¼å®šä¹‰ */
        html, body, #map_container { width: 100%; height: 100%; overflow: hidden; margin: 0; font-family: "å¾®è½¯é›…é»‘"; }
        .anchorBL, .BMap_cpyCtrl { display: none; } /* éšè—ç™¾åº¦ç‰ˆæƒ */

        /* è‡ªå®šä¹‰ä¿å­˜å¼¹çª— (HTML UI) */
        #save_modal {
            display: none; position: absolute; z-index: 9999;
            background: white; width: 240px; padding: 15px;
            border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            border: 1px solid #ddd;
        }
        #save_modal h4 { margin: 0 0 10px 0; font-size: 14px; color: #333; }
        #save_modal select { width: 100%; padding: 6px; margin-bottom: 12px; border: 1px solid #ccc; border-radius: 4px; }
        #save_modal input { width: 93%; padding: 6px; margin-bottom: 12px; border: 1px solid #ccc; border-radius: 4px; }
        .btn-group { display: flex; justify-content: space-between; }
        .btn-group button { padding: 6px 15px; cursor: pointer; border: none; border-radius: 4px; color: white; font-size: 12px; }
        #btn_confirm { background-color: #007bff; }
        #btn_cancel { background-color: #6c757d; }
    </style>
        <script type="text/javascript" src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
    <script src="turf.min.js"></script>
</head>
<body>
    <div id="map_container"></div>

    <div id="save_modal">
        <h4 id="modal_title">åˆ†æå®Œæˆ</h4>
        <select id="color_selector">
            <option value="yellow" selected>ğŸŸ¡ ä»…ä¿ç•™é»„è‰² (æ–°æ‹“å±•åŒº)</option>
            <option value="purple">ğŸŸ£ ä»…ä¿ç•™ç´«è‰² (å•ä¾§è¦†ç›–)</option>
            <option value="pink">ğŸŒ¸ ä»…ä¿ç•™æ·¡çº¢ (é‡å æ ¸å¿ƒ)</option>
            <option value="all">ğŸ’  ä¿ç•™æ‰€æœ‰åŒºåŸŸ</option>
        </select>
        <input type="text" id="poly_name_input" placeholder="è¯·è¾“å…¥åŒºåŸŸåç§°" value="æˆ‘çš„åŒºåŸŸ">
        <div class="btn-group">
            <button id="btn_cancel" onclick="closeModal()">ä¸¢å¼ƒ</button>
            <button id="btn_confirm" onclick="confirmSave()">ä¿å­˜</button>
        </div>
    </div>
</body>
</html>

<script>
    // ================= åˆå§‹åŒ– =================
    var map = new BMapGL.Map("map_container");
    map.centerAndZoom(new BMapGL.Point(116.404, 39.915), 17);
    map.enableScrollWheelZoom(true);
    map.setTilt(60);

    var appState = {
        mode: 'browse', // browse | edit | reconstruct
        polygons: [],   // æ°¸ä¹…æ•°æ®
        drawPath: [], isDrawing: false, tempPolyline: null,
        analysisOverlays: [], tempResultData: [] // ä¸´æ—¶åˆ†æç»“æœ
    };
    var ID_COUNTER = 1;

    // ================= äº¤äº’é€»è¾‘ (C++ è°ƒç”¨) =================
    window.setMode = function(mode) {
        appState.mode = mode;
        closeModal(); clearAnalysis(); clearTemp();
        if(mode === 'browse') map.enableDragging();
        else map.disableDragging(); // ç¼–è¾‘/é‡æ„æ¨¡å¼ç¦æ­¢æ‹–æ‹½åœ°å›¾
    };

    // ================= æ‰‹ç»˜é€»è¾‘ (æŒ‰ä½æ‹–æ‹½) =================
    map.addEventListener('mousedown', function(e) {
        if(appState.mode === 'browse') return;
        // å¦‚æœç‚¹åˆ°äº†å¼¹çª—ï¼Œä¸ç”»å›¾
        if(e.target.closest('#save_modal')) return;
        
        appState.isDrawing = true;
        appState.drawPath = [e.latlng];
    });

    map.addEventListener('mousemove', function(e) {
        if(!appState.isDrawing || appState.mode === 'browse') return;
        appState.drawPath.push(e.latlng);
        
        // å®æ—¶ç”»çº¿
        if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline);
        appState.tempPolyline = new BMapGL.Polyline(appState.drawPath.map(p=>new BMapGL.Point(p.lng, p.lat)), {strokeColor:"blue", strokeWeight:2});
        map.addOverlay(appState.tempPolyline);
    });

    map.addEventListener('mouseup', function(e) {
        if(!appState.isDrawing || appState.mode === 'browse') return;
        appState.isDrawing = false;
        
        // æ•è·é¼ æ ‡å±å¹•åæ ‡ï¼Œç”¨äºå¼¹çª—
        var screenX = e.clientX;
        var screenY = e.clientY;

        if(appState.drawPath.length < 3) { clearTemp(); return; }

        // é—­åˆä¸å¹³æ»‘å¤„ç†
        appState.drawPath.push(appState.drawPath[0]);
        var coords = appState.drawPath.map(p => [p.lng, p.lat]);
        var rawGeo = turf.polygon([coords]);
        var simpleGeo = turf.simplify(rawGeo, {tolerance: 0.00001, highQuality: false});

        if (appState.mode === 'edit') {
            // ç¼–è¾‘æ¨¡å¼ï¼šç›´æ¥å¼¹çª—é—®åå­—ä¿å­˜
            prepareSingleSave(simpleGeo, screenX, screenY);
        } 
        else if (appState.mode === 'reconstruct') {
            // é‡æ„æ¨¡å¼ï¼šæ‰§è¡Œå¤æ‚åˆ†æ
            executeAnalysis(simpleGeo, screenX, screenY);
        }
        clearTemp();
    });

    // ================= æ ¸å¿ƒåˆ†æç®—æ³• =================
    function executeAnalysis(polyX, mx, my) {
        clearAnalysis(); appState.tempResultData = [];
        if(appState.polygons.length === 0) { prepareSingleSave(polyX, mx, my); return; }

        try {
            var featX = turf.feature(polyX.geometry);
            var existFeats = appState.polygons.map(p => turf.feature(p.geoJson.geometry));

            // A. è®¡ç®—æ‰€æœ‰ C (A n B)
            var unionC = null;
            for(let i=0; i<existFeats.length; i++) {
                for(let j=i+1; j<existFeats.length; j++) {
                    var inter = turf.intersect(existFeats[i], existFeats[j]);
                    if(inter) unionC = unionC ? turf.union(unionC, inter) : inter;
                }
            }

            // B. X n C (æ·¡çº¢)
            var interXC = unionC ? turf.intersect(featX, unionC) : null;
            if(interXC) cacheResult(interXC, "#FFC0CB", 0.6, "é‡å æ ¸å¿ƒ", false, 'pink');

            // C. X n (A U B) - C (ç´«è‰²)
            var unionAll = existFeats[0];
            for(let i=1; i<existFeats.length; i++) unionAll = turf.union(unionAll, existFeats[i]);
            
            var interTotal = turf.intersect(featX, unionAll);
            var interPurple = (interTotal && interXC) ? turf.difference(interTotal, interXC) : interTotal;
            if(interPurple) cacheResult(interPurple, "#800080", 0.4, "å•ä¾§è¦†ç›–", false, 'purple');

            // D. è¾¹çº¿ (æ©™è‰²)
            if(interTotal) {
                var lines = turf.polygonToLine(interTotal);
                cacheResult(lines, "#FFA500", 1.0, "äº¤ç•Œçº¿", true, 'orange');
            }

            // E. X - All (é»„è‰²) [ä¿®å¤MultiPolygonä¸¢å¤±é—®é¢˜]
            var resE = turf.difference(featX, unionAll);
            if(resE) cacheResult(resE, "yellow", 0.3, "æ–°æ‹“å±•åŒº", false, 'yellow');

            // å¼¹å‡ºåˆ†æç»“æœä¿å­˜çª—
            showModal(mx, my, true); 

        } catch(e) { console.error(e); alert("åˆ†æé”™è¯¯"); }
    }

    // ================= å¼¹çª—ä¸ä¿å­˜é€»è¾‘ =================
    function prepareSingleSave(geoJson, x, y) {
        // ä¼ªè£…æˆä¸´æ—¶æ•°æ®ä»¥ä¾¿ç»Ÿä¸€å¤„ç†
        appState.tempResultData = [{
            geoJson: geoJson, color: 'blue', opacity: 0.5, rawType: 'single', isLine: false
        }];
        // ä¸´æ—¶æ¸²æŸ“ä¸€ä¸‹ä»¥ä¾¿ç”¨æˆ·çœ‹åˆ°
        cacheResult(geoJson, 'blue', 0.5, 'Temp', false, 'single');
        showModal(x, y, false); // falseè¡¨ç¤ºä¸æ˜¯å¤šé€‰æ¨¡å¼ï¼Œéšè—ä¸‹æ‹‰æ¡†
    }

    function showModal(x, y, isMulti) {
        var modal = document.getElementById('save_modal');
        var sel = document.getElementById('color_selector');
        var title = document.getElementById('modal_title');
        
        if(isMulti) {
            sel.style.display = 'block';
            sel.value = 'yellow'; // é»˜è®¤é€‰é»„è‰²
            title.innerText = "é‡æ„åˆ†æå®Œæˆ";
        } else {
            sel.style.display = 'none'; // å•ä¸ªä¿å­˜ä¸éœ€è¦é€‰é¢œè‰²
            title.innerText = "ç»˜åˆ¶å®Œæˆ";
        }

        // æ™ºèƒ½å®šä½ï¼Œé˜²æ­¢æº¢å‡ºå±å¹•
        var left = Math.min(x + 15, window.innerWidth - 260);
        var top = Math.min(y + 15, window.innerHeight - 200);
        modal.style.left = left + 'px';
        modal.style.top = top + 'px';
        modal.style.display = 'block';
        
        // è‡ªåŠ¨èšç„¦è¾“å…¥æ¡†
        document.getElementById('poly_name_input').focus();
    }

    function closeModal() {
        document.getElementById('save_modal').style.display = 'none';
        clearAnalysis(); // ä¸¢å¼ƒä¸´æ—¶æ•°æ®
    }

    window.confirmSave = function() {
        var nameInput = document.getElementById('poly_name_input').value || "æœªå‘½å";
        var sel = document.getElementById('color_selector');
        var choice = (sel.style.display === 'none') ? 'single' : sel.value;

        // è¿‡æ»¤æ•°æ®
        var toSave = [];
        if(choice === 'all' || choice === 'single') toSave = appState.tempResultData;
        else toSave = appState.tempResultData.filter(i => i.rawType === choice);

        if(toSave.length === 0) { alert("æ²¡æœ‰è¯¥é¢œè‰²çš„åŒºåŸŸï¼"); return; }

        // æ‰§è¡Œä¿å­˜
        toSave.forEach((item, idx) => {
            var finalName = (toSave.length > 1) ? (nameInput + "_" + item.rawType + "_" + idx) : nameInput;
            addPermanent(item.geoJson, item.color, item.opacity, item.isLine, finalName);
        });

        document.getElementById('save_modal').style.display = 'none';
        appState.analysisOverlays = []; appState.tempResultData = [];
    };

    // ================= è¾…åŠ©å‡½æ•° =================
    function cacheResult(geo, col, op, name, line, type) {
        // æ¸²æŸ“ä¸´æ—¶Overlay
        var geoms = flattenGeo(geo);
        geoms.forEach(path => {
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4}) 
                          : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1});
            map.addOverlay(ov);
            appState.analysisOverlays.push(ov);
        });
        // å­˜æ•°æ®
        appState.tempResultData.push({geoJson:geo, color:col, opacity:op, rawType:type, isLine:line});
    }

    function addPermanent(geo, col, op, line, name) {
        var id = 'poly_' + (ID_COUNTER++);
        // èµ‹äºˆå±æ€§
        geo.properties = { id: id, name: name, svCol: col, svOp: op, svLine: line };
        
        var geoms = flattenGeo(geo);
        geoms.forEach(path => {
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4, strokeOpacity:op}) 
                          : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1});
            
            // ç‚¹å‡»é«˜äº®é€»è¾‘
            ov.addEventListener('click', function(){ window.focusPoly(id); });
            map.addOverlay(ov);
            appState.polygons.push({overlay:ov, geoJson:geo});
        });

        // é€šçŸ¥UE5æ·»åŠ åˆ—è¡¨é¡¹
        document.title = "UE_ADD:" + id + "|" + name;
    }

    // å±•å¹³ MultiPolygon ä¸º Point æ•°ç»„åˆ—è¡¨
    function flattenGeo(geo) {
        var res = [];
        var coords = [];
        if(geo.geometry.type === 'MultiPolygon') coords = geo.geometry.coordinates.map(c=>c[0]);
        else if(geo.geometry.type === 'Polygon') coords = [geo.geometry.coordinates[0]];
        else if(geo.geometry.type === 'LineString') coords = [geo.geometry.coordinates];
        
        coords.forEach(c => {
            res.push(c.map(p => new BMapGL.Point(p[0], p[1])));
        });
        return res;
    }

    function clearTemp() { appState.drawPath=[]; if(appState.tempPolyline) map.removeOverlay(appState.tempPolyline); }
    function clearAnalysis() { appState.analysisOverlays.forEach(o=>map.removeOverlay(o)); appState.analysisOverlays=[]; appState.tempResultData=[]; }

    // ================= IO æ¥å£ (UE5è°ƒç”¨) =================
    window.exportMap = function(fname) {
        var data = appState.polygons.map(p => p.geoJson);
        document.title = "UE_SAVE:" + fname + "|" + JSON.stringify(data);
    };
    window.importMap = function(json) {
        map.clearOverlays(); appState.polygons=[];
        var list = JSON.parse(json);
        list.forEach(g => {
            var p = g.properties;
            addPermanent(g, p.svCol, p.svOp, p.svLine, p.name);
        });
    };
    window.focusPoly = function(id) {
        var t = appState.polygons.find(p=>p.geoJson.properties.id === id);
        if(t) {
            var b = new BMapGL.Bounds();
            var path = t.overlay.getPath(); // è¿™é‡Œå¦‚æœæ˜¯MultiPolyå¯èƒ½åªå–ä¸€éƒ¨åˆ†ï¼Œæš‚ç®€åŒ–
            path.forEach(pt=>b.extend(pt));
            map.setViewport(b);
            // é—ªçƒä¸€ä¸‹
            var old = t.overlay.getStrokeColor();
            t.overlay.setStrokeColor("red"); t.overlay.setStrokeWeight(4);
            setTimeout(()=>{ t.overlay.setStrokeColor(old); t.overlay.setStrokeWeight(1); }, 800);
        }
    };
    window.deletePoly = function(id) {
        var idx = appState.polygons.findIndex(p=>p.geoJson.properties.id === id);
        if(idx>-1) { map.removeOverlay(appState.polygons[idx].overlay); appState.polygons.splice(idx,1); }
    };
</script>
-->