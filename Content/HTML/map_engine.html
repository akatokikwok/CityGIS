<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <title>UE5 Map Engine</title>
    <style>
        /* åŸºç¡€æ ·å¼ */
        html, body, #map_container
        {
            width: 100%;
            height: 100%;
            overflow: hidden;
            margin: 0;
            padding: 0;
            font-family: "å¾®è½¯é›…é»‘";
        }

        .anchorBL, .BMap_cpyCtrl
        {
            display: none;
        }

        .BMapLabel
        {
            background: transparent !important;
            border: none !important;
            font-size: 14px !important;
            font-weight: bold !important;
            text-shadow: 1px 1px 2px black, -1px -1px 2px black;
            pointer-events: none;
        }

        /* æ‚¬æµ®ç»„ä»¶ */
        #style_toolbox
        {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 9990;
            width: 220px;
            backdrop-filter: blur(5px);
            border: 1px solid #eee;
        }

        .tool-row
        {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 13px;
            color: #555;
        }

        input[type=color]
        {
            border: none;
            width: 40px;
            height: 25px;
            cursor: pointer;
            background: none;
        }

        input[type=range]
        {
            width: 100px;
            cursor: pointer;
        }

        .val-display
        {
            font-size: 12px;
            color: #007bff;
            font-weight: bold;
            width: 30px;
            text-align: right;
        }

        #filter_panel
        {
            position: fixed;
            top: 280px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 9990;
            width: 180px;
            backdrop-filter: blur(5px);
            border: 1px solid #eee;
            max-height: 55vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .filter-item
        {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
            cursor: pointer;
        }

        .filter-item input
        {
            margin-right: 8px;
            cursor: pointer;
        }

        .filter-group-title
        {
            font-weight: bold;
            margin-top: 10px;
            margin-bottom: 5px;
            font-size: 12px;
            color: #007bff;
            border-top: 1px dashed #eee;
            padding-top: 5px;
        }

        .filter-actions
        {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .filter-btn
        {
            flex: 1;
            padding: 4px;
            font-size: 10px;
            border: 1px solid #ccc;
            background: #f0f0f0;
            cursor: pointer;
            border-radius: 4px;
        }

        .filter-btn:hover
        {
            background: #e0e0e0;
        }

        #mode_select_modal
        {
            display: none;
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 10000;
            background: white;
            width: 320px;
            padding: 25px;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
        }

        .mode-btn
        {
            display: block;
            width: 100%;
            padding: 15px;
            margin-bottom: 15px;
            border: 2px solid #eee;
            border-radius: 10px;
            background: #f9f9f9;
            cursor: pointer;
            transition: 0.2s;
            text-align: left;
        }

        .mode-btn:hover
        {
            border-color: #007bff;
            background: #eef7ff;
        }

        .mode-btn strong
        {
            display: block;
            font-size: 16px;
            margin-bottom: 4px;
            color: #333;
        }

        .mode-btn span
        {
            font-size: 12px;
            color: #666;
        }

        #save_modal
        {
            display: none;
            position: fixed;
            left: 50%;
            bottom: 80px;
            transform: translateX(-50%);
            z-index: 9999;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(12px);
            width: 280px;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            border: 1px solid #eee;
            animation: popUp 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }

        @keyframes popUp
        {
            from { bottom: -200px; opacity: 0; }
            to { bottom: 80px; opacity: 1; }
        }

        #save_modal h4
        {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #333;
            text-align: center;
        }

        .input-label
        {
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
            display: block;
        }

        select, input[type=text], input[type=number]
        {
            width: 100%;
            padding: 8px;
            margin-bottom: 12px;
            box-sizing: border-box;
            border: 1px solid #ddd;
            border-radius: 6px;
            outline: none;
            font-size: 14px;
        }

        #parent_container
        {
            display: none;
            background: #f9f9f9;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 10px;
            border: 1px dashed #ccc;
        }

        .btn-group
        {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-top: 10px;
        }

        .btn-group button
        {
            flex: 1;
            padding: 8px;
            cursor: pointer;
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: bold;
        }

        #btn_confirm, #btn_search_confirm
        {
            background-color: #007bff;
        }

        #btn_confirm:hover, #btn_search_confirm:hover
        {
            background-color: #0056b3;
        }

        #btn_cancel, #btn_search_cancel
        {
            background-color: #6c757d;
        }

        #btn_cancel:hover, #btn_search_cancel:hover
        {
            background-color: #5a6268;
        }

        .checkbox-row
        {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 12px;
            padding: 8px;
            background: #f0f8ff;
            border-radius: 6px;
            cursor: pointer;
            border: 1px dashed #a0cfff;
        }

        .checkbox-row input
        {
            width: auto;
            margin-right: 8px;
            cursor: pointer;
        }

        .checkbox-row strong
        {
            font-size: 13px;
            color: #0056b3;
        }

        #hint_bar
        {
            display: none;
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 9998;
            pointer-events: none;
        }
        
        #search_modal
        {
            display: none;
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 10001;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            width: 260px;
            padding: 25px;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
            border: 1px solid #eee;
        }
        
        #search_modal h4
        {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #333;
        }
    </style>
    
    <script type="text/javascript" src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=REwU3A6aymH7RUEsO3QUhzietfLDDfRk"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
</head>
<body>
    <div id="map_container"></div>
    <div id="hint_bar">æ“ä½œæç¤º...</div>

    <div id="filter_panel">
        <h4>ğŸ” åŒºåŸŸç­›é€‰ (å¤šé€‰)</h4>
        <div class="filter-actions">
            <button class="filter-btn" onclick="selectAllFilters()">âœ… é€‰æ‹©æ‰€æœ‰</button>
            <button class="filter-btn" onclick="clearAllFilters()">âŒ æ¸…é™¤æ‰€æœ‰</button>
        </div>
        <div id="filter_list"></div>
    </div>
    
    <div id="style_toolbox">
        <h4>ğŸ¨ ç»˜å›¾æ ·å¼æ¿</h4>
        <div class="tool-row">
            <span>å¡«å……é¢œè‰²</span> <input type="color" id="tool_color" value="#3388ff" onchange="updateStyleState()">
        </div>
        <div class="tool-row">
            <span>ä¸é€æ˜åº¦</span> <input type="range" id="tool_opacity" min="0.1" max="1.0" step="0.1" value="0.5" oninput="updateStyleState()">
            <span id="opacity_val" class="val-display">0.5</span>
        </div>
        <div class="tool-row" id="row_width" style="display:none; border-top:1px dashed #eee; padding-top:10px;">
            <span>é“è·¯å®½åº¦(ç±³)</span>
            <input type="range" id="tool_width" min="2" max="50" step="1" value="10" oninput="document.getElementById('width_val').innerText=this.value">
            <span id="width_val" class="val-display">10</span>
        </div>
    </div>
    
    <div id="mode_select_modal">
        <h3>ğŸ› ï¸ é€‰æ‹©ç»˜åˆ¶æ–¹æ¡ˆ</h3>
        <div class="mode-btn" onclick="startDraw('Freehand')">
            <strong>æ–¹æ¡ˆä¸€ï¼šæ‰‹ç»˜æ‹–æ‹½</strong> <span>æŒ‰ä½å·¦é”®æ‹–åŠ¨ï¼Œæ¾å¼€å³é—­åˆã€‚</span>
        </div>
        <div class="mode-btn" onclick="startDraw('Polyline')">
            <strong>æ–¹æ¡ˆäºŒï¼šç‚¹å¯¹ç‚¹æŠ˜çº¿</strong> <span>ç‚¹å‡»å®šç‚¹ï¼ŒåŒå‡»é—­åˆã€‚</span>
        </div>
        <div class="mode-btn" onclick="startDraw('PolylineRoad')">
            <strong>æ–¹æ¡ˆä¸‰ï¼šé“è·¯ (ç‚¹å¯¹ç‚¹)</strong> <span>ç‚¹å‡»å®šç‚¹ï¼Œç”Ÿæˆé“è·¯ã€‚</span>
        </div>
        <div class="mode-btn" onclick="startDraw('FreehandRoad')">
            <strong>æ–¹æ¡ˆå››ï¼šé“è·¯ (æ‰‹ç»˜æ‹–æ‹½)</strong> <span>æŒ‰ä½æ‹–åŠ¨ï¼Œç”Ÿæˆé“è·¯ã€‚</span>
        </div>
        <div style="margin-top:15px; font-size:12px; color:#999; cursor:pointer;" onclick="setMode('browse')">å–æ¶ˆè¿”å›</div>
    </div>
    
    <div id="save_modal">
        <h4 id="modal_title">åŒºåŸŸä¿å­˜</h4>
        <label class="checkbox-row" style="display:flex;justify-content:center;margin-bottom:10px;">
            <input type="checkbox" id="snap_toggle" checked> <strong>ğŸ§² è‡ªåŠ¨å¸é™„</strong>
        </label>
        
        <div id="color_filter_box">
            <span class="input-label">åˆ†æç»“æœ:</span>
            <select id="color_selector">
                <option value="yellow">ğŸŸ¡ æ–°æ‹“å±•åŒº</option>
                <option value="purple">ğŸŸ£ å•ä¾§è¦†ç›–</option>
                <option value="pink">ğŸŒ¸ é‡å æ ¸å¿ƒ</option>
                <option value="all">ğŸ’  æ‰€æœ‰åŒºåŸŸ</option>
            </select>
        </div>
        
        <span class="input-label">å½’å±å±‚çº§:</span>
        <select id="type_selector" onchange="onTypeChanged()">
            <option value="District">1çº§ - åŒºé•‡</option>
            <option value="Street" selected>2çº§ - è¡—é“</option>
            <option value="Community">3çº§ - å»ºç­‘/å°åŒº</option>
            <option value="Custom">4çº§ - è‡ªå®šä¹‰åŒºåŸŸ (ä»å±è¡—é“)</option>
            <option value="Road">ğŸ›£ï¸ - é“è·¯/é«˜æ¶ (ç‹¬ç«‹åˆ†ç±»)</option>
            <option value="Reconstruct">âš¡ é‡æ„å›¾å—</option>
        </select>

        <div id="parent_container">
            <span class="input-label" id="parent_label">é™„ç€åˆ°:</span> <select id="parent_selector"><option value="">è¯·é€‰æ‹©...</option></select>
        </div>
        
        <span class="input-label">é«˜åº¦ (ç±³, å¯é€‰):</span>
        <input type="number" id="poly_height_input" placeholder="ä¾‹å¦‚: 20 (é«˜æ¶æ¡¥)">
        
        <span class="input-label">è‡ªå®šä¹‰æ ‡ç­¾ (å¯é€‰):</span>
        <input type="text" id="poly_tag_input" placeholder="ä¾‹å¦‚: å•†ä¸šåŒº...">
        
        <span class="input-label">åŒºåŸŸåç§°:</span>
        <input type="text" id="poly_name_input" placeholder="è¯·è¾“å…¥åç§°">
        
        <div class="btn-group">
            <button id="btn_cancel" onclick="closeModal()" style="background:#6c757d;">ä¸¢å¼ƒ</button>
            <button id="btn_confirm" onclick="confirmSave()">ä¿å­˜</button>
        </div>
    </div>

    <div id="search_modal">
        <h4>ğŸ” æœç´¢åŒºåŸŸ</h4>
        <input type="text" id="search_input" placeholder="è¾“å…¥åŒºåŸŸåç§°..." style="margin-bottom: 15px;">
        <div class="btn-group">
            <button id="btn_search_cancel" onclick="closeSearchModal()" style="background:#6c757d;">å–æ¶ˆ</button>
            <button id="btn_search_confirm" onclick="confirmSearch()">ç¡®è®¤</button>
        </div>
    </div>

<script>
    window.onerror = function(msg, url, line)
    {
        console.log("UE_ERROR:JS_Error:" + msg + " Line:" + line);
    };

    document.oncontextmenu = function()
    {
        return false;
    };

    var map = new BMapGL.Map("map_container");
    map.centerAndZoom(new BMapGL.Point(121.474, 31.233), 17);
    map.enableScrollWheelZoom(true);
    map.setTilt(0);
    const MOVE_SPEED = 15;
    var appState = { mode: 'browse', drawMethod: 'None', currentStyle: { color: '#3388ff', opacity: 0.5, textColor: '#ffffff' }, polygons: [], drawPath: [], tempPolyline: null, tempMouseLine: null, canSnapClose: false, snapHintCircle: null, analysisOverlays: [], tempResultData: [], isSaving: false, isDrawing: false, activeFilters: new Set(['District', 'Street', 'Community', 'Custom', 'Road', 'Reconstruct']) };
    var ID_COUNTER = 1;
    var DEFAULT_NAME_IDX = 1;
    var tempHighlighter = null; 
    var highlightAnimReq = null;

    function updateFilterUI()
    {
        var panel = document.getElementById('filter_list');
        panel.innerHTML = "";
        var baseTypes = ['District', 'Street', 'Community', 'Custom', 'Road', 'Reconstruct'];
        var labelMap = {'District':'åŒºé•‡', 'Street':'è¡—é“', 'Community':'å°åŒº', 'Custom':'è‡ªå®šä¹‰', 'Road':'é“è·¯', 'Reconstruct':'é‡æ„'};
        var group1 = document.createElement('div');
        group1.className = 'filter-group-title';
        group1.innerText = "åŸºç¡€ç±»å‹";
        panel.appendChild(group1);
        baseTypes.forEach(type =>
        {
            createFilterCheckbox(panel, type, labelMap[type], type);
        });
        var allTags = new Set();
        appState.polygons.forEach(p =>
        {
            var tag = p.geoJson.properties.customTag;
            if (tag && tag.trim() !== "")
            {
                allTags.add(tag);
            }
        });
        if (allTags.size > 0)
        {
            var group2 = document.createElement('div');
            group2.className = 'filter-group-title';
            group2.innerText = "è‡ªå®šä¹‰æ ‡ç­¾";
            panel.appendChild(group2);
            allTags.forEach(tag =>
            {
                createFilterCheckbox(panel, tag, tag, 'TAG:' + tag);
            });
        }
    }

    function createFilterCheckbox(container, id, labelText, filterKey)
    {
        var row = document.createElement('label');
        row.className = 'filter-item';
        var chk = document.createElement('input');
        chk.type = 'checkbox';
        chk.checked = appState.activeFilters.has(id);
        chk.onchange = function()
        {
            if (chk.checked)
            {
                appState.activeFilters.add(id);
            }
            else
            {
                appState.activeFilters.delete(id);
            }
            executeMultiFilter();
        };
        row.appendChild(chk);
        row.appendChild(document.createTextNode(labelText));
        container.appendChild(row);
    }

    function selectAllFilters()
    {
        ['District', 'Street', 'Community', 'Custom', 'Road', 'Reconstruct'].forEach(t => appState.activeFilters.add(t));
        appState.polygons.forEach(p =>
        {
            var tag = p.geoJson.properties.customTag;
            if (tag)
            {
                appState.activeFilters.add(tag);
            }
        });
        updateFilterUI();
        executeMultiFilter();
    }

    function clearAllFilters()
    {
        appState.activeFilters.clear();
        updateFilterUI();
        executeMultiFilter();
    }

    function executeMultiFilter()
    {
        appState.polygons.forEach(p =>
        {
            var type = p.geoJson.properties.customType;
            var tag = p.geoJson.properties.customTag;
            var showByType = appState.activeFilters.has(type);
            var showByTag = tag && appState.activeFilters.has(tag);
            var shouldShow = showByType || showByTag;
            var ovs = Array.isArray(p.overlay) ? p.overlay : [p.overlay];
            ovs.forEach(o =>
            {
                if (shouldShow)
                {
                    o.show();
                }
                else
                {
                    o.hide();
                }
            });
            if (p.label)
            {
                if (shouldShow)
                {
                    p.label.show();
                }
                else
                {
                    p.label.hide();
                }
            }
        });
    }

    window.updateStyleState = function()
    {
        var col = document.getElementById('tool_color').value;
        var op = parseFloat(document.getElementById('tool_opacity').value);
        document.getElementById('opacity_val').innerText = op;
        appState.currentStyle.color = col;
        appState.currentStyle.opacity = op;
        if (appState.isDrawing && appState.tempPolyline)
        {
            appState.tempPolyline.setStrokeColor(col);
        }
    };

    window.setMode = function(mode)
    {
        appState.mode = mode;
        closeModal();
        clearAnalysis();
        clearTemp();
        appState.isDrawing = false;
        appState.drawPath = [];
        appState.drawMethod = 'None';
        document.getElementById('mode_select_modal').style.display = 'none';
        var toolbox = document.getElementById('style_toolbox');
        if (mode === 'edit')
        {
            toolbox.style.display = 'block';
            map.disableDragging();
            document.getElementById('mode_select_modal').style.display = 'block';
        }
        else if (mode === 'reconstruct')
        {
            toolbox.style.display = 'none';
            map.disableDragging();
            appState.drawMethod = 'Freehand';
            appState.currentStyle = { color: '#800080', opacity: 0.5, textColor: '#ffffff' };
            showHint("WASDç§»åŠ¨ | å·¦é”®æ‰‹ç»˜ | é‡æ„æ¨¡å¼");
        }
        else
        {
            toolbox.style.display = 'none';
            map.enableDragging();
            map.setDefaultCursor("default");
            hideHint();
        }
        document.getElementById('row_width').style.display = 'none';
    };

    window.startDraw = function(method)
    {
        appState.drawMethod = method;
        document.getElementById('mode_select_modal').style.display = 'none';
        updateStyleState();
        if (method === 'PolylineRoad' || method === 'FreehandRoad')
        {
            document.getElementById('row_width').style.display = 'flex';
            if (method === 'FreehandRoad')
            {
                showHint("ã€å·¦é”®æ‹–æ‹½ã€‘ç»˜åˆ¶ä¸­å¿ƒçº¿ | æ¾å¼€ç”Ÿæˆé“è·¯");
            }
            else
            {
                showHint("ã€å·¦é”®ç‚¹å‡»ã€‘å®šç‚¹ | ã€åŒå‡»ã€‘ç”Ÿæˆé“è·¯");
            }
        }
        else
        {
            document.getElementById('row_width').style.display = 'none';
            if (method === 'Freehand')
            {
                showHint("ã€WASDã€‘ç§»åŠ¨ | ã€å·¦é”®æ‹–æ‹½ã€‘ç»˜åˆ¶");
            }
            else
            {
                showHint("ã€WASDã€‘ç§»åŠ¨ | ã€å·¦é”®ç‚¹å‡»ã€‘å®šç‚¹ | ã€åŒå‡»ã€‘é—­åˆ");
            }
        }
        map.setDefaultCursor("crosshair");
    };

    var keyState = { w: false, a: false, s: false, d: false };
    var isPanningLoopActive = false;
    document.addEventListener('keydown', function(e)
    {
        if ((e.ctrlKey || e.metaKey) && (e.key === 'f' || e.key === 'F'))
        {
            e.preventDefault();
            openSearchModal();
        }
        if (e.target.tagName === 'INPUT')
        {
            return;
        }
        var k = e.key.toLowerCase();
        if (['w','a','s','d'].includes(k))
        {
            keyState[k] = true;
            if (!isPanningLoopActive)
            {
                isPanningLoopActive = true;
                panMapLoop();
            }
        }
    });
    
    document.addEventListener('keyup', function(e)
    {
        var k = e.key.toLowerCase();
        if (['w','a','s','d'].includes(k))
        {
            keyState[k] = false;
        }
    });
    
    document.getElementById('search_input').addEventListener('keydown', function(e)
    {
        if (e.key === 'Enter')
        {
            confirmSearch();
        }
    });

    function panMapLoop()
    {
        if (!keyState.w && !keyState.a && !keyState.s && !keyState.d)
        {
            isPanningLoopActive = false;
            return;
        }
        var centerPt = map.getCenter();
        var centerPx = map.pointToPixel(centerPt);
        var dx = 0;
        var dy = 0;
        if (keyState.w) dy -= MOVE_SPEED;
        if (keyState.s) dy += MOVE_SPEED;
        if (keyState.a) dx -= MOVE_SPEED;
        if (keyState.d) dx += MOVE_SPEED;
        var newCenterPx = new BMapGL.Pixel(centerPx.x + dx, centerPx.y + dy);
        var newCenterPt = map.pixelToPoint(newCenterPx);
        map.setCenter(newCenterPt, { noAnimation: true });
        requestAnimationFrame(panMapLoop);
    }

    var container = document.getElementById('map_container');
    container.addEventListener('mousedown', function(e)
    {
        if (appState.mode === 'browse') return;
        if (e.target.closest('#save_modal') || e.target.closest('#mode_select_modal') || e.target.closest('#style_toolbox') || e.target.closest('#filter_panel') || e.target.closest('#search_modal')) return;
        if (e.button !== 0) return;
        
        if (appState.drawMethod === 'Freehand' || appState.drawMethod === 'FreehandRoad')
        {
            handleFreehandDown(e);
        }
        else if (appState.drawMethod === 'Polyline' || appState.drawMethod === 'PolylineRoad')
        {
            handlePolylineDown(e);
        }
    });

    container.addEventListener('mousemove', function(e)
    {
        if (appState.mode === 'browse') return;
        if (appState.drawMethod === 'Freehand' || appState.drawMethod === 'FreehandRoad')
        {
            handleFreehandMove(e);
        }
        else if (appState.drawMethod === 'Polyline' || appState.drawMethod === 'PolylineRoad')
        {
            handlePolylineMove(e);
        }
    });

    container.addEventListener('mouseup', function(e)
    {
        if (appState.mode === 'browse') return;
        if (e.button !== 0) return;
        if (appState.drawMethod === 'Freehand' || appState.drawMethod === 'FreehandRoad')
        {
            handleFreehandUp(e);
        }
    });

    container.addEventListener('dblclick', function(e)
    {
        if (appState.mode === 'browse') return;
        if (appState.drawMethod === 'Polyline' || appState.drawMethod === 'PolylineRoad')
        {
            finishPolyline();
        }
    });

    function handleFreehandDown(e)
    {
        if (!appState.isDrawing)
        {
            appState.isDrawing = true;
            var pt = map.pixelToPoint(new BMapGL.Pixel(e.clientX, e.clientY));
            appState.drawPath = [pt];
            appState.canSnapClose = false;
        }
    }

    function handleFreehandMove(e)
    {
        if (appState.isDrawing)
        {
            var currentPt = map.pixelToPoint(new BMapGL.Pixel(e.clientX, e.clientY));
            appState.drawPath.push(currentPt);
            redrawTempPolyline();
            checkSnapProximity(currentPt);
        }
    }

    function handleFreehandUp(e)
    {
        if (appState.isDrawing)
        {
            appState.isDrawing = false;
            finishDraw();
        }
    }

    function handlePolylineDown(e)
    {
        var pt = map.pixelToPoint(new BMapGL.Pixel(e.clientX, e.clientY));
        appState.drawPath.push(pt);
        redrawTempPolyline();
        appState.isDrawing = true;
    }

    function handlePolylineMove(e)
    {
        if (appState.isDrawing && appState.drawPath.length > 0)
        {
            var lastPt = appState.drawPath[appState.drawPath.length - 1];
            var mousePt = map.pixelToPoint(new BMapGL.Pixel(e.clientX, e.clientY));
            if (appState.tempMouseLine)
            {
                map.removeOverlay(appState.tempMouseLine);
            }
            appState.tempMouseLine = new BMapGL.Polyline([lastPt, mousePt], { strokeColor: appState.currentStyle.color, strokeWeight: 2, strokeStyle: 'dashed' });
            map.addOverlay(appState.tempMouseLine);
        }
    }

    function finishPolyline()
    {
        if (appState.drawPath.length < 2) return;
        if (appState.tempMouseLine)
        {
            map.removeOverlay(appState.tempMouseLine);
        }
        finishDraw();
    }

    function redrawTempPolyline()
    {
        if (appState.tempPolyline)
        {
            map.removeOverlay(appState.tempPolyline);
        }
        appState.tempPolyline = new BMapGL.Polyline(appState.drawPath, { strokeColor: appState.currentStyle.color, strokeWeight: 2 });
        map.addOverlay(appState.tempPolyline);
    }

    function checkSnapProximity(currentPt)
    {
        if (appState.drawMethod.includes('Road')) return;
        
        if (appState.drawPath.length < 10) return;
        var startPt = appState.drawPath[0];
        var pixStart = map.pointToPixel(new BMapGL.Point(startPt.lng, startPt.lat));
        var pixCurrent = map.pointToPixel(new BMapGL.Point(currentPt.lng, currentPt.lat));
        var dist = Math.sqrt(Math.pow(pixStart.x - pixCurrent.x, 2) + Math.pow(pixStart.y - pixCurrent.y, 2));
        if (dist < 20)
        {
            appState.canSnapClose = true;
            if (!appState.snapHintCircle)
            {
                appState.snapHintCircle = new BMapGL.Circle(new BMapGL.Point(startPt.lng, startPt.lat), 5, {strokeColor: "white", strokeWeight: 2, fillColor: "#FFD700", fillOpacity: 0.9});
                map.addOverlay(appState.snapHintCircle);
            }
        }
        else
        {
            appState.canSnapClose = false;
            if (appState.snapHintCircle)
            {
                map.removeOverlay(appState.snapHintCircle);
                appState.snapHintCircle = null;
            }
        }
    }

    function finishDraw()
    {
        if (appState.drawPath.length < 2)
        {
            clearTemp();
            return;
        }
        
        if (appState.drawMethod.includes('Road'))
        {
            var widthMeters = parseFloat(document.getElementById('tool_width').value) || 10;
            var widthKm = widthMeters / 1000.0;
            
            var coords = appState.drawPath.map(p => [p.lng, p.lat]);
            var line = turf.lineString(coords);
            var buffered = turf.buffer(line, widthKm, {units: 'kilometers'});
            
            document.getElementById('type_selector').value = 'Road';
            onTypeChanged();
            
            prepareSingleSave(buffered);
        }
        else
        {
            if (appState.canSnapClose)
            {
                appState.drawPath.push(appState.drawPath[0]);
            }
            else
            {
                appState.drawPath.push(appState.drawPath[0]);
            }
            var coords = appState.drawPath.map(p => [p.lng, p.lat]);
            var rawGeo = turf.polygon([coords]);
            var simpleGeo = turf.simplify(rawGeo, {tolerance: 0.00001, highQuality: false});
            if (appState.mode === 'edit')
            {
                prepareSingleSave(simpleGeo);
            }
            else if (appState.mode === 'reconstruct')
            {
                executeAnalysis(simpleGeo);
            }
        }
        clearTemp();
        hideHint();
    }

    function snapPolygon(inputGeo)
    {
        var existingPoints = [];
        appState.polygons.forEach(p =>
        {
            if (p.geoJson && p.geoJson.geometry)
            {
                var coords = turf.coordAll(p.geoJson);
                existingPoints = existingPoints.concat(coords);
            }
        });
        if (existingPoints.length === 0) return inputGeo;
        var targetPointsFC = turf.featureCollection(existingPoints.map(c => turf.point(c)));
        var SNAP_THRESHOLD = 0.05;
        var oldCoords = inputGeo.geometry.coordinates;
        var newCoords = oldCoords.map(ring =>
        {
            var ringPoints = [];
            ring.forEach((ptCoords, idx) =>
            {
                var fromPt = turf.point(ptCoords);
                var nearest = turf.nearestPoint(fromPt, targetPointsFC);
                var dist = turf.distance(fromPt, nearest);
                var finalCoords = ptCoords;
                if (dist < SNAP_THRESHOLD)
                {
                    console.log("âš¡ Snapped!");
                    finalCoords = nearest.geometry.coordinates;
                }
                if (ringPoints.length > 0)
                {
                    var lastPt = ringPoints[ringPoints.length - 1];
                    if (lastPt[0] === finalCoords[0] && lastPt[1] === finalCoords[1]) return;
                }
                ringPoints.push(finalCoords);
            });
            if (ringPoints.length > 2)
            {
                var first = ringPoints[0];
                var last = ringPoints[ringPoints.length - 1];
                if (first[0] !== last[0] || first[1] !== last[1])
                {
                    ringPoints.push(first);
                }
            }
            return ringPoints;
        });
        var snappedPoly = turf.polygon(newCoords, inputGeo.properties);
        return turf.cleanCoords(snappedPoly);
    }

    function executeAnalysis(polyX)
    {
        clearAnalysis();
        appState.tempResultData = [];
        if (appState.polygons.length === 0)
        {
            prepareSingleSave(polyX);
            return;
        }
        try
        {
            var featX = turf.feature(polyX.geometry);
            var existFeats = appState.polygons.map(p => turf.feature(p.geoJson.geometry));
            var unionC = null;
            for (let i = 0; i < existFeats.length; i++)
            {
                for (let j = i + 1; j < existFeats.length; j++)
                {
                    var inter = turf.intersect(existFeats[i], existFeats[j]);
                    if (inter) unionC = unionC ? turf.union(unionC, inter) : inter;
                }
            }
            var interXC = unionC ? turf.intersect(featX, unionC) : null;
            if (interXC) cacheResult(interXC, "#FFC0CB", 0.6, "é‡å æ ¸å¿ƒ", false, 'pink');
            var unionAll = existFeats[0];
            for (let i = 1; i < existFeats.length; i++) unionAll = turf.union(unionAll, existFeats[i]);
            var interTotal = turf.intersect(featX, unionAll);
            var interPurple = (interTotal && interXC) ? turf.difference(interTotal, interXC) : interTotal;
            if (interPurple) cacheResult(interPurple, "#800080", 0.4, "å•ä¾§è¦†ç›–", false, 'purple');
            var resE = turf.difference(featX, unionAll);
            if (resE) cacheResult(resE, "yellow", 0.3, "æ–°æ‹“å±•åŒº", false, 'yellow');
            showModal(true);
        }
        catch (e)
        {
            console.log("UE_ERROR:" + e.message);
            alert("åˆ†æé”™è¯¯");
        }
    }

    function cacheResult(geo, col, op, name, line, type)
    {
        var geoms = flattenGeo(geo);
        geoms.forEach(path =>
        {
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4}) : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1});
            map.addOverlay(ov);
            appState.analysisOverlays.push(ov);
        });
        if (!type) type = "Reconstruct";
        appState.tempResultData.push({geoJson:geo, color:col, opacity:op, rawType:type, isLine:line});
    }

    function prepareSingleSave(geoJson)
    {
        appState.tempResultData = [];
        cacheResult(geoJson, appState.currentStyle.color, appState.currentStyle.opacity, 'Temp', false, 'single');
        showModal(false);
    }

    function showModal(isMulti)
    {
        var modal = document.getElementById('save_modal');
        var colorBox = document.getElementById('color_filter_box');
        var colorSel = document.getElementById('color_selector');
        document.getElementById('poly_tag_input').value = "";
        document.getElementById('poly_height_input').value = "";
        if (isMulti)
        {
            colorBox.style.display = 'block';
        }
        else
        {
            colorBox.style.display = 'none';
        }
        document.getElementById('poly_name_input').value = "æˆ‘çš„åŒºåŸŸ" + DEFAULT_NAME_IDX;
        onTypeChanged();
        modal.style.display = 'block';
    }

    function closeModal()
    {
        document.getElementById('save_modal').style.display = 'none';
        clearAnalysis();
    }

    window.onTypeChanged = function()
    {
        var type = document.getElementById('type_selector').value;
        var parentContainer = document.getElementById('parent_container');
        var parentSelector = document.getElementById('parent_selector');
        parentSelector.innerHTML = '<option value="">è¯·é€‰æ‹©...</option>';
        var targetParentType = "";
        if (type === 'District')
        {
            parentContainer.style.display = 'none';
            return;
        }
        else if (type === 'Street')
        {
            targetParentType = 'District';
        }
        else if (type === 'Community')
        {
            targetParentType = 'Street';
        }
        else if (type === 'Custom' || type === 'Road')
        {
            targetParentType = 'Street';
        }
        else
        {
            parentContainer.style.display = 'none';
            return;
        }
        parentContainer.style.display = 'block';
        var parents = appState.polygons.filter(p => p.geoJson.properties.customType === targetParentType);
        if (parents.length === 0)
        {
            var opt = document.createElement('option');
            opt.text = "âš ï¸ æš‚æ— ä¸Šçº§æ•°æ®";
            opt.disabled = true;
            opt.selected = true;
            parentSelector.add(opt);
        }
        else
        {
            parents.forEach(p =>
            {
                var opt = document.createElement('option');
                opt.value = p.geoJson.properties.id;
                opt.text = p.geoJson.properties.name;
                parentSelector.add(opt);
            });
        }
    };

    window.confirmSave = function()
    {
        if (appState.isSaving) return;
        var nameInput = document.getElementById('poly_name_input').value || "æœªå‘½å";
        var selectedType = document.getElementById('type_selector').value;
        var parentId = "";
        if (selectedType !== 'District' && selectedType !== 'Reconstruct' && selectedType !== 'Road')
        {
            var pSel = document.getElementById('parent_selector');
            parentId = pSel.value;
            if (!parentId)
            {
                alert("è¯·é€‰æ‹©éš¶å±çš„çˆ¶çº§åŒºåŸŸï¼");
                return;
            }
        }
        if (nameInput === "æˆ‘çš„åŒºåŸŸ" + DEFAULT_NAME_IDX)
        {
            DEFAULT_NAME_IDX++;
        }
        var toSave = appState.tempResultData;
        var tagInput = document.getElementById('poly_tag_input').value.trim();
        var heightInput = parseFloat(document.getElementById('poly_height_input').value) || 0;
        var isSnapEnabled = document.getElementById('snap_toggle').checked;
        if (isSnapEnabled)
        {
            toSave.forEach((item) =>
            {
                try
                {
                    if (item.geoJson.geometry.type === 'Polygon')
                    {
                        item.geoJson = snapPolygon(item.geoJson);
                    }
                }
                catch (e) {}
            });
        }
        document.getElementById('save_modal').style.display = 'none';
        appState.isSaving = true;
        processSaveQueue(toSave, nameInput, selectedType, parentId, tagInput, heightInput, 0);
    };

    function processSaveQueue(list, baseName, typeStr, pid, tag, height, index)
    {
        if (index >= list.length)
        {
            appState.tempResultData = [];
            appState.isSaving = false;
            return;
        }
        var item = list[index];
        var finalName = (list.length > 1) ? (baseName + "_" + item.rawType + "_" + (index + 1)) : baseName;
        var txtColorToSave = appState.currentStyle.textColor || '#ffffff';
        addPermanent(item.geoJson, item.color, item.opacity, item.isLine, finalName, typeStr, pid, txtColorToSave, tag, height);
        setTimeout(function()
        {
            processSaveQueue(list, baseName, typeStr, pid, tag, height, index + 1);
        }, 300);
    }

    function addPermanent(geo, col, op, line, name, typeStr, parentId, txtCol, tag, height)
    {
        var id = 'poly_' + (ID_COUNTER++);
        if (!parentId) parentId = "None";
        if (!txtCol) txtCol = "yellow";
        if (!tag) tag = "";
        if (!height) height = 0;
        geo.properties = { id: id, name: name, svCol: col, svOp: op, svLine: line, customType: typeStr, pid: parentId, svTxtCol: txtCol, customTag: tag, customHeight: height };
        var polygonOverlays = [];
        var geoms = flattenGeo(geo);
        geoms.forEach(path =>
        {
            var ov = line ? new BMapGL.Polyline(path, {strokeColor:col, strokeWeight:4, strokeOpacity:op}) : new BMapGL.Polygon(path, {fillColor:col, fillOpacity:op, strokeColor:col, strokeWeight:1});
            
            // ã€åŒå‡»èšç„¦ã€‘
            ov.addEventListener('dblclick', function()
            {
                window.focusPoly(id);
                // é€šçŸ¥ C++
                console.log("UE_DBLCLICK:" + id);
            });

            // ã€æ‚¬æµ®é«˜äº®ã€‘
            ov.addEventListener('mouseover', function()
            {
                highlightPoly(id, path);
            });
            ov.addEventListener('mouseout', function()
            {
                unhighlightPoly();
            });

            ov.customData = { id: id, type: typeStr, tag: tag };
            map.addOverlay(ov);
            polygonOverlays.push(ov);
        });
        var label = null;
        try
        {
            var center = turf.centerOfMass(geo).geometry.coordinates;
            var labelPt = new BMapGL.Point(center[0], center[1]);
            label = new BMapGL.Label(name, { position: labelPt, offset: new BMapGL.Size(-20, -10) });
            label.setStyle({ color: txtCol, backgroundColor: "transparent", border: "none", fontSize: "14px", fontWeight: "bold", textShadow: "1px 1px 2px black" });
            map.addOverlay(label);
        }
        catch (e) {}
        appState.polygons.push({ overlay: polygonOverlays, label: label, geoJson: geo });
        updateFilterUI();
        var randomTag = new Date().getTime();
        console.log("UE_ADD:" + id + "|" + name + "|" + typeStr + "|" + parentId + "|" + col + "|" + op + "|" + txtCol + "|" + tag + "|" + height + "|" + randomTag);
    }

    function highlightPoly(id, path)
    {
        if (appState.mode !== 'browse') return;
        unhighlightPoly();
        tempHighlighter = new BMapGL.Polyline(path, {
            strokeColor: '#00FFFF', 
            strokeWeight: 6,        
            strokeOpacity: 0.8,
            strokeStyle: 'solid'
        });
        map.addOverlay(tempHighlighter);
        var step = 0;
        var direction = 1;
        function animateGlow()
        {
            if (!tempHighlighter) return;
            step += 0.05 * direction;
            if (step >= 1) direction = -1;
            if (step <= 0) direction = 1;
            var alpha = 0.5 + (step * 0.5); 
            var weight = 6 + (step * 2);
            tempHighlighter.setStrokeOpacity(alpha);
            tempHighlighter.setStrokeWeight(weight);
            highlightAnimReq = requestAnimationFrame(animateGlow);
        }
        animateGlow();
    }

    function unhighlightPoly()
    {
        if (highlightAnimReq)
        {
            cancelAnimationFrame(highlightAnimReq);
            highlightAnimReq = null;
        }
        if (tempHighlighter)
        {
            map.removeOverlay(tempHighlighter);
            tempHighlighter = null;
        }
    }

    function openSearchModal()
    {
        document.getElementById('search_modal').style.display = 'block';
        var input = document.getElementById('search_input');
        input.value = "";
        input.focus();
    }

    function closeSearchModal()
    {
        document.getElementById('search_modal').style.display = 'none';
    }

    function confirmSearch()
    {
        var val = document.getElementById('search_input').value.trim();
        if (val)
        {
            var found = window.searchPoly(val);
            if (found)
            {
                closeSearchModal();
            }
            else
            {
                alert("æœªæ‰¾åˆ°åä¸º '" + val + "' çš„åŒºåŸŸ");
            }
        }
    }

    window.searchPoly = function(name)
    {
        var target = appState.polygons.find(p => p.geoJson.properties.name.includes(name));
        if (target)
        {
            focusPoly(target.geoJson.properties.id);
            return true;
        }
        return false;
    };

    function showHint(text)
    {
        var bar = document.getElementById('hint_bar');
        if (bar)
        {
            bar.innerText = text;
            bar.style.display = 'block';
        }
    }

    function hideHint()
    {
        var bar = document.getElementById('hint_bar');
        if (bar)
        {
            bar.style.display = 'none';
        }
    }

    window.updatePolyAttributes = function(id, newName, newColor, newOpacity, newTxtCol, newParentId)
    {
        var target = appState.polygons.find(p => p.geoJson.properties.id === id);
        if (!target) return;
        target.geoJson.properties.name = newName;
        target.geoJson.properties.svCol = newColor;
        target.geoJson.properties.svOp = newOpacity;
        target.geoJson.properties.svTxtCol = newTxtCol;
        target.geoJson.properties.pid = newParentId;
        var ovs = Array.isArray(target.overlay) ? target.overlay : [target.overlay];
        ovs.forEach(o =>
        {
            if (o instanceof BMapGL.Polygon)
            {
                o.setFillColor(newColor);
                o.setStrokeColor(newColor);
                o.setFillOpacity(parseFloat(newOpacity));
            }
            else if (o instanceof BMapGL.Polyline)
            {
                o.setStrokeColor(newColor);
                o.setStrokeOpacity(parseFloat(newOpacity));
            }
        });
        if (target.label)
        {
            target.label.setContent(newName);
            target.label.setStyle({ color: newTxtCol });
        }
    };

    window.deletePoly = function(id)
    {
        var targets = appState.polygons.filter(p => p.geoJson.properties.id === id);
        if (targets.length > 0)
        {
            targets.forEach(t =>
            {
                var ovs = Array.isArray(t.overlay) ? t.overlay : [t.overlay];
                ovs.forEach(o => map.removeOverlay(o));
                if (t.label) map.removeOverlay(t.label);
            });
            appState.polygons = appState.polygons.filter(p => p.geoJson.properties.id !== id);
            console.log("UE_LOG: Deleted poly " + id);
            updateFilterUI();
        }
    };

    window.clearTemp = function()
    {
        appState.drawPath = [];
        if (appState.tempPolyline) map.removeOverlay(appState.tempPolyline);
        if (appState.tempMouseLine) map.removeOverlay(appState.tempMouseLine);
        if (appState.snapHintCircle)
        {
            map.removeOverlay(appState.snapHintCircle);
            appState.snapHintCircle = null;
        }
        appState.canSnapClose = false;
        appState.isDrawing = false;
    };

    window.requestAllDataForSave = function()
    {
        var data = appState.polygons.map(p => p.geoJson);
        var jsonStr = JSON.stringify(data);
        console.log("UE_EXPORT_DATA:" + jsonStr);
    };

    window.exportMap = function(fname)
    {
        var data = appState.polygons.map(p => p.geoJson);
        console.log("UE_SAVE:" + fname + "|" + JSON.stringify(data));
    };

    window.importMap = function(json)
    {
        map.clearOverlays();
        appState.polygons = [];
        var list = (typeof json === 'string') ? JSON.parse(json) : json;
        list.forEach((g, i) =>
        {
            var p = g.properties;
            var h = p.customHeight || 0;
            setTimeout(() =>
            {
                addPermanent(g, p.svCol, p.svOp, p.svLine, p.name, p.customType, p.pid, p.svTxtCol, p.customTag, h);
            }, i * 50);
        });
    };

    function flattenGeo(geo)
    {
        var coords = [];
        if (!geo || !geo.geometry) return [];
        var type = geo.geometry.type;
        if (type === 'MultiPolygon') coords = geo.geometry.coordinates.map(c => c[0]);
        else if (type === 'Polygon') coords = [geo.geometry.coordinates[0]];
        else if (type === 'LineString') coords = [geo.geometry.coordinates];
        else if (type === 'MultiLineString') coords = geo.geometry.coordinates;
        var res = [];
        coords.forEach(c =>
        {
            if (c) res.push(c.map(p => new BMapGL.Point(p[0], p[1])));
        });
        return res;
    }

    function clearAnalysis()
    {
        appState.analysisOverlays.forEach(o => map.removeOverlay(o));
        appState.analysisOverlays = [];
        appState.tempResultData = [];
    }

    window.focusPoly = function(id)
    {
        var targets = appState.polygons.filter(p => p.geoJson.properties.id === id);
        if (targets.length > 0)
        {
            var allPoints = [];
            targets.forEach(t =>
            {
                var ovs = Array.isArray(t.overlay) ? t.overlay : [t.overlay];
                ovs.forEach(o =>
                {
                    var path = o.getPath();
                    if (path) allPoints = allPoints.concat(path);
                    var oldColor = o.getStrokeColor();
                    o.setStrokeColor("red");
                    o.setStrokeWeight(4);
                    setTimeout(() =>
                    {
                        o.setStrokeColor(oldColor);
                        o.setStrokeWeight(1);
                    }, 1000);
                });
            });
            if (allPoints.length > 0)
            {
                map.setViewport(allPoints, { margins: [60, 60, 60, 300], enableAnimation: true, zoomFactor: 0 });
            }
        }
        else
        {
            console.log("UE_ERROR: Not found " + id);
        }
    };
    
    updateFilterUI();
</script>
</body>
</html>